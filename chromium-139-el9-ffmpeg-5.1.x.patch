diff -up chromium-139.0.7258.5/media/ffmpeg/ffmpeg_common.cc.el9-ffmpeg-5.1.x chromium-139.0.7258.5/media/ffmpeg/ffmpeg_common.cc
--- chromium-139.0.7258.5/media/ffmpeg/ffmpeg_common.cc.el9-ffmpeg-5.1.x	2025-07-06 20:30:36.125746197 +0200
+++ chromium-139.0.7258.5/media/ffmpeg/ffmpeg_common.cc	2025-07-06 20:36:47.648896691 +0200
@@ -784,8 +784,13 @@ bool AVStreamToVideoDecoderConfig(const
   }
 
   VideoTransformation video_transformation = VideoTransformation();
+#if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(60, 31, 102)
+  for (int i = 0; i < stream->nb_side_data; i++) {
+    const auto& side_data = stream->side_data[i];
+#else
   for (const auto& side_data :
        AVCodecParametersCodedSideToSpan(stream->codecpar)) {
+#endif
     switch (side_data.type) {
       case AV_PKT_DATA_DISPLAYMATRIX: {
         CHECK_EQ(side_data.size, sizeof(int32_t) * 3 * 3);
diff -up chromium-139.0.7258.5/media/ffmpeg/ffmpeg_common.h.el9-ffmpeg-5.1.x chromium-139.0.7258.5/media/ffmpeg/ffmpeg_common.h
--- chromium-139.0.7258.5/media/ffmpeg/ffmpeg_common.h.el9-ffmpeg-5.1.x	2025-06-25 00:02:26.000000000 +0200
+++ chromium-139.0.7258.5/media/ffmpeg/ffmpeg_common.h	2025-07-06 20:30:36.131085710 +0200
@@ -93,6 +93,7 @@ inline base::span<const uint8_t> AVPacke
       base::span(packet.data, base::checked_cast<size_t>(packet.size)));
 }
 
+#if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(60, 31, 102)
 inline base::span<AVStream*> AVFormatContextToSpan(
     const AVFormatContext* codec_context) {
   // SAFETY:
@@ -114,6 +115,7 @@ inline base::span<AVPacketSideData> AVCo
       base::span(codecpar->coded_side_data,
                  base::checked_cast<size_t>(codecpar->nb_coded_side_data)));
 }
+#endif
 
 // Converts an int64_t timestamp in |time_base| units to a base::TimeDelta.
 // For example if |timestamp| equals 11025 and |time_base| equals {1, 44100}
diff -up chromium-139.0.7258.5/media/filters/audio_video_metadata_extractor.cc.el9-ffmpeg-5.1.x chromium-139.0.7258.5/media/filters/audio_video_metadata_extractor.cc
--- chromium-139.0.7258.5/media/filters/audio_video_metadata_extractor.cc.el9-ffmpeg-5.1.x	2025-06-25 00:02:26.000000000 +0200
+++ chromium-139.0.7258.5/media/filters/audio_video_metadata_extractor.cc	2025-07-06 20:30:36.131372795 +0200
@@ -109,17 +109,33 @@ bool AudioVideoMetadataExtractor::Extrac
   container_info.type = format_context->iformat->name;
   ExtractDictionary(format_context->metadata, &container_info.tags);
 
+#if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(60, 31, 102)
+  for (unsigned int i = 0; i < format_context->nb_streams; ++i) {
+    stream_infos_.push_back(StreamInfo());
+#else
   base::span<AVStream*> format_context_span =
       AVFormatContextToSpan(format_context);
   std::ranges::for_each(format_context_span, [&](AVStream* stream) {
     stream_infos_.emplace_back();
+#endif
     StreamInfo& info = stream_infos_.back();
 
+#if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(60, 31, 102)
+    AVStream* stream = format_context->streams[i];
+    if (!stream)
+      continue;
+#else
     if (!stream) {
       return;
     }
+#endif
 
+#if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(60, 31, 102)
+    for (int j = 0; j < stream->nb_side_data; j++) {
+      const AVPacketSideData& sd = stream->side_data[j];
+#else
     for (const auto& sd : AVCodecParametersCodedSideToSpan(stream->codecpar)) {
+#endif
       if (sd.type == AV_PKT_DATA_DISPLAYMATRIX) {
         CHECK_EQ(sd.size, sizeof(int32_t) * 3 * 3);
         rotation_ = VideoTransformation::FromFFmpegDisplayMatrix(
@@ -135,7 +151,11 @@ bool AudioVideoMetadataExtractor::Extrac
     ExtractDictionary(stream->metadata, &info.tags);
 
     if (!stream->codecpar) {
+#if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(60, 31, 102)
+      continue;
+#else
       return;
+#endif
     }
 
     info.type = avcodec_get_name(stream->codecpar->codec_id);
@@ -158,7 +178,11 @@ bool AudioVideoMetadataExtractor::Extrac
           reinterpret_cast<const char*>(stream->attached_pic.data),
           stream->attached_pic.size);
     }
+#if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(60, 31, 102)
+  }
+#else
   });
+#endif
 
   extracted_ = true;
   return true;
diff -up chromium-139.0.7258.5/media/filters/media_file_checker.cc.el9-ffmpeg-5.1.x chromium-139.0.7258.5/media/filters/media_file_checker.cc
--- chromium-139.0.7258.5/media/filters/media_file_checker.cc.el9-ffmpeg-5.1.x	2025-06-25 00:02:26.000000000 +0200
+++ chromium-139.0.7258.5/media/filters/media_file_checker.cc	2025-07-06 20:30:36.131615487 +0200
@@ -64,6 +64,10 @@ bool MediaFileChecker::Start(base::TimeD
   // Remember the codec context for any decodable audio or video streams.
   bool found_streams = false;
   std::vector<Decoder> stream_contexts(format_context->nb_streams);
+#if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(60, 31, 102)
+  for (size_t i = 0; i < format_context->nb_streams; ++i) {
+    AVCodecParameters* cp = format_context->streams[i]->codecpar;
+#else
   base::span<AVStream*> format_context_span =
       AVFormatContextToSpan(format_context);
   std::ranges::transform(
@@ -85,9 +89,26 @@ bool MediaFileChecker::Start(base::TimeD
           }
         }
 
+#endif
+#if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(60, 31, 102)
+    if (cp->codec_type == AVMEDIA_TYPE_AUDIO ||
+        cp->codec_type == AVMEDIA_TYPE_VIDEO) {
+      auto context = AVStreamToAVCodecContext(format_context->streams[i]);
+      if (!context)
+        continue;
+      const AVCodec* codec = avcodec_find_decoder(cp->codec_id);
+      if (codec && avcodec_open2(context.get(), codec, nullptr) >= 0) {
+        auto loop = std::make_unique<FFmpegDecodingLoop>(context.get());
+        stream_contexts[i] = {std::move(context), std::move(loop)};
+        found_streams = true;
+      }
+    }
+  }
+#else
         return Decoder{};
       });
 
+#endif
   if (!found_streams)
     return false;
 
