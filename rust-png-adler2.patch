From 3b7f74a3a15172ce0a18892948a98a10d505a29e Mon Sep 17 00:00:00 2001
From: Lukasz Anforowicz <lukasza@chromium.org>
Date: Wed, 2 Oct 2024 16:04:06 +0000
Subject: [PATCH] Roll png: 0.17.13 => 0.17.14 in //third_party/rust.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

This CL has been created semi-automatically.  The expected review
process and other details can be found at
//tools/crates/create_update_cl.md

Updated crates:

* png: 0.17.13 => 0.17.14

Removed crates:

* adler@1.0.2
* miniz_oxide@0.7.4

Chromium `supply-chain/config.toml` policy requires that the following
audit criteria are met (note that these are the *minimum* required
criteria and `supply-chain/audits.toml` can and should record a stricter
certification if possible;  see also //docs/rust-unsafe.md):

* png@0.17.14: crypto-safe, safe-to-deploy, ub-risk-2

Bug: None
Change-Id: I614fd9f78be097c28cdab35517d68d3c02bc8865
Cq-Include-Trybots: chromium/try:android-rust-arm32-rel
Cq-Include-Trybots: chromium/try:android-rust-arm64-dbg
Cq-Include-Trybots: chromium/try:android-rust-arm64-rel
Cq-Include-Trybots: chromium/try:linux-rust-x64-dbg
Cq-Include-Trybots: chromium/try:linux-rust-x64-rel
Cq-Include-Trybots: chromium/try:win-rust-x64-dbg
Cq-Include-Trybots: chromium/try:win-rust-x64-rel
Disable-Rts: True
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/5901113
Reviewed-by: Adrian Taylor <adetaylor@google.com>
Commit-Queue: ≈Åukasz Anforowicz <lukasza@chromium.org>
Cr-Commit-Position: refs/heads/main@{#1363099}
---
 third_party/rust/adler/v1/BUILD.gn            |   41 -
 third_party/rust/adler/v1/README.chromium     |    9 -
 .../rust/chromium_crates_io/Cargo.lock        |   21 +-
 ...ntroduce-a-separate-struct-Adam7Info.patch |  199 --
 ...-Passing-Adam7Info-to-fn-expand_pass.patch |  205 --
 ...ng-Adam7Info-to-fn-expand_adam7_bits.patch |  149 -
 ...stride_in_bytes-in-expand_adam7_bits.patch |  319 ---
 ...lic-API-pub-fn-expand_interlaced_row.patch |   94 -
 .../png/0106-Fix-cargo-doc-warnings.patch     |   39 -
 ...e-to-the-doc-comment-of-fn-expand_in.patch |   76 -
 ...-a-separate-interlace_info.rs-module.patch |  376 ---
 ...cting-an-unexpected-EOF-using-the-pu.patch |  129 -
 ...esuming-decoding-after-UnexpectedEof.patch |  336 ---
 .../supply-chain/audits.toml                  |    5 +
 .../supply-chain/config.toml                  |    8 +-
 .../vendor/adler-1.0.2/.cargo_vcs_info.json   |    5 -
 .../adler-1.0.2/.github/workflows/ci.yml      |   81 -
 .../vendor/adler-1.0.2/.gitignore             |    2 -
 .../vendor/adler-1.0.2/CHANGELOG.md           |   63 -
 .../vendor/adler-1.0.2/Cargo.toml             |   64 -
 .../vendor/adler-1.0.2/Cargo.toml.orig        |   68 -
 .../vendor/adler-1.0.2/LICENSE-0BSD           |   12 -
 .../vendor/adler-1.0.2/LICENSE-APACHE         |  201 --
 .../vendor/adler-1.0.2/LICENSE-MIT            |   23 -
 .../vendor/adler-1.0.2/README.md              |   39 -
 .../vendor/adler-1.0.2/RELEASE_PROCESS.md     |   13 -
 .../vendor/adler-1.0.2/benches/bench.rs       |  109 -
 .../vendor/adler-1.0.2/src/algo.rs            |  146 -
 .../vendor/adler-1.0.2/src/lib.rs             |  287 --
 .../miniz_oxide-0.7.4/.cargo-checksum.json    |    1 -
 .../miniz_oxide-0.7.4/.cargo_vcs_info.json    |    6 -
 .../vendor/miniz_oxide-0.7.4/Cargo.toml       |   74 -
 .../vendor/miniz_oxide-0.7.4/Cargo.toml.orig  |   38 -
 .../vendor/miniz_oxide-0.7.4/LICENSE          |   21 -
 .../miniz_oxide-0.7.4/LICENSE-APACHE.md       |  177 --
 .../vendor/miniz_oxide-0.7.4/LICENSE-MIT.md   |   21 -
 .../vendor/miniz_oxide-0.7.4/LICENSE-ZLIB.md  |   11 -
 .../vendor/miniz_oxide-0.7.4/Readme.md        |   44 -
 .../miniz_oxide-0.7.4/src/deflate/buffer.rs   |   58 -
 .../miniz_oxide-0.7.4/src/deflate/core.rs     | 2469 -----------------
 .../miniz_oxide-0.7.4/src/deflate/mod.rs      |  226 --
 .../miniz_oxide-0.7.4/src/deflate/stream.rs   |  121 -
 .../miniz_oxide-0.7.4/src/inflate/core.rs     | 2052 --------------
 .../miniz_oxide-0.7.4/src/inflate/mod.rs      |  343 ---
 .../src/inflate/output_buffer.rs              |   60 -
 .../miniz_oxide-0.7.4/src/inflate/stream.rs   |  423 ---
 .../vendor/miniz_oxide-0.7.4/src/lib.rs       |  211 --
 .../vendor/miniz_oxide-0.7.4/src/shared.rs    |   25 -
 .../vendor/png-0.17.13/.cargo-checksum.json   |    1 -
 .../vendor/png-0.17.13/.cargo_vcs_info.json   |    6 -
 .../.cargo-checksum.json                      |    0
 .../vendor/png-0.17.14/.cargo_vcs_info.json   |    6 +
 .../{png-0.17.13 => png-0.17.14}/CHANGES.md   |   13 +-
 .../{png-0.17.13 => png-0.17.14}/Cargo.lock   |  819 +++---
 .../{png-0.17.13 => png-0.17.14}/Cargo.toml   |    4 +-
 .../Cargo.toml.orig                           |    6 +-
 .../LICENSE-APACHE                            |    0
 .../{png-0.17.13 => png-0.17.14}/LICENSE-MIT  |    0
 .../{png-0.17.13 => png-0.17.14}/README.md    |    2 -
 .../benches/README.md                         |    0
 .../benches/decoder.rs                        |    0
 .../benches/expand_paletted.rs                |    0
 .../benches/unfilter.rs                       |    0
 .../examples/change-png-info.rs               |    0
 .../examples/corpus-bench.rs                  |    0
 .../examples/png-generate.rs                  |    0
 .../examples/pngcheck.rs                      |    8 +-
 .../examples/show.rs                          |    0
 .../{png-0.17.13 => png-0.17.14}/src/adam7.rs |    0
 .../src/benchable_apis.rs                     |    0
 .../{png-0.17.13 => png-0.17.14}/src/chunk.rs |    0
 .../src/common.rs                             |    4 +-
 .../src/decoder/interlace_info.rs             |    0
 .../src/decoder/mod.rs                        |   57 +-
 .../src/decoder/stream.rs                     |  202 +-
 .../src/decoder/transform.rs                  |    0
 .../src/decoder/transform/palette.rs          |    2 +-
 .../src/decoder/zlib.rs                       |   10 +-
 .../src/encoder.rs                            |   96 +-
 .../src/filter.rs                             |  236 +-
 .../{png-0.17.13 => png-0.17.14}/src/lib.rs   |    9 +-
 .../{png-0.17.13 => png-0.17.14}/src/srgb.rs  |    0
 .../src/test_utils.rs                         |    0
 .../src/text_metadata.rs                      |    0
 .../src/traits.rs                             |    0
 third_party/rust/miniz_oxide/v0_7/BUILD.gn    |   56 -
 .../rust/miniz_oxide/v0_7/README.chromium     |    9 -
 third_party/rust/miniz_oxide/v0_8/BUILD.gn    |   11 +-
 third_party/rust/png/v0_17/BUILD.gn           |   40 +-
 third_party/rust/png/v0_17/README.chromium    |    6 +-
 90 files changed, 904 insertions(+), 10199 deletions(-)
 delete mode 100644 third_party/rust/adler/v1/BUILD.gn
 delete mode 100644 third_party/rust/adler/v1/README.chromium
 delete mode 100644 third_party/rust/chromium_crates_io/patches/png/0101-Introduce-a-separate-struct-Adam7Info.patch
 delete mode 100644 third_party/rust/chromium_crates_io/patches/png/0102-Passing-Adam7Info-to-fn-expand_pass.patch
 delete mode 100644 third_party/rust/chromium_crates_io/patches/png/0103-Passing-Adam7Info-to-fn-expand_adam7_bits.patch
 delete mode 100644 third_party/rust/chromium_crates_io/patches/png/0104-Independent-row_stride_in_bytes-in-expand_adam7_bits.patch
 delete mode 100644 third_party/rust/chromium_crates_io/patches/png/0105-New-public-API-pub-fn-expand_interlaced_row.patch
 delete mode 100644 third_party/rust/chromium_crates_io/patches/png/0106-Fix-cargo-doc-warnings.patch
 delete mode 100644 third_party/rust/chromium_crates_io/patches/png/0107-Add-usage-example-to-the-doc-comment-of-fn-expand_in.patch
 delete mode 100644 third_party/rust/chromium_crates_io/patches/png/0201-Extract-a-separate-interlace_info.rs-module.patch
 delete mode 100644 third_party/rust/chromium_crates_io/patches/png/0202-Support-for-detecting-an-unexpected-EOF-using-the-pu.patch
 delete mode 100644 third_party/rust/chromium_crates_io/patches/png/0203-Support-for-resuming-decoding-after-UnexpectedEof.patch
 delete mode 100644 third_party/rust/chromium_crates_io/vendor/adler-1.0.2/.cargo_vcs_info.json
 delete mode 100644 third_party/rust/chromium_crates_io/vendor/adler-1.0.2/.github/workflows/ci.yml
 delete mode 100644 third_party/rust/chromium_crates_io/vendor/adler-1.0.2/.gitignore
 delete mode 100644 third_party/rust/chromium_crates_io/vendor/adler-1.0.2/CHANGELOG.md
 delete mode 100644 third_party/rust/chromium_crates_io/vendor/adler-1.0.2/Cargo.toml
 delete mode 100644 third_party/rust/chromium_crates_io/vendor/adler-1.0.2/Cargo.toml.orig
 delete mode 100644 third_party/rust/chromium_crates_io/vendor/adler-1.0.2/LICENSE-0BSD
 delete mode 100644 third_party/rust/chromium_crates_io/vendor/adler-1.0.2/LICENSE-APACHE
 delete mode 100644 third_party/rust/chromium_crates_io/vendor/adler-1.0.2/LICENSE-MIT
 delete mode 100644 third_party/rust/chromium_crates_io/vendor/adler-1.0.2/README.md
 delete mode 100644 third_party/rust/chromium_crates_io/vendor/adler-1.0.2/RELEASE_PROCESS.md
 delete mode 100644 third_party/rust/chromium_crates_io/vendor/adler-1.0.2/benches/bench.rs
 delete mode 100644 third_party/rust/chromium_crates_io/vendor/adler-1.0.2/src/algo.rs
 delete mode 100644 third_party/rust/chromium_crates_io/vendor/adler-1.0.2/src/lib.rs
 delete mode 100644 third_party/rust/chromium_crates_io/vendor/miniz_oxide-0.7.4/.cargo-checksum.json
 delete mode 100644 third_party/rust/chromium_crates_io/vendor/miniz_oxide-0.7.4/.cargo_vcs_info.json
 delete mode 100644 third_party/rust/chromium_crates_io/vendor/miniz_oxide-0.7.4/Cargo.toml
 delete mode 100644 third_party/rust/chromium_crates_io/vendor/miniz_oxide-0.7.4/Cargo.toml.orig
 delete mode 100644 third_party/rust/chromium_crates_io/vendor/miniz_oxide-0.7.4/LICENSE
 delete mode 100644 third_party/rust/chromium_crates_io/vendor/miniz_oxide-0.7.4/LICENSE-APACHE.md
 delete mode 100644 third_party/rust/chromium_crates_io/vendor/miniz_oxide-0.7.4/LICENSE-MIT.md
 delete mode 100644 third_party/rust/chromium_crates_io/vendor/miniz_oxide-0.7.4/LICENSE-ZLIB.md
 delete mode 100644 third_party/rust/chromium_crates_io/vendor/miniz_oxide-0.7.4/Readme.md
 delete mode 100644 third_party/rust/chromium_crates_io/vendor/miniz_oxide-0.7.4/src/deflate/buffer.rs
 delete mode 100644 third_party/rust/chromium_crates_io/vendor/miniz_oxide-0.7.4/src/deflate/core.rs
 delete mode 100644 third_party/rust/chromium_crates_io/vendor/miniz_oxide-0.7.4/src/deflate/mod.rs
 delete mode 100644 third_party/rust/chromium_crates_io/vendor/miniz_oxide-0.7.4/src/deflate/stream.rs
 delete mode 100644 third_party/rust/chromium_crates_io/vendor/miniz_oxide-0.7.4/src/inflate/core.rs
 delete mode 100644 third_party/rust/chromium_crates_io/vendor/miniz_oxide-0.7.4/src/inflate/mod.rs
 delete mode 100644 third_party/rust/chromium_crates_io/vendor/miniz_oxide-0.7.4/src/inflate/output_buffer.rs
 delete mode 100644 third_party/rust/chromium_crates_io/vendor/miniz_oxide-0.7.4/src/inflate/stream.rs
 delete mode 100644 third_party/rust/chromium_crates_io/vendor/miniz_oxide-0.7.4/src/lib.rs
 delete mode 100644 third_party/rust/chromium_crates_io/vendor/miniz_oxide-0.7.4/src/shared.rs
 delete mode 100644 third_party/rust/chromium_crates_io/vendor/png-0.17.13/.cargo-checksum.json
 delete mode 100644 third_party/rust/chromium_crates_io/vendor/png-0.17.13/.cargo_vcs_info.json
 rename third_party/rust/chromium_crates_io/vendor/{adler-1.0.2 => png-0.17.14}/.cargo-checksum.json (100%)
 create mode 100644 third_party/rust/chromium_crates_io/vendor/png-0.17.14/.cargo_vcs_info.json
 rename third_party/rust/chromium_crates_io/vendor/{png-0.17.13 => png-0.17.14}/CHANGES.md (92%)
 rename third_party/rust/chromium_crates_io/vendor/{png-0.17.13 => png-0.17.14}/Cargo.lock (74%)
 rename third_party/rust/chromium_crates_io/vendor/{png-0.17.13 => png-0.17.14}/Cargo.toml (98%)
 rename third_party/rust/chromium_crates_io/vendor/{png-0.17.13 => png-0.17.14}/Cargo.toml.orig (90%)
 rename third_party/rust/chromium_crates_io/vendor/{png-0.17.13 => png-0.17.14}/LICENSE-APACHE (100%)
 rename third_party/rust/chromium_crates_io/vendor/{png-0.17.13 => png-0.17.14}/LICENSE-MIT (100%)
 rename third_party/rust/chromium_crates_io/vendor/{png-0.17.13 => png-0.17.14}/README.md (89%)
 rename third_party/rust/chromium_crates_io/vendor/{png-0.17.13 => png-0.17.14}/benches/README.md (100%)
 rename third_party/rust/chromium_crates_io/vendor/{png-0.17.13 => png-0.17.14}/benches/decoder.rs (100%)
 rename third_party/rust/chromium_crates_io/vendor/{png-0.17.13 => png-0.17.14}/benches/expand_paletted.rs (100%)
 rename third_party/rust/chromium_crates_io/vendor/{png-0.17.13 => png-0.17.14}/benches/unfilter.rs (100%)
 rename third_party/rust/chromium_crates_io/vendor/{png-0.17.13 => png-0.17.14}/examples/change-png-info.rs (100%)
 rename third_party/rust/chromium_crates_io/vendor/{png-0.17.13 => png-0.17.14}/examples/corpus-bench.rs (100%)
 rename third_party/rust/chromium_crates_io/vendor/{png-0.17.13 => png-0.17.14}/examples/png-generate.rs (100%)
 rename third_party/rust/chromium_crates_io/vendor/{png-0.17.13 => png-0.17.14}/examples/pngcheck.rs (98%)
 rename third_party/rust/chromium_crates_io/vendor/{png-0.17.13 => png-0.17.14}/examples/show.rs (100%)
 rename third_party/rust/chromium_crates_io/vendor/{png-0.17.13 => png-0.17.14}/src/adam7.rs (100%)
 rename third_party/rust/chromium_crates_io/vendor/{png-0.17.13 => png-0.17.14}/src/benchable_apis.rs (100%)
 rename third_party/rust/chromium_crates_io/vendor/{png-0.17.13 => png-0.17.14}/src/chunk.rs (100%)
 rename third_party/rust/chromium_crates_io/vendor/{png-0.17.13 => png-0.17.14}/src/common.rs (99%)
 rename third_party/rust/chromium_crates_io/vendor/{png-0.17.13 => png-0.17.14}/src/decoder/interlace_info.rs (100%)
 rename third_party/rust/chromium_crates_io/vendor/{png-0.17.13 => png-0.17.14}/src/decoder/mod.rs (94%)
 rename third_party/rust/chromium_crates_io/vendor/{png-0.17.13 => png-0.17.14}/src/decoder/stream.rs (92%)
 rename third_party/rust/chromium_crates_io/vendor/{png-0.17.13 => png-0.17.14}/src/decoder/transform.rs (100%)
 rename third_party/rust/chromium_crates_io/vendor/{png-0.17.13 => png-0.17.14}/src/decoder/transform/palette.rs (99%)
 rename third_party/rust/chromium_crates_io/vendor/{png-0.17.13 => png-0.17.14}/src/decoder/zlib.rs (97%)
 rename third_party/rust/chromium_crates_io/vendor/{png-0.17.13 => png-0.17.14}/src/encoder.rs (95%)
 rename third_party/rust/chromium_crates_io/vendor/{png-0.17.13 => png-0.17.14}/src/filter.rs (83%)
 rename third_party/rust/chromium_crates_io/vendor/{png-0.17.13 => png-0.17.14}/src/lib.rs (92%)
 rename third_party/rust/chromium_crates_io/vendor/{png-0.17.13 => png-0.17.14}/src/srgb.rs (100%)
 rename third_party/rust/chromium_crates_io/vendor/{png-0.17.13 => png-0.17.14}/src/test_utils.rs (100%)
 rename third_party/rust/chromium_crates_io/vendor/{png-0.17.13 => png-0.17.14}/src/text_metadata.rs (100%)
 rename third_party/rust/chromium_crates_io/vendor/{png-0.17.13 => png-0.17.14}/src/traits.rs (100%)
 delete mode 100644 third_party/rust/miniz_oxide/v0_7/BUILD.gn
 delete mode 100644 third_party/rust/miniz_oxide/v0_7/README.chromium

diff --git a/third_party/rust/adler/v1/BUILD.gn b/third_party/rust/adler/v1/BUILD.gn
deleted file mode 100644
index a09f062e6875b6..00000000000000
--- a/third_party/rust/adler/v1/BUILD.gn
+++ /dev/null
@@ -1,41 +0,0 @@
-# Copyright 2023 The Chromium Authors
-# Use of this source code is governed by a BSD-style license that can be
-# found in the LICENSE file.
-
-# @generated from third_party/rust/chromium_crates_io/BUILD.gn.hbs by
-# tools/crates/gnrt.
-# Do not edit!
-
-import("//build/rust/cargo_crate.gni")
-
-cargo_crate("lib") {
-  crate_name = "adler"
-  epoch = "1"
-  crate_type = "rlib"
-  crate_root =
-      "//third_party/rust/chromium_crates_io/vendor/adler-1.0.2/src/lib.rs"
-  sources = [
-    "//third_party/rust/chromium_crates_io/vendor/adler-1.0.2/src/algo.rs",
-    "//third_party/rust/chromium_crates_io/vendor/adler-1.0.2/src/lib.rs",
-  ]
-  inputs = []
-
-  build_native_rust_unit_tests = false
-  edition = "2015"
-  cargo_pkg_version = "1.0.2"
-  cargo_pkg_authors = "Jonas Schievink <jonasschievink@gmail.com>"
-  cargo_pkg_name = "adler"
-  cargo_pkg_description =
-      "A simple clean-room implementation of the Adler-32 checksum"
-  library_configs -= [ "//build/config/compiler:chromium_code" ]
-  library_configs += [ "//build/config/compiler:no_chromium_code" ]
-  executable_configs -= [ "//build/config/compiler:chromium_code" ]
-  executable_configs += [ "//build/config/compiler:no_chromium_code" ]
-  proc_macro_configs -= [ "//build/config/compiler:chromium_code" ]
-  proc_macro_configs += [ "//build/config/compiler:no_chromium_code" ]
-
-  # Only for usage from third-party crates. Add the crate to
-  # //third_party/rust/chromium_crates_io/Cargo.toml to use
-  # it from first-party code.
-  visibility = [ "//third_party/rust/*" ]
-}
diff --git a/third_party/rust/adler/v1/README.chromium b/third_party/rust/adler/v1/README.chromium
deleted file mode 100644
index ec114e74cd9272..00000000000000
--- a/third_party/rust/adler/v1/README.chromium
+++ /dev/null
@@ -1,9 +0,0 @@
-Name: adler
-URL: https://crates.io/crates/adler
-Description: A simple clean-room implementation of the Adler-32 checksum
-Version: 1.0.2
-Security Critical: yes
-Shipped: yes
-License: Apache 2.0
-License File: //third_party/rust/chromium_crates_io/vendor/adler-1.0.2/LICENSE-APACHE
-Revision: a94f525f62698d699d1fb3cc9112db8c35662b16
diff --git a/third_party/rust/chromium_crates_io/Cargo.lock b/third_party/rust/chromium_crates_io/Cargo.lock
index fa4a2d38a649e9..fbd7ba087d5b82 100644
--- a/third_party/rust/chromium_crates_io/Cargo.lock
+++ b/third_party/rust/chromium_crates_io/Cargo.lock
@@ -2,11 +2,6 @@
 # It is not intended for manual editing.
 version = 3
 
-[[package]]
-name = "adler"
-version = "1.0.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-
 [[package]]
 name = "adler2"
 version = "2.0.0"
@@ -237,7 +232,7 @@ version = "1.0.34"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 dependencies = [
  "crc32fast",
- "miniz_oxide 0.8.0",
+ "miniz_oxide",
 ]
 
 [[package]]
@@ -324,21 +319,13 @@ name = "minimal-lexical"
 version = "0.2.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 
-[[package]]
-name = "miniz_oxide"
-version = "0.7.4"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "adler",
- "simd-adler32",
-]
-
 [[package]]
 name = "miniz_oxide"
 version = "0.8.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 dependencies = [
  "adler2",
+ "simd-adler32",
 ]
 
 [[package]]
@@ -352,14 +339,14 @@ dependencies = [
 
 [[package]]
 name = "png"
-version = "0.17.13"
+version = "0.17.14"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 dependencies = [
  "bitflags 1.3.2",
  "crc32fast",
  "fdeflate",
  "flate2",
- "miniz_oxide 0.7.4",
+ "miniz_oxide",
 ]
 
 [[package]]
diff --git a/third_party/rust/chromium_crates_io/patches/png/0101-Introduce-a-separate-struct-Adam7Info.patch b/third_party/rust/chromium_crates_io/patches/png/0101-Introduce-a-separate-struct-Adam7Info.patch
deleted file mode 100644
index 9651b86f02072a..00000000000000
--- a/third_party/rust/chromium_crates_io/patches/png/0101-Introduce-a-separate-struct-Adam7Info.patch
+++ /dev/null
@@ -1,199 +0,0 @@
-From a8606523dc284a0432c9b1737066b189ca3ea660 Mon Sep 17 00:00:00 2001
-From: Lukasz Anforowicz <lukasza@chromium.org>
-Date: Fri, 30 Aug 2024 19:19:17 +0000
-Subject: [PATCH 101/107] Introduce a separate `struct Adam7Info`.
-
-This helps with the following things:
-
-* It means that after making `InterlaceInfo` public in a follow-up
-  commit, `pass`, `line`, and `width` fields can remain private.
-* It means that a follow-up commit that refactors `adam7::expand_pass`
-  to take a single `info` parameter doesn't allow passing an
-  invalid `InterlaceInfo::Null` value.
-* It gives `Adam7Iterator` a nicer, named `Iterator::Item`.
----
- src/adam7.rs       | 67 ++++++++++++++++++++++++++++++++++++++--------
- src/decoder/mod.rs | 32 +++++++++++++---------
- 2 files changed, 76 insertions(+), 23 deletions(-)
-
-diff --git a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/adam7.rs b/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/adam7.rs
-index 5bf7bb3..550e215 100644
---- a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/adam7.rs
-+++ b/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/adam7.rs
-@@ -1,7 +1,20 @@
--//! Utility functions
-+//! Utility functions related to handling of
-+//! [the Adam7 algorithm](https://en.wikipedia.org/wiki/Adam7_algorithm).
- use std::iter::StepBy;
- use std::ops::Range;
- 
-+/// Describes which stage of
-+/// [the Adam7 algorithm](https://en.wikipedia.org/wiki/Adam7_algorithm)
-+/// applies to a decoded row.
-+///
-+/// See also [Reader::next_interlaced_row].
-+#[derive(Clone, Copy, Debug, PartialEq, Eq)]
-+pub struct Adam7Info {
-+    pub(crate) pass: u8,
-+    pub(crate) line: u32,
-+    pub(crate) width: u32,
-+}
-+
- /// This iterator iterates over the different passes of an image Adam7 encoded
- /// PNG image
- /// The pattern is:
-@@ -63,14 +76,18 @@ impl Adam7Iterator {
-     }
- }
- 
--/// Iterates over the (passes, lines, widths)
-+/// Iterates over `Adam7Info`s.
- impl Iterator for Adam7Iterator {
--    type Item = (u8, u32, u32);
-+    type Item = Adam7Info;
-     fn next(&mut self) -> Option<Self::Item> {
-         if self.line < self.lines && self.line_width > 0 {
-             let this_line = self.line;
-             self.line += 1;
--            Some((self.current_pass, this_line, self.line_width))
-+            Some(Adam7Info {
-+                pass: self.current_pass,
-+                line: this_line,
-+                width: self.line_width,
-+            })
-         } else if self.current_pass < 7 {
-             self.current_pass += 1;
-             self.init_pass();
-@@ -179,13 +196,41 @@ fn test_adam7() {
-     assert_eq!(
-         &*passes,
-         &[
--            (1, 0, 1),
--            (4, 0, 1),
--            (5, 0, 2),
--            (6, 0, 2),
--            (6, 1, 2),
--            (7, 0, 4),
--            (7, 1, 4)
-+            Adam7Info {
-+                pass: 1,
-+                line: 0,
-+                width: 1
-+            },
-+            Adam7Info {
-+                pass: 4,
-+                line: 0,
-+                width: 1
-+            },
-+            Adam7Info {
-+                pass: 5,
-+                line: 0,
-+                width: 2
-+            },
-+            Adam7Info {
-+                pass: 6,
-+                line: 0,
-+                width: 2
-+            },
-+            Adam7Info {
-+                pass: 6,
-+                line: 1,
-+                width: 2
-+            },
-+            Adam7Info {
-+                pass: 7,
-+                line: 0,
-+                width: 4
-+            },
-+            Adam7Info {
-+                pass: 7,
-+                line: 1,
-+                width: 4
-+            }
-         ]
-     );
- }
-diff --git a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/decoder/mod.rs b/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/decoder/mod.rs
-index 2a18964..a5f2e70 100644
---- a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/decoder/mod.rs
-+++ b/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/decoder/mod.rs
-@@ -99,19 +99,26 @@ impl<'data> InterlacedRow<'data> {
-         self.data
-     }
- 
--    pub fn interlace(&self) -> InterlaceInfo {
--        self.interlace
-+    pub fn interlace(&self) -> &InterlaceInfo {
-+        &self.interlace
-     }
- }
- 
-+/// Describes which interlacing algorithm applies to a decoded row.
-+///
- /// PNG (2003) specifies two interlace modes, but reserves future extensions.
-+///
-+/// See also [Reader::next_interlaced_row].
- #[derive(Clone, Copy, Debug)]
- pub enum InterlaceInfo {
--    /// the null method means no interlacing
-+    /// The `null` method means no interlacing.
-     Null,
--    /// Adam7 derives its name from doing 7 passes over the image, only decoding a subset of all pixels in each pass.
--    /// The following table shows pictorially what parts of each 8x8 area of the image is found in each pass:
-+    /// [The `Adam7` algorithm](https://en.wikipedia.org/wiki/Adam7_algorithm) derives its name
-+    /// from doing 7 passes over the image, only decoding a subset of all pixels in each pass.
-+    /// The following table shows pictorially what parts of each 8x8 area of the image is found in
-+    /// each pass:
-     ///
-+    /// ```txt
-     /// 1 6 4 6 2 6 4 6
-     /// 7 7 7 7 7 7 7 7
-     /// 5 6 5 6 5 6 5 6
-@@ -120,7 +127,8 @@ pub enum InterlaceInfo {
-     /// 7 7 7 7 7 7 7 7
-     /// 5 6 5 6 5 6 5 6
-     /// 7 7 7 7 7 7 7 7
--    Adam7 { pass: u8, line: u32, width: u32 },
-+    /// ```
-+    Adam7(adam7::Adam7Info),
- }
- 
- /// A row of data without interlace information.
-@@ -545,7 +553,7 @@ impl<R: Read> Reader<R> {
-             }) = self.next_interlaced_row()?
-             {
-                 let (line, pass) = match interlace {
--                    InterlaceInfo::Adam7 { line, pass, .. } => (line, pass),
-+                    InterlaceInfo::Adam7(adam7::Adam7Info { line, pass, .. }) => (line, pass),
-                     InterlaceInfo::Null => unreachable!("expected interlace information"),
-                 };
-                 let samples = color_type.samples() as u8;
-@@ -599,7 +607,7 @@ impl<R: Read> Reader<R> {
-             None => return Ok(None),
-         };
- 
--        let width = if let InterlaceInfo::Adam7 { width, .. } = interlace {
-+        let width = if let InterlaceInfo::Adam7(adam7::Adam7Info { width, .. }) = interlace {
-             width
-         } else {
-             self.subframe.width
-@@ -715,12 +723,12 @@ impl<R: Read> Reader<R> {
-         match self.subframe.interlace {
-             InterlaceIter::Adam7(ref mut adam7) => {
-                 let last_pass = adam7.current_pass();
--                let (pass, line, width) = adam7.next()?;
--                let rowlen = self.info().raw_row_length_from_width(width);
--                if last_pass != pass {
-+                let adam7info = adam7.next()?;
-+                let rowlen = self.info().raw_row_length_from_width(adam7info.width);
-+                if last_pass != adam7info.pass {
-                     self.prev_start = self.current_start;
-                 }
--                Some((rowlen, InterlaceInfo::Adam7 { pass, line, width }))
-+                Some((rowlen, InterlaceInfo::Adam7(adam7info)))
-             }
-             InterlaceIter::None(ref mut height) => {
-                 let _ = height.next()?;
--- 
-2.46.0.598.g6f2099f65c-goog
-
diff --git a/third_party/rust/chromium_crates_io/patches/png/0102-Passing-Adam7Info-to-fn-expand_pass.patch b/third_party/rust/chromium_crates_io/patches/png/0102-Passing-Adam7Info-to-fn-expand_pass.patch
deleted file mode 100644
index da8330028ccaf5..00000000000000
--- a/third_party/rust/chromium_crates_io/patches/png/0102-Passing-Adam7Info-to-fn-expand_pass.patch
+++ /dev/null
@@ -1,205 +0,0 @@
-From 82547fcd38519ea1104e99ff58d0863fb304551f Mon Sep 17 00:00:00 2001
-From: Lukasz Anforowicz <lukasza@chromium.org>
-Date: Thu, 29 Aug 2024 17:05:30 +0000
-Subject: [PATCH 102/107] Passing `&Adam7Info` to `fn expand_pass`.
-
-Instead of passing `line_no` and `pass` as separate parameters, we
-can pass a single `&Adam7Info` parameter.  This minor refactoring
-helps with:
-
-* Exposing a nice public API in a follow-up commit
-* Depending on `Adam7Info.width` in a follow-up commit
----
- src/adam7.rs       | 57 +++++++++++++++++++++++++++-------------------
- src/decoder/mod.rs | 22 ++++++++++++------
- 2 files changed, 48 insertions(+), 31 deletions(-)
-
-diff --git a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/adam7.rs b/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/adam7.rs
-index 550e215..213bb6d 100644
---- a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/adam7.rs
-+++ b/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/adam7.rs
-@@ -148,16 +148,10 @@ fn expand_adam7_bits(
- }
- 
- /// Expands an Adam 7 pass
--pub fn expand_pass(
--    img: &mut [u8],
--    width: u32,
--    scanline: &[u8],
--    pass: u8,
--    line_no: u32,
--    bits_pp: u8,
--) {
-+pub fn expand_pass(img: &mut [u8], width: u32, scanline: &[u8], info: &Adam7Info, bits_pp: u8) {
-     let width = width as usize;
--    let line_no = line_no as usize;
-+    let line_no = info.line as usize;
-+    let pass = info.pass;
-     let bits_pp = bits_pp as usize;
- 
-     // pass is out of range but don't blow up
-@@ -318,56 +312,57 @@ fn test_expand_pass_subbyte() {
-     let mut img = [0u8; 8];
-     let width = 8;
-     let bits_pp = 1;
-+    let info = create_adam7_info_for_tests;
- 
--    expand_pass(&mut img, width, &[0b10000000], 1, 0, bits_pp);
-+    expand_pass(&mut img, width, &[0b10000000], &info(1, 0, width), bits_pp);
-     assert_eq!(img, [0b10000000u8, 0, 0, 0, 0, 0, 0, 0]);
- 
--    expand_pass(&mut img, width, &[0b10000000], 2, 0, bits_pp);
-+    expand_pass(&mut img, width, &[0b10000000], &info(2, 0, width), bits_pp);
-     assert_eq!(img, [0b10001000u8, 0, 0, 0, 0, 0, 0, 0]);
- 
--    expand_pass(&mut img, width, &[0b11000000], 3, 0, bits_pp);
-+    expand_pass(&mut img, width, &[0b11000000], &info(3, 0, width), bits_pp);
-     assert_eq!(img, [0b10001000u8, 0, 0, 0, 0b10001000, 0, 0, 0]);
- 
--    expand_pass(&mut img, width, &[0b11000000], 4, 0, bits_pp);
-+    expand_pass(&mut img, width, &[0b11000000], &info(4, 0, width), bits_pp);
-     assert_eq!(img, [0b10101010u8, 0, 0, 0, 0b10001000, 0, 0, 0]);
- 
--    expand_pass(&mut img, width, &[0b11000000], 4, 1, bits_pp);
-+    expand_pass(&mut img, width, &[0b11000000], &info(4, 1, width), bits_pp);
-     assert_eq!(img, [0b10101010u8, 0, 0, 0, 0b10101010, 0, 0, 0]);
- 
--    expand_pass(&mut img, width, &[0b11110000], 5, 0, bits_pp);
-+    expand_pass(&mut img, width, &[0b11110000], &info(5, 0, width), bits_pp);
-     assert_eq!(img, [0b10101010u8, 0, 0b10101010, 0, 0b10101010, 0, 0, 0]);
- 
--    expand_pass(&mut img, width, &[0b11110000], 5, 1, bits_pp);
-+    expand_pass(&mut img, width, &[0b11110000], &info(5, 1, width), bits_pp);
-     assert_eq!(
-         img,
-         [0b10101010u8, 0, 0b10101010, 0, 0b10101010, 0, 0b10101010, 0]
-     );
- 
--    expand_pass(&mut img, width, &[0b11110000], 6, 0, bits_pp);
-+    expand_pass(&mut img, width, &[0b11110000], &info(6, 0, width), bits_pp);
-     assert_eq!(
-         img,
-         [0b11111111u8, 0, 0b10101010, 0, 0b10101010, 0, 0b10101010, 0]
-     );
- 
--    expand_pass(&mut img, width, &[0b11110000], 6, 1, bits_pp);
-+    expand_pass(&mut img, width, &[0b11110000], &info(6, 1, width), bits_pp);
-     assert_eq!(
-         img,
-         [0b11111111u8, 0, 0b11111111, 0, 0b10101010, 0, 0b10101010, 0]
-     );
- 
--    expand_pass(&mut img, width, &[0b11110000], 6, 2, bits_pp);
-+    expand_pass(&mut img, width, &[0b11110000], &info(6, 2, width), bits_pp);
-     assert_eq!(
-         img,
-         [0b11111111u8, 0, 0b11111111, 0, 0b11111111, 0, 0b10101010, 0]
-     );
- 
--    expand_pass(&mut img, width, &[0b11110000], 6, 3, bits_pp);
-+    expand_pass(&mut img, width, &[0b11110000], &info(6, 3, width), bits_pp);
-     assert_eq!(
-         [0b11111111u8, 0, 0b11111111, 0, 0b11111111, 0, 0b11111111, 0],
-         img
-     );
- 
--    expand_pass(&mut img, width, &[0b11111111], 7, 0, bits_pp);
-+    expand_pass(&mut img, width, &[0b11111111], &info(7, 0, width), bits_pp);
-     assert_eq!(
-         [
-             0b11111111u8,
-@@ -382,7 +377,7 @@ fn test_expand_pass_subbyte() {
-         img
-     );
- 
--    expand_pass(&mut img, width, &[0b11111111], 7, 1, bits_pp);
-+    expand_pass(&mut img, width, &[0b11111111], &info(7, 1, width), bits_pp);
-     assert_eq!(
-         [
-             0b11111111u8,
-@@ -397,7 +392,7 @@ fn test_expand_pass_subbyte() {
-         img
-     );
- 
--    expand_pass(&mut img, width, &[0b11111111], 7, 2, bits_pp);
-+    expand_pass(&mut img, width, &[0b11111111], &info(7, 2, width), bits_pp);
-     assert_eq!(
-         [
-             0b11111111u8,
-@@ -412,7 +407,7 @@ fn test_expand_pass_subbyte() {
-         img
-     );
- 
--    expand_pass(&mut img, width, &[0b11111111], 7, 3, bits_pp);
-+    expand_pass(&mut img, width, &[0b11111111], &info(7, 3, width), bits_pp);
-     assert_eq!(
-         [
-             0b11111111u8,
-@@ -427,3 +422,17 @@ fn test_expand_pass_subbyte() {
-         img
-     );
- }
-+
-+#[cfg(test)]
-+fn create_adam7_info_for_tests(pass: u8, line: u32, img_width: u32) -> Adam7Info {
-+    let width = {
-+        let img_height = 8;
-+        Adam7Iterator::new(img_width, img_height)
-+            .filter(|info| info.pass == pass)
-+            .map(|info| info.width)
-+            .next()
-+            .unwrap()
-+    };
-+
-+    Adam7Info { pass, line, width }
-+}
-diff --git a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/decoder/mod.rs b/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/decoder/mod.rs
-index a5f2e70..bbd5953 100644
---- a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/decoder/mod.rs
-+++ b/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/decoder/mod.rs
-@@ -131,6 +131,15 @@ pub enum InterlaceInfo {
-     Adam7(adam7::Adam7Info),
- }
- 
-+impl InterlaceInfo {
-+    fn get_adam7_info(&self) -> Option<&adam7::Adam7Info> {
-+        match self {
-+            InterlaceInfo::Null => None,
-+            InterlaceInfo::Adam7(adam7info) => Some(adam7info),
-+        }
-+    }
-+}
-+
- /// A row of data without interlace information.
- #[derive(Clone, Copy, Debug)]
- pub struct Row<'data> {
-@@ -544,20 +553,19 @@ impl<R: Read> Reader<R> {
-         self.data_stream.clear();
-         self.current_start = 0;
-         self.prev_start = 0;
--        let width = self.info().width;
-         if self.info().interlaced {
-+            let width = self.info().width;
-+            let samples = color_type.samples() as u8;
-+            let bits_pp = samples * (bit_depth as u8);
-             while let Some(InterlacedRow {
-                 data: row,
-                 interlace,
-                 ..
-             }) = self.next_interlaced_row()?
-             {
--                let (line, pass) = match interlace {
--                    InterlaceInfo::Adam7(adam7::Adam7Info { line, pass, .. }) => (line, pass),
--                    InterlaceInfo::Null => unreachable!("expected interlace information"),
--                };
--                let samples = color_type.samples() as u8;
--                adam7::expand_pass(buf, width, row, pass, line, samples * (bit_depth as u8));
-+                // `unwrap` won't panic, because we checked `self.info().interlaced` above.
-+                let adam7info = interlace.get_adam7_info().unwrap();
-+                adam7::expand_pass(buf, width, row, &adam7info, bits_pp);
-             }
-         } else {
-             for row in buf
--- 
-2.46.0.598.g6f2099f65c-goog
-
diff --git a/third_party/rust/chromium_crates_io/patches/png/0103-Passing-Adam7Info-to-fn-expand_adam7_bits.patch b/third_party/rust/chromium_crates_io/patches/png/0103-Passing-Adam7Info-to-fn-expand_adam7_bits.patch
deleted file mode 100644
index dba1eba3301464..00000000000000
--- a/third_party/rust/chromium_crates_io/patches/png/0103-Passing-Adam7Info-to-fn-expand_adam7_bits.patch
+++ /dev/null
@@ -1,149 +0,0 @@
-From fa12d377c046bbb1e20805552cf4866977ba3c77 Mon Sep 17 00:00:00 2001
-From: Lukasz Anforowicz <lukasza@chromium.org>
-Date: Thu, 29 Aug 2024 19:02:27 +0000
-Subject: [PATCH 103/107] Passing `&Adam7Info` to `fn expand_adam7_bits`.
-
-Instead of passing `line_no` and `pass` as separate parameters, we
-can pass a single `&Adam7Info` parameter.  This minor refactoring
-helps with:
-
-* Cleaning up `fn expand_pass` by moving some of its complexity closer
-  to where its needed (within `fn expand_adam7_bits`)
-* Preparing for changing the semantics of the `width` parameter of
-  `fn expand_adam7_bits` in a follow-up commit, where we will stop
-  depending on `width` for calculating the length of the returned
-  iterator (depending on `Adam7Info.width` instead).  See the follow-up
-  commit for more details.
----
- src/adam7.rs | 46 ++++++++++++++++++++++------------------------
- 1 file changed, 22 insertions(+), 24 deletions(-)
-
-diff --git a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/adam7.rs b/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/adam7.rs
-index 213bb6d..51667f7 100644
---- a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/adam7.rs
-+++ b/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/adam7.rs
-@@ -117,14 +117,13 @@ fn subbyte_pixels(scanline: &[u8], bits_pp: usize) -> impl Iterator<Item = u8> +
-         })
- }
- 
--/// Given pass, image width, and line number, produce an iterator of bit positions of pixels to copy
--/// from the input scanline to the image buffer.
--fn expand_adam7_bits(
--    pass: u8,
--    width: usize,
--    line_no: usize,
--    bits_pp: usize,
--) -> StepBy<Range<usize>> {
-+/// Given image `width`, interlace `info`, and bits-per-pixel, produce an iterator of bit positions
-+/// of pixels to copy from the input scanline to the image buffer.  The positions are expressed as
-+/// bit offsets from position (0,0) in the frame that is currently being decoded.
-+fn expand_adam7_bits(width: usize, info: &Adam7Info, bits_pp: usize) -> StepBy<Range<usize>> {
-+    let line_no = info.line as usize;
-+    let pass = info.pass;
-+
-     let (line_mul, line_off, samp_mul, samp_off) = match pass {
-         1 => (8, 0, 8, 0),
-         2 => (8, 0, 8, 4),
-@@ -133,7 +132,11 @@ fn expand_adam7_bits(
-         5 => (4, 2, 2, 0),
-         6 => (2, 0, 2, 1),
-         7 => (2, 1, 1, 0),
--        _ => panic!("Adam7 pass out of range: {}", pass),
-+        _ => {
-+            // `Adam7Info.pass` is a non-`pub`lic field.  `InterlaceInfo` is expected
-+            // to maintain an invariant that `pass` is valid.
-+            panic!("Invalid `Adam7Info.pass`");
-+        }
-     };
- 
-     // the equivalent line number in progressive scan
-@@ -150,16 +153,9 @@ fn expand_adam7_bits(
- /// Expands an Adam 7 pass
- pub fn expand_pass(img: &mut [u8], width: u32, scanline: &[u8], info: &Adam7Info, bits_pp: u8) {
-     let width = width as usize;
--    let line_no = info.line as usize;
--    let pass = info.pass;
-     let bits_pp = bits_pp as usize;
- 
--    // pass is out of range but don't blow up
--    if pass == 0 || pass > 7 {
--        return;
--    }
--
--    let bit_indices = expand_adam7_bits(pass, width, line_no, bits_pp);
-+    let bit_indices = expand_adam7_bits(width, info, bits_pp);
- 
-     if bits_pp < 8 {
-         for (pos, px) in bit_indices.zip(subbyte_pixels(scanline, bits_pp)) {
-@@ -242,6 +238,8 @@ fn test_subbyte_pixels() {
- fn test_expand_adam7_bits() {
-     let width = 32;
-     let bits_pp = 1;
-+    let info =
-+        |pass, line, img_width| create_adam7_info_for_tests(pass, line as u32, img_width as u32);
- 
-     let expected = |offset: usize, step: usize, count: usize| {
-         (0..count)
-@@ -253,21 +251,21 @@ fn test_expand_adam7_bits() {
-         let start = 8 * line_no * width;
- 
-         assert_eq!(
--            expand_adam7_bits(1, width, line_no, bits_pp).collect::<Vec<_>>(),
-+            expand_adam7_bits(width, &info(1, line_no, width), bits_pp).collect::<Vec<_>>(),
-             expected(start, 8, 4)
-         );
- 
-         let start = start + 4;
- 
-         assert_eq!(
--            expand_adam7_bits(2, width, line_no, bits_pp).collect::<Vec<_>>(),
-+            expand_adam7_bits(width, &info(2, line_no, width), bits_pp).collect::<Vec<_>>(),
-             expected(start, 8, 4)
-         );
- 
-         let start = (8 * line_no + 4) * width;
- 
-         assert_eq!(
--            expand_adam7_bits(3, width, line_no, bits_pp).collect::<Vec<_>>(),
-+            expand_adam7_bits(width, &info(3, line_no, width), bits_pp).collect::<Vec<_>>(),
-             expected(start, 4, 8)
-         );
-     }
-@@ -276,14 +274,14 @@ fn test_expand_adam7_bits() {
-         let start = 4 * line_no * width + 2;
- 
-         assert_eq!(
--            expand_adam7_bits(4, width, line_no, bits_pp).collect::<Vec<_>>(),
-+            expand_adam7_bits(width, &info(4, line_no, width), bits_pp).collect::<Vec<_>>(),
-             expected(start, 4, 8)
-         );
- 
-         let start = (4 * line_no + 2) * width;
- 
-         assert_eq!(
--            expand_adam7_bits(5, width, line_no, bits_pp).collect::<Vec<_>>(),
-+            expand_adam7_bits(width, &info(5, line_no, width), bits_pp).collect::<Vec<_>>(),
-             expected(start, 2, 16)
-         )
-     }
-@@ -292,7 +290,7 @@ fn test_expand_adam7_bits() {
-         let start = 2 * line_no * width + 1;
- 
-         assert_eq!(
--            expand_adam7_bits(6, width, line_no, bits_pp).collect::<Vec<_>>(),
-+            expand_adam7_bits(width, &info(6, line_no, width), bits_pp).collect::<Vec<_>>(),
-             expected(start, 2, 16),
-             "line_no: {}",
-             line_no
-@@ -301,7 +299,7 @@ fn test_expand_adam7_bits() {
-         let start = (2 * line_no + 1) * width;
- 
-         assert_eq!(
--            expand_adam7_bits(7, width, line_no, bits_pp).collect::<Vec<_>>(),
-+            expand_adam7_bits(width, &info(7, line_no, width), bits_pp).collect::<Vec<_>>(),
-             expected(start, 1, 32)
-         );
-     }
--- 
-2.46.0.598.g6f2099f65c-goog
-
diff --git a/third_party/rust/chromium_crates_io/patches/png/0104-Independent-row_stride_in_bytes-in-expand_adam7_bits.patch b/third_party/rust/chromium_crates_io/patches/png/0104-Independent-row_stride_in_bytes-in-expand_adam7_bits.patch
deleted file mode 100644
index 66c481eec7ade5..00000000000000
--- a/third_party/rust/chromium_crates_io/patches/png/0104-Independent-row_stride_in_bytes-in-expand_adam7_bits.patch
+++ /dev/null
@@ -1,319 +0,0 @@
-From d19fa0957bc4910fc8235ff53b6f0b2578f73c62 Mon Sep 17 00:00:00 2001
-From: Lukasz Anforowicz <lukasza@chromium.org>
-Date: Thu, 29 Aug 2024 20:09:49 +0000
-Subject: [PATCH 104/107] Independent `row_stride_in_bytes` in
- `expand_adam7_bits`.
-
-This commit refactors implementation of `expand_adam7_bits` so that it
-can accept `row_stride_in_bytes` that is different from the expanded
-width of the frame or image.
-
-This is helpful for making `expand_pass` work in scenarios where
-interlaced row needs to expanded into a bigger image (e.g. if the
-currently decoded frame is an animation frame that only takes a
-subregion of the whole image - in this case the stride between expanded
-rows is bigger than the size of expanded rows).
-
-And the above is helpful for exposing `expand_pass` through a public API
-that will hopefully pass the test of time...
----
- src/adam7.rs       | 105 ++++++++++++++++++++++++++++-----------------
- src/decoder/mod.rs |   4 +-
- 2 files changed, 68 insertions(+), 41 deletions(-)
-
-diff --git a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/adam7.rs b/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/adam7.rs
-index 51667f7..2863f2a 100644
---- a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/adam7.rs
-+++ b/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/adam7.rs
-@@ -1,7 +1,5 @@
- //! Utility functions related to handling of
- //! [the Adam7 algorithm](https://en.wikipedia.org/wiki/Adam7_algorithm).
--use std::iter::StepBy;
--use std::ops::Range;
- 
- /// Describes which stage of
- /// [the Adam7 algorithm](https://en.wikipedia.org/wiki/Adam7_algorithm)
-@@ -117,12 +115,17 @@ fn subbyte_pixels(scanline: &[u8], bits_pp: usize) -> impl Iterator<Item = u8> +
-         })
- }
- 
--/// Given image `width`, interlace `info`, and bits-per-pixel, produce an iterator of bit positions
-+/// Given `row_stride`, interlace `info`, and bits-per-pixel, produce an iterator of bit positions
- /// of pixels to copy from the input scanline to the image buffer.  The positions are expressed as
- /// bit offsets from position (0,0) in the frame that is currently being decoded.
--fn expand_adam7_bits(width: usize, info: &Adam7Info, bits_pp: usize) -> StepBy<Range<usize>> {
-+fn expand_adam7_bits(
-+    row_stride_in_bytes: usize,
-+    info: &Adam7Info,
-+    bits_pp: usize,
-+) -> impl Iterator<Item = usize> {
-     let line_no = info.line as usize;
-     let pass = info.pass;
-+    let interlaced_width = info.width as usize;
- 
-     let (line_mul, line_off, samp_mul, samp_off) = match pass {
-         1 => (8, 0, 8, 0),
-@@ -141,21 +144,19 @@ fn expand_adam7_bits(width: usize, info: &Adam7Info, bits_pp: usize) -> StepBy<R
- 
-     // the equivalent line number in progressive scan
-     let prog_line = line_mul * line_no + line_off;
--    // line width is rounded up to the next byte
--    let line_width = (width * bits_pp + 7) & !7;
--    let line_start = prog_line * line_width;
--    let start = line_start + (samp_off * bits_pp);
--    let stop = line_start + (width * bits_pp);
-+    let line_start = prog_line * row_stride_in_bytes * 8;
- 
--    (start..stop).step_by(bits_pp * samp_mul)
-+    (0..interlaced_width)
-+        .map(move |i| i * samp_mul + samp_off)
-+        .map(move |i| i * bits_pp)
-+        .map(move |bits_offset| bits_offset + line_start)
- }
- 
- /// Expands an Adam 7 pass
--pub fn expand_pass(img: &mut [u8], width: u32, scanline: &[u8], info: &Adam7Info, bits_pp: u8) {
--    let width = width as usize;
-+pub fn expand_pass(img: &mut [u8], stride: usize, scanline: &[u8], info: &Adam7Info, bits_pp: u8) {
-     let bits_pp = bits_pp as usize;
- 
--    let bit_indices = expand_adam7_bits(width, info, bits_pp);
-+    let bit_indices = expand_adam7_bits(stride, info, bits_pp);
- 
-     if bits_pp < 8 {
-         for (pos, px) in bit_indices.zip(subbyte_pixels(scanline, bits_pp)) {
-@@ -238,8 +239,8 @@ fn test_subbyte_pixels() {
- fn test_expand_adam7_bits() {
-     let width = 32;
-     let bits_pp = 1;
--    let info =
--        |pass, line, img_width| create_adam7_info_for_tests(pass, line as u32, img_width as u32);
-+    let stride = width / 8;
-+    let info = |pass, line, img_width| create_adam7_info_for_tests(pass, line as u32, img_width);
- 
-     let expected = |offset: usize, step: usize, count: usize| {
-         (0..count)
-@@ -251,21 +252,21 @@ fn test_expand_adam7_bits() {
-         let start = 8 * line_no * width;
- 
-         assert_eq!(
--            expand_adam7_bits(width, &info(1, line_no, width), bits_pp).collect::<Vec<_>>(),
-+            expand_adam7_bits(stride, &info(1, line_no, width), bits_pp).collect::<Vec<_>>(),
-             expected(start, 8, 4)
-         );
- 
-         let start = start + 4;
- 
-         assert_eq!(
--            expand_adam7_bits(width, &info(2, line_no, width), bits_pp).collect::<Vec<_>>(),
-+            expand_adam7_bits(stride, &info(2, line_no, width), bits_pp).collect::<Vec<_>>(),
-             expected(start, 8, 4)
-         );
- 
-         let start = (8 * line_no + 4) * width;
- 
-         assert_eq!(
--            expand_adam7_bits(width, &info(3, line_no, width), bits_pp).collect::<Vec<_>>(),
-+            expand_adam7_bits(stride, &info(3, line_no, width), bits_pp).collect::<Vec<_>>(),
-             expected(start, 4, 8)
-         );
-     }
-@@ -274,14 +275,14 @@ fn test_expand_adam7_bits() {
-         let start = 4 * line_no * width + 2;
- 
-         assert_eq!(
--            expand_adam7_bits(width, &info(4, line_no, width), bits_pp).collect::<Vec<_>>(),
-+            expand_adam7_bits(stride, &info(4, line_no, width), bits_pp).collect::<Vec<_>>(),
-             expected(start, 4, 8)
-         );
- 
-         let start = (4 * line_no + 2) * width;
- 
-         assert_eq!(
--            expand_adam7_bits(width, &info(5, line_no, width), bits_pp).collect::<Vec<_>>(),
-+            expand_adam7_bits(stride, &info(5, line_no, width), bits_pp).collect::<Vec<_>>(),
-             expected(start, 2, 16)
-         )
-     }
-@@ -290,7 +291,7 @@ fn test_expand_adam7_bits() {
-         let start = 2 * line_no * width + 1;
- 
-         assert_eq!(
--            expand_adam7_bits(width, &info(6, line_no, width), bits_pp).collect::<Vec<_>>(),
-+            expand_adam7_bits(stride, &info(6, line_no, width), bits_pp).collect::<Vec<_>>(),
-             expected(start, 2, 16),
-             "line_no: {}",
-             line_no
-@@ -299,68 +300,94 @@ fn test_expand_adam7_bits() {
-         let start = (2 * line_no + 1) * width;
- 
-         assert_eq!(
--            expand_adam7_bits(width, &info(7, line_no, width), bits_pp).collect::<Vec<_>>(),
-+            expand_adam7_bits(stride, &info(7, line_no, width), bits_pp).collect::<Vec<_>>(),
-             expected(start, 1, 32)
-         );
-     }
- }
- 
-+#[test]
-+fn test_expand_adam7_bits_independent_row_stride() {
-+    let pass = 1;
-+    let line_no = 1;
-+    let width = 32;
-+    let bits_pp = 8;
-+    let info = create_adam7_info_for_tests;
-+
-+    {
-+        let stride = width;
-+        assert_eq!(
-+            expand_adam7_bits(stride, &info(pass, line_no, width), bits_pp).collect::<Vec<_>>(),
-+            vec![2048, 2112, 2176, 2240],
-+        );
-+    }
-+
-+    {
-+        let stride = 10000;
-+        assert_eq!(
-+            expand_adam7_bits(stride, &info(pass, line_no, width), bits_pp).collect::<Vec<_>>(),
-+            vec![640000, 640064, 640128, 640192],
-+        );
-+    }
-+}
-+
- #[test]
- fn test_expand_pass_subbyte() {
-     let mut img = [0u8; 8];
-     let width = 8;
-+    let stride = width / 8;
-     let bits_pp = 1;
-     let info = create_adam7_info_for_tests;
- 
--    expand_pass(&mut img, width, &[0b10000000], &info(1, 0, width), bits_pp);
-+    expand_pass(&mut img, stride, &[0b10000000], &info(1, 0, width), bits_pp);
-     assert_eq!(img, [0b10000000u8, 0, 0, 0, 0, 0, 0, 0]);
- 
--    expand_pass(&mut img, width, &[0b10000000], &info(2, 0, width), bits_pp);
-+    expand_pass(&mut img, stride, &[0b10000000], &info(2, 0, width), bits_pp);
-     assert_eq!(img, [0b10001000u8, 0, 0, 0, 0, 0, 0, 0]);
- 
--    expand_pass(&mut img, width, &[0b11000000], &info(3, 0, width), bits_pp);
-+    expand_pass(&mut img, stride, &[0b11000000], &info(3, 0, width), bits_pp);
-     assert_eq!(img, [0b10001000u8, 0, 0, 0, 0b10001000, 0, 0, 0]);
- 
--    expand_pass(&mut img, width, &[0b11000000], &info(4, 0, width), bits_pp);
-+    expand_pass(&mut img, stride, &[0b11000000], &info(4, 0, width), bits_pp);
-     assert_eq!(img, [0b10101010u8, 0, 0, 0, 0b10001000, 0, 0, 0]);
- 
--    expand_pass(&mut img, width, &[0b11000000], &info(4, 1, width), bits_pp);
-+    expand_pass(&mut img, stride, &[0b11000000], &info(4, 1, width), bits_pp);
-     assert_eq!(img, [0b10101010u8, 0, 0, 0, 0b10101010, 0, 0, 0]);
- 
--    expand_pass(&mut img, width, &[0b11110000], &info(5, 0, width), bits_pp);
-+    expand_pass(&mut img, stride, &[0b11110000], &info(5, 0, width), bits_pp);
-     assert_eq!(img, [0b10101010u8, 0, 0b10101010, 0, 0b10101010, 0, 0, 0]);
- 
--    expand_pass(&mut img, width, &[0b11110000], &info(5, 1, width), bits_pp);
-+    expand_pass(&mut img, stride, &[0b11110000], &info(5, 1, width), bits_pp);
-     assert_eq!(
-         img,
-         [0b10101010u8, 0, 0b10101010, 0, 0b10101010, 0, 0b10101010, 0]
-     );
- 
--    expand_pass(&mut img, width, &[0b11110000], &info(6, 0, width), bits_pp);
-+    expand_pass(&mut img, stride, &[0b11110000], &info(6, 0, width), bits_pp);
-     assert_eq!(
-         img,
-         [0b11111111u8, 0, 0b10101010, 0, 0b10101010, 0, 0b10101010, 0]
-     );
- 
--    expand_pass(&mut img, width, &[0b11110000], &info(6, 1, width), bits_pp);
-+    expand_pass(&mut img, stride, &[0b11110000], &info(6, 1, width), bits_pp);
-     assert_eq!(
-         img,
-         [0b11111111u8, 0, 0b11111111, 0, 0b10101010, 0, 0b10101010, 0]
-     );
- 
--    expand_pass(&mut img, width, &[0b11110000], &info(6, 2, width), bits_pp);
-+    expand_pass(&mut img, stride, &[0b11110000], &info(6, 2, width), bits_pp);
-     assert_eq!(
-         img,
-         [0b11111111u8, 0, 0b11111111, 0, 0b11111111, 0, 0b10101010, 0]
-     );
- 
--    expand_pass(&mut img, width, &[0b11110000], &info(6, 3, width), bits_pp);
-+    expand_pass(&mut img, stride, &[0b11110000], &info(6, 3, width), bits_pp);
-     assert_eq!(
-         [0b11111111u8, 0, 0b11111111, 0, 0b11111111, 0, 0b11111111, 0],
-         img
-     );
- 
--    expand_pass(&mut img, width, &[0b11111111], &info(7, 0, width), bits_pp);
-+    expand_pass(&mut img, stride, &[0b11111111], &info(7, 0, width), bits_pp);
-     assert_eq!(
-         [
-             0b11111111u8,
-@@ -375,7 +402,7 @@ fn test_expand_pass_subbyte() {
-         img
-     );
- 
--    expand_pass(&mut img, width, &[0b11111111], &info(7, 1, width), bits_pp);
-+    expand_pass(&mut img, stride, &[0b11111111], &info(7, 1, width), bits_pp);
-     assert_eq!(
-         [
-             0b11111111u8,
-@@ -390,7 +417,7 @@ fn test_expand_pass_subbyte() {
-         img
-     );
- 
--    expand_pass(&mut img, width, &[0b11111111], &info(7, 2, width), bits_pp);
-+    expand_pass(&mut img, stride, &[0b11111111], &info(7, 2, width), bits_pp);
-     assert_eq!(
-         [
-             0b11111111u8,
-@@ -405,7 +432,7 @@ fn test_expand_pass_subbyte() {
-         img
-     );
- 
--    expand_pass(&mut img, width, &[0b11111111], &info(7, 3, width), bits_pp);
-+    expand_pass(&mut img, stride, &[0b11111111], &info(7, 3, width), bits_pp);
-     assert_eq!(
-         [
-             0b11111111u8,
-@@ -422,10 +449,10 @@ fn test_expand_pass_subbyte() {
- }
- 
- #[cfg(test)]
--fn create_adam7_info_for_tests(pass: u8, line: u32, img_width: u32) -> Adam7Info {
-+fn create_adam7_info_for_tests(pass: u8, line: u32, img_width: usize) -> Adam7Info {
-     let width = {
-         let img_height = 8;
--        Adam7Iterator::new(img_width, img_height)
-+        Adam7Iterator::new(img_width as u32, img_height)
-             .filter(|info| info.pass == pass)
-             .map(|info| info.width)
-             .next()
-diff --git a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/decoder/mod.rs b/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/decoder/mod.rs
-index bbd5953..8f50e9b 100644
---- a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/decoder/mod.rs
-+++ b/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/decoder/mod.rs
-@@ -554,7 +554,7 @@ impl<R: Read> Reader<R> {
-         self.current_start = 0;
-         self.prev_start = 0;
-         if self.info().interlaced {
--            let width = self.info().width;
-+            let stride = self.output_line_size(self.info().width);
-             let samples = color_type.samples() as u8;
-             let bits_pp = samples * (bit_depth as u8);
-             while let Some(InterlacedRow {
-@@ -565,7 +565,7 @@ impl<R: Read> Reader<R> {
-             {
-                 // `unwrap` won't panic, because we checked `self.info().interlaced` above.
-                 let adam7info = interlace.get_adam7_info().unwrap();
--                adam7::expand_pass(buf, width, row, &adam7info, bits_pp);
-+                adam7::expand_pass(buf, stride, row, &adam7info, bits_pp);
-             }
-         } else {
-             for row in buf
--- 
-2.46.0.598.g6f2099f65c-goog
-
diff --git a/third_party/rust/chromium_crates_io/patches/png/0105-New-public-API-pub-fn-expand_interlaced_row.patch b/third_party/rust/chromium_crates_io/patches/png/0105-New-public-API-pub-fn-expand_interlaced_row.patch
deleted file mode 100644
index 8601f12a3cda39..00000000000000
--- a/third_party/rust/chromium_crates_io/patches/png/0105-New-public-API-pub-fn-expand_interlaced_row.patch
+++ /dev/null
@@ -1,94 +0,0 @@
-From 83c89cd36644e73648ea100128370cbcab6a3834 Mon Sep 17 00:00:00 2001
-From: Lukasz Anforowicz <lukasza@chromium.org>
-Date: Wed, 28 Aug 2024 23:22:26 +0000
-Subject: [PATCH 105/107] New public API: `pub fn expand_interlaced_row`.
-
-This also exposes supporting items through the public API: `Adam7Info`,
-`InterlaceInfo`, `InterlacedRow`.
----
- src/adam7.rs | 35 +++++++++++++++++++++++++++--------
- src/lib.rs   |  5 ++++-
- 2 files changed, 31 insertions(+), 9 deletions(-)
-
-diff --git a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/adam7.rs b/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/adam7.rs
-index 2863f2a..4d65be8 100644
---- a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/adam7.rs
-+++ b/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/adam7.rs
-@@ -5,7 +5,7 @@
- /// [the Adam7 algorithm](https://en.wikipedia.org/wiki/Adam7_algorithm)
- /// applies to a decoded row.
- ///
--/// See also [Reader::next_interlaced_row].
-+/// See also [crate::decoder::Reader::next_interlaced_row].
- #[derive(Clone, Copy, Debug, PartialEq, Eq)]
- pub struct Adam7Info {
-     pub(crate) pass: u8,
-@@ -152,21 +152,40 @@ fn expand_adam7_bits(
-         .map(move |bits_offset| bits_offset + line_start)
- }
- 
--/// Expands an Adam 7 pass
--pub fn expand_pass(img: &mut [u8], stride: usize, scanline: &[u8], info: &Adam7Info, bits_pp: u8) {
--    let bits_pp = bits_pp as usize;
--
--    let bit_indices = expand_adam7_bits(stride, info, bits_pp);
-+/// Copies pixels from `interlaced_row` into the right location in `img`.
-+///
-+/// First bytes of `img` should belong to the top-left corner of the currently decoded frame.
-+///
-+/// `img_row_stride` specifies an offset in bytes between subsequent rows of `img`.
-+/// This can be the width of the current frame being decoded, but this is not required - a bigger
-+/// stride may be useful if the frame being decoded is a sub-region of `img`.
-+///
-+/// `interlaced_row` and `interlace_info` typically come from
-+/// [crate::decoder::Reader::next_interlaced_row], but this is not required.  In particular, before
-+/// calling `expand_interlaced_row` one may need to expand the decoded row, so that its format and
-+/// `bits_per_pixel` matches that of `img`.  Note that in initial Adam7 passes the `interlaced_row`
-+/// may contain less pixels that the width of the frame being decoded (e.g. it contains only 1/8th
-+/// of pixels in the initial pass).
-+pub fn expand_pass(
-+    img: &mut [u8],
-+    img_row_stride: usize,
-+    interlaced_row: &[u8],
-+    interlace_info: &Adam7Info,
-+    bits_per_pixel: u8,
-+) {
-+    let bits_pp = bits_per_pixel as usize;
-+
-+    let bit_indices = expand_adam7_bits(img_row_stride, interlace_info, bits_pp);
- 
-     if bits_pp < 8 {
--        for (pos, px) in bit_indices.zip(subbyte_pixels(scanline, bits_pp)) {
-+        for (pos, px) in bit_indices.zip(subbyte_pixels(interlaced_row, bits_pp)) {
-             let rem = 8 - pos % 8 - bits_pp;
-             img[pos / 8] |= px << rem as u8;
-         }
-     } else {
-         let bytes_pp = bits_pp / 8;
- 
--        for (bitpos, px) in bit_indices.zip(scanline.chunks(bytes_pp)) {
-+        for (bitpos, px) in bit_indices.zip(interlaced_row.chunks(bytes_pp)) {
-             for (offset, val) in px.iter().enumerate() {
-                 img[bitpos / 8 + offset] = *val;
-             }
-diff --git a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/lib.rs b/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/lib.rs
-index e514aa5..23c7b78 100644
---- a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/lib.rs
-+++ b/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/lib.rs
-@@ -71,9 +71,12 @@ mod srgb;
- pub mod text_metadata;
- mod traits;
- 
-+pub use crate::adam7::expand_pass as expand_interlaced_row;
-+pub use crate::adam7::Adam7Info;
- pub use crate::common::*;
- pub use crate::decoder::{
--    DecodeOptions, Decoded, Decoder, DecodingError, Limits, OutputInfo, Reader, StreamingDecoder,
-+    DecodeOptions, Decoded, Decoder, DecodingError, InterlaceInfo, InterlacedRow, Limits,
-+    OutputInfo, Reader, StreamingDecoder,
- };
- pub use crate::encoder::{Encoder, EncodingError, StreamWriter, Writer};
- pub use crate::filter::{AdaptiveFilterType, FilterType};
--- 
-2.46.0.598.g6f2099f65c-goog
-
diff --git a/third_party/rust/chromium_crates_io/patches/png/0106-Fix-cargo-doc-warnings.patch b/third_party/rust/chromium_crates_io/patches/png/0106-Fix-cargo-doc-warnings.patch
deleted file mode 100644
index 638931b29ef6aa..00000000000000
--- a/third_party/rust/chromium_crates_io/patches/png/0106-Fix-cargo-doc-warnings.patch
+++ /dev/null
@@ -1,39 +0,0 @@
-From ac04cd314dfa2259f8b2426c63a4b42c69fef0f8 Mon Sep 17 00:00:00 2001
-From: Lukasz Anforowicz <lukasza@chromium.org>
-Date: Fri, 30 Aug 2024 20:01:06 +0000
-Subject: [PATCH 106/107] Fix `cargo doc` warnings
-
----
- src/decoder/transform/palette.rs | 2 +-
- src/text_metadata.rs             | 2 +-
- 2 files changed, 2 insertions(+), 2 deletions(-)
-
-diff --git a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/decoder/transform/palette.rs b/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/decoder/transform/palette.rs
-index 0bf49f2..329c7bd 100644
---- a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/decoder/transform/palette.rs
-+++ b/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/decoder/transform/palette.rs
-@@ -5,7 +5,7 @@
- //!
- //! To achieve higher throughput, `create_rgba_palette` combines entries from
- //! `PLTE` and `trNS` chunks into a single lookup table.  This is based on the
--//! ideas explored in https://crbug.com/706134.
-+//! ideas explored in <https://crbug.com/706134>.
- //!
- //! Memoization is a trade-off:
- //! * On one hand, memoization requires spending X ns before starting to call
-diff --git a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/text_metadata.rs b/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/text_metadata.rs
-index 18a2abe..7fc730f 100644
---- a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/text_metadata.rs
-+++ b/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/text_metadata.rs
-@@ -145,7 +145,7 @@ pub(crate) enum TextDecodingError {
- 
- /// A generalized text chunk trait
- pub trait EncodableTextChunk {
--    /// Encode text chunk as Vec<u8> to a `Write`
-+    /// Encode text chunk as `Vec<u8>` to a `Write`
-     fn encode<W: Write>(&self, w: &mut W) -> Result<(), EncodingError>;
- }
- 
--- 
-2.46.0.598.g6f2099f65c-goog
-
diff --git a/third_party/rust/chromium_crates_io/patches/png/0107-Add-usage-example-to-the-doc-comment-of-fn-expand_in.patch b/third_party/rust/chromium_crates_io/patches/png/0107-Add-usage-example-to-the-doc-comment-of-fn-expand_in.patch
deleted file mode 100644
index f4955b9505cece..00000000000000
--- a/third_party/rust/chromium_crates_io/patches/png/0107-Add-usage-example-to-the-doc-comment-of-fn-expand_in.patch
+++ /dev/null
@@ -1,76 +0,0 @@
-From ddb54b298bc87079c2216d3bdc16749477d73cc1 Mon Sep 17 00:00:00 2001
-From: Lukasz Anforowicz <lukasza@chromium.org>
-Date: Fri, 30 Aug 2024 20:49:06 +0000
-Subject: [PATCH 107/107] Add usage example to the doc comment of `fn
- expand_interlaced_row`.
-
----
- src/adam7.rs | 45 +++++++++++++++++++++++++++++++++++++++++++++
- 1 file changed, 45 insertions(+)
-
-diff --git a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/adam7.rs b/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/adam7.rs
-index 4d65be8..8016b8b 100644
---- a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/adam7.rs
-+++ b/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/adam7.rs
-@@ -13,6 +13,31 @@ pub struct Adam7Info {
-     pub(crate) width: u32,
- }
- 
-+impl Adam7Info {
-+    /// Creates a new `Adam7Info`.  May panic if the arguments are out of range (e.g. if `pass` is
-+    /// 0 or greater than 8).
-+    ///
-+    /// * `pass` corresponds to a pass of the
-+    ///   [the Adam7 algorithm](https://en.wikipedia.org/wiki/Adam7_algorithm)
-+    /// * `line` is the number of a line within a pass (starting with 0).  For example,
-+    ///   in an image of height 8, `line` can be beteween `0..4` in the 7th `pass`
-+    ///   (those 4 interlaced rows correspond to 2nd, 4th, 6th, and 8th row of the full image).
-+    /// * `width` describes how many pixels are in an interlaced row.  For example,
-+    ///   in the 7th `pass`, the `width` is be the same as full image width, but in
-+    ///   in the 1st `pass`, the `width` is be 1/8th of the image width (rounded up as
-+    ///   necessary).
-+    ///
-+    /// Note that in typical usage, `Adam7Info`s are returned by [Reader::next_interlaced_row]
-+    /// and there is no need to create them by calling `Adam7Info::new`.  `Adam7Info::new` is
-+    /// nevertheless exposed as a public API, because it helps to provide self-contained example
-+    /// usage of [expand_interlaced_row].
-+    pub fn new(pass: u8, line: u32, width: u32) -> Self {
-+        assert!(1 <= pass && pass <= 7);
-+        assert!(width > 0);
-+        Self { pass, line, width }
-+    }
-+}
-+
- /// This iterator iterates over the different passes of an image Adam7 encoded
- /// PNG image
- /// The pattern is:
-@@ -166,6 +191,26 @@ fn expand_adam7_bits(
- /// `bits_per_pixel` matches that of `img`.  Note that in initial Adam7 passes the `interlaced_row`
- /// may contain less pixels that the width of the frame being decoded (e.g. it contains only 1/8th
- /// of pixels in the initial pass).
-+///
-+/// Example:
-+///
-+/// ```
-+/// use png::{expand_interlaced_row, Adam7Info};
-+/// let info = Adam7Info::new(5, 0, 4);  // 1st line of 5th pass has 4 pixels.
-+/// let mut img = vec![0; 8 * 8];
-+/// let row = vec![1, 2, 3, 4];
-+/// expand_interlaced_row(&mut img, 8, &row, &info, 8);
-+/// assert_eq!(&img, &[
-+///     0, 0, 0, 0, 0, 0, 0, 0,
-+///     0, 0, 0, 0, 0, 0, 0, 0,
-+///     1, 0, 2, 0, 3, 0, 4, 0,  // <= this is where the 1st line of 5s appears
-+///     0, 0, 0, 0, 0, 0, 0, 0,  //    in the schematic drawing of the passes at
-+///     0, 0, 0, 0, 0, 0, 0, 0,  //    https://en.wikipedia.org/wiki/Adam7_algorithm
-+///     0, 0, 0, 0, 0, 0, 0, 0,
-+///     0, 0, 0, 0, 0, 0, 0, 0,
-+///     0, 0, 0, 0, 0, 0, 0, 0,
-+/// ]);
-+/// ```
- pub fn expand_pass(
-     img: &mut [u8],
-     img_row_stride: usize,
--- 
-2.46.0.598.g6f2099f65c-goog
-
diff --git a/third_party/rust/chromium_crates_io/patches/png/0201-Extract-a-separate-interlace_info.rs-module.patch b/third_party/rust/chromium_crates_io/patches/png/0201-Extract-a-separate-interlace_info.rs-module.patch
deleted file mode 100644
index 339f8064b205cf..00000000000000
--- a/third_party/rust/chromium_crates_io/patches/png/0201-Extract-a-separate-interlace_info.rs-module.patch
+++ /dev/null
@@ -1,376 +0,0 @@
-From eebd5b2f43d635451a93fc6db6378ad8023a94f6 Mon Sep 17 00:00:00 2001
-From: Lukasz Anforowicz <lukasza@chromium.org>
-Date: Sun, 8 Sep 2024 20:40:17 +0000
-Subject: [PATCH] Extract a separate `interlace_info.rs` module.
-
-This commit decouples `fn next_pass` and `InterlaceIter` from the rest
-of `mod.rs` - this coupling was mostly limited to 1) using
-`self.subframe.rowlen` for `InterfaceInfo::Null` and 2) resetting
-`self.prev_start` in-between Adam7 passes.  This decoupling allows
-to encapsulate the related functionality inside a new
-`interlace_info.rs` module.  This helps in follow-up commits, where
-we want to refactor when exactly `Reader` advances that iterator.
----
- src/adam7.rs                  |  11 +--
- src/decoder/interlace_info.rs | 128 ++++++++++++++++++++++++++++++++++
- src/decoder/mod.rs            | 102 ++++++---------------------
- 3 files changed, 154 insertions(+), 87 deletions(-)
- create mode 100644 src/decoder/interlace_info.rs
-
-diff --git a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/adam7.rs b/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/adam7.rs
-index 8016b8b..75acf02 100644
---- a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/adam7.rs
-+++ b/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/adam7.rs
-@@ -5,7 +5,7 @@
- /// [the Adam7 algorithm](https://en.wikipedia.org/wiki/Adam7_algorithm)
- /// applies to a decoded row.
- ///
--/// See also [crate::decoder::Reader::next_interlaced_row].
-+/// See also [Reader.next_interlaced_row](crate::decoder::Reader::next_interlaced_row).
- #[derive(Clone, Copy, Debug, PartialEq, Eq)]
- pub struct Adam7Info {
-     pub(crate) pass: u8,
-@@ -27,10 +27,10 @@ impl Adam7Info {
-     ///   in the 1st `pass`, the `width` is be 1/8th of the image width (rounded up as
-     ///   necessary).
-     ///
--    /// Note that in typical usage, `Adam7Info`s are returned by [Reader::next_interlaced_row]
-+    /// Note that in typical usage, `Adam7Info`s are returned by [Reader.next_interlaced_row]
-     /// and there is no need to create them by calling `Adam7Info::new`.  `Adam7Info::new` is
-     /// nevertheless exposed as a public API, because it helps to provide self-contained example
--    /// usage of [expand_interlaced_row].
-+    /// usage of [expand_interlaced_row](crate::expand_interlaced_row).
-     pub fn new(pass: u8, line: u32, width: u32) -> Self {
-         assert!(1 <= pass && pass <= 7);
-         assert!(width > 0);
-@@ -92,11 +92,6 @@ impl Adam7Iterator {
-         self.lines = lines.ceil() as u32;
-         self.line = 0;
-     }
--
--    /// The current pass#.
--    pub fn current_pass(&self) -> u8 {
--        self.current_pass
--    }
- }
- 
- /// Iterates over `Adam7Info`s.
-diff --git a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/decoder/interlace_info.rs b/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/decoder/interlace_info.rs
-new file mode 100644
-index 0000000..4201fff
---- /dev/null
-+++ b/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/decoder/interlace_info.rs
-@@ -0,0 +1,128 @@
-+use std::ops::Range;
-+
-+use crate::adam7::{Adam7Info, Adam7Iterator};
-+
-+/// Describes which interlacing algorithm applies to a decoded row.
-+///
-+/// PNG (2003) specifies two interlace modes, but reserves future extensions.
-+///
-+/// See also [Reader.next_interlaced_row](crate::Reader::next_interlaced_row).
-+#[derive(Clone, Copy, Debug)]
-+pub enum InterlaceInfo {
-+    /// The `null` method means no interlacing.
-+    Null(NullInfo),
-+    /// [The `Adam7` algorithm](https://en.wikipedia.org/wiki/Adam7_algorithm) derives its name
-+    /// from doing 7 passes over the image, only decoding a subset of all pixels in each pass.
-+    /// The following table shows pictorially what parts of each 8x8 area of the image is found in
-+    /// each pass:
-+    ///
-+    /// ```txt
-+    /// 1 6 4 6 2 6 4 6
-+    /// 7 7 7 7 7 7 7 7
-+    /// 5 6 5 6 5 6 5 6
-+    /// 7 7 7 7 7 7 7 7
-+    /// 3 6 4 6 3 6 4 6
-+    /// 7 7 7 7 7 7 7 7
-+    /// 5 6 5 6 5 6 5 6
-+    /// 7 7 7 7 7 7 7 7
-+    /// ```
-+    Adam7(Adam7Info),
-+}
-+
-+#[derive(Clone, Copy, Debug)]
-+pub struct NullInfo {
-+    line: u32,
-+}
-+
-+impl InterlaceInfo {
-+    pub(crate) fn line_number(&self) -> u32 {
-+        match self {
-+            InterlaceInfo::Null(NullInfo { line }) => *line,
-+            InterlaceInfo::Adam7(Adam7Info { line, .. }) => *line,
-+        }
-+    }
-+
-+    pub(crate) fn get_adam7_info(&self) -> Option<&Adam7Info> {
-+        match self {
-+            InterlaceInfo::Null(_) => None,
-+            InterlaceInfo::Adam7(adam7info) => Some(adam7info),
-+        }
-+    }
-+}
-+
-+pub(crate) struct InterlaceInfoIter(IterImpl);
-+
-+impl InterlaceInfoIter {
-+    pub fn empty() -> Self {
-+        Self(IterImpl::None(0..0))
-+    }
-+
-+    pub fn new(width: u32, height: u32, interlaced: bool) -> Self {
-+        if interlaced {
-+            Self(IterImpl::Adam7(Adam7Iterator::new(width, height)))
-+        } else {
-+            Self(IterImpl::None(0..height))
-+        }
-+    }
-+}
-+
-+impl Iterator for InterlaceInfoIter {
-+    type Item = InterlaceInfo;
-+
-+    fn next(&mut self) -> Option<InterlaceInfo> {
-+        match self.0 {
-+            IterImpl::Adam7(ref mut adam7) => Some(InterlaceInfo::Adam7(adam7.next()?)),
-+            IterImpl::None(ref mut height) => Some(InterlaceInfo::Null(NullInfo {
-+                line: height.next()?,
-+            })),
-+        }
-+    }
-+}
-+
-+enum IterImpl {
-+    None(Range<u32>),
-+    Adam7(Adam7Iterator),
-+}
-+
-+#[cfg(test)]
-+mod test {
-+    use super::*;
-+
-+    #[test]
-+    fn null() {
-+        assert_eq!(
-+            InterlaceInfoIter::new(8, 8, false)
-+                .map(|info| info.line_number())
-+                .collect::<Vec<_>>(),
-+            vec![0, 1, 2, 3, 4, 5, 6, 7],
-+        );
-+    }
-+
-+    #[test]
-+    fn adam7() {
-+        assert_eq!(
-+            InterlaceInfoIter::new(8, 8, true)
-+                .map(|info| info.line_number())
-+                .collect::<Vec<_>>(),
-+            vec![
-+                0, // pass 1
-+                0, // pass 2
-+                0, // pass 3
-+                0, 1, // pass 4
-+                0, 1, // pass 5
-+                0, 1, 2, 3, // pass 6
-+                0, 1, 2, 3, // pass 7
-+            ],
-+        );
-+    }
-+
-+    #[test]
-+    fn empty() {
-+        assert_eq!(
-+            InterlaceInfoIter::empty()
-+                .map(|info| info.line_number())
-+                .collect::<Vec<_>>(),
-+            vec![],
-+        );
-+    }
-+}
-diff --git a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/decoder/mod.rs b/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/decoder/mod.rs
-index 8f50e9b..abe94c1 100644
---- a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/decoder/mod.rs
-+++ b/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/decoder/mod.rs
-@@ -1,3 +1,4 @@
-+mod interlace_info;
- mod stream;
- pub(crate) mod transform;
- mod zlib;
-@@ -8,15 +9,17 @@ use self::transform::{create_transform_fn, TransformFn};
- 
- use std::io::{BufRead, BufReader, Read};
- use std::mem;
--use std::ops::Range;
- 
--use crate::adam7;
-+use crate::adam7::{self, Adam7Info};
- use crate::chunk;
- use crate::common::{
-     BitDepth, BytesPerPixel, ColorType, Info, ParameterErrorKind, Transformations,
- };
- use crate::filter::{unfilter, FilterType};
- 
-+pub use interlace_info::InterlaceInfo;
-+use interlace_info::InterlaceInfoIter;
-+
- /*
- pub enum InterlaceHandling {
-     /// Outputs the raw rows
-@@ -104,42 +107,6 @@ impl<'data> InterlacedRow<'data> {
-     }
- }
- 
--/// Describes which interlacing algorithm applies to a decoded row.
--///
--/// PNG (2003) specifies two interlace modes, but reserves future extensions.
--///
--/// See also [Reader::next_interlaced_row].
--#[derive(Clone, Copy, Debug)]
--pub enum InterlaceInfo {
--    /// The `null` method means no interlacing.
--    Null,
--    /// [The `Adam7` algorithm](https://en.wikipedia.org/wiki/Adam7_algorithm) derives its name
--    /// from doing 7 passes over the image, only decoding a subset of all pixels in each pass.
--    /// The following table shows pictorially what parts of each 8x8 area of the image is found in
--    /// each pass:
--    ///
--    /// ```txt
--    /// 1 6 4 6 2 6 4 6
--    /// 7 7 7 7 7 7 7 7
--    /// 5 6 5 6 5 6 5 6
--    /// 7 7 7 7 7 7 7 7
--    /// 3 6 4 6 3 6 4 6
--    /// 7 7 7 7 7 7 7 7
--    /// 5 6 5 6 5 6 5 6
--    /// 7 7 7 7 7 7 7 7
--    /// ```
--    Adam7(adam7::Adam7Info),
--}
--
--impl InterlaceInfo {
--    fn get_adam7_info(&self) -> Option<&adam7::Adam7Info> {
--        match self {
--            InterlaceInfo::Null => None,
--            InterlaceInfo::Adam7(adam7info) => Some(adam7info),
--        }
--    }
--}
--
- /// A row of data without interlace information.
- #[derive(Clone, Copy, Debug)]
- pub struct Row<'data> {
-@@ -422,16 +389,10 @@ struct SubframeInfo {
-     width: u32,
-     height: u32,
-     rowlen: usize,
--    interlace: InterlaceIter,
-+    interlace: InterlaceInfoIter,
-     consumed_and_flushed: bool,
- }
- 
--#[derive(Clone)]
--enum InterlaceIter {
--    None(Range<u32>),
--    Adam7(adam7::Adam7Iterator),
--}
--
- /// Denote a frame as given by sequence numbers.
- #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
- enum SubframeIdx {
-@@ -565,7 +526,7 @@ impl<R: Read> Reader<R> {
-             {
-                 // `unwrap` won't panic, because we checked `self.info().interlaced` above.
-                 let adam7info = interlace.get_adam7_info().unwrap();
--                adam7::expand_pass(buf, stride, row, &adam7info, bits_pp);
-+                adam7::expand_pass(buf, stride, row, adam7info, bits_pp);
-             }
-         } else {
-             for row in buf
-@@ -610,15 +571,22 @@ impl<R: Read> Reader<R> {
- 
-     /// Returns the next processed row of the image
-     pub fn next_interlaced_row(&mut self) -> Result<Option<InterlacedRow>, DecodingError> {
--        let (rowlen, interlace) = match self.next_pass() {
--            Some((rowlen, interlace)) => (rowlen, interlace),
-+        let interlace = match self.subframe.interlace.next() {
-             None => return Ok(None),
-+            Some(interlace) => interlace,
-         };
--
--        let width = if let InterlaceInfo::Adam7(adam7::Adam7Info { width, .. }) = interlace {
--            width
--        } else {
--            self.subframe.width
-+        if interlace.line_number() == 0 {
-+            self.prev_start = self.current_start;
-+        }
-+        let rowlen = match interlace {
-+            InterlaceInfo::Null(_) => self.subframe.rowlen,
-+            InterlaceInfo::Adam7(Adam7Info { width, .. }) => {
-+                self.info().raw_row_length_from_width(width)
-+            }
-+        };
-+        let width = match interlace {
-+            InterlaceInfo::Adam7(Adam7Info { width, .. }) => width,
-+            InterlaceInfo::Null(_) => self.subframe.width,
-         };
-         let output_line_size = self.output_line_size(width);
- 
-@@ -727,24 +695,6 @@ impl<R: Read> Reader<R> {
-         color.raw_row_length_from_width(depth, width) - 1
-     }
- 
--    fn next_pass(&mut self) -> Option<(usize, InterlaceInfo)> {
--        match self.subframe.interlace {
--            InterlaceIter::Adam7(ref mut adam7) => {
--                let last_pass = adam7.current_pass();
--                let adam7info = adam7.next()?;
--                let rowlen = self.info().raw_row_length_from_width(adam7info.width);
--                if last_pass != adam7info.pass {
--                    self.prev_start = self.current_start;
--                }
--                Some((rowlen, InterlaceInfo::Adam7(adam7info)))
--            }
--            InterlaceIter::None(ref mut height) => {
--                let _ = height.next()?;
--                Some((self.subframe.rowlen, InterlaceInfo::Null))
--            }
--        }
--    }
--
-     /// Write the next raw interlaced row into `self.prev`.
-     ///
-     /// The scanline is filtered against the previous scanline according to the specification.
-@@ -812,7 +762,7 @@ impl SubframeInfo {
-             width: 0,
-             height: 0,
-             rowlen: 0,
--            interlace: InterlaceIter::None(0..0),
-+            interlace: InterlaceInfoIter::empty(),
-             consumed_and_flushed: false,
-         }
-     }
-@@ -826,17 +776,11 @@ impl SubframeInfo {
-             (info.width, info.height)
-         };
- 
--        let interlace = if info.interlaced {
--            InterlaceIter::Adam7(adam7::Adam7Iterator::new(width, height))
--        } else {
--            InterlaceIter::None(0..height)
--        };
--
-         SubframeInfo {
-             width,
-             height,
-             rowlen: info.raw_row_length_from_width(width),
--            interlace,
-+            interlace: InterlaceInfoIter::new(width, height, info.interlaced),
-             consumed_and_flushed: false,
-         }
-     }
--- 
-2.46.0.662.g92d0881bb0-goog
-
diff --git a/third_party/rust/chromium_crates_io/patches/png/0202-Support-for-detecting-an-unexpected-EOF-using-the-pu.patch b/third_party/rust/chromium_crates_io/patches/png/0202-Support-for-detecting-an-unexpected-EOF-using-the-pu.patch
deleted file mode 100644
index 95e9f542e757df..00000000000000
--- a/third_party/rust/chromium_crates_io/patches/png/0202-Support-for-detecting-an-unexpected-EOF-using-the-pu.patch
+++ /dev/null
@@ -1,129 +0,0 @@
-From b5b0674a0cd50a1f3c1e09f699c04b168648a237 Mon Sep 17 00:00:00 2001
-From: Lukasz Anforowicz <lukasza@chromium.org>
-Date: Sun, 8 Sep 2024 20:02:54 +0000
-Subject: [PATCH 202/203] Support for detecting an unexpected EOF using the
- public API.
-
-This commit supports detecting unexpected EOF using the public API of of
-`DecodingError`.  Before this commit `UnexpectedEof`,
-`UnexpectedEndOfChunk`, and `NoMoreImageData` errors were represented as
-a crate-internal `FormatErrorInner` type.  After this commit, these
-errors have a representation that can be detected using the public API:
-`DecodingError::IoError(std::io::ErrorKind::UnexpectedEof.into())`.
----
- src/decoder/mod.rs    | 31 +++++++------------------------
- src/decoder/stream.rs | 12 ------------
- 2 files changed, 7 insertions(+), 36 deletions(-)
-
-diff --git a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/decoder/mod.rs b/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/decoder/mod.rs
-index abe94c1..94a95bb 100644
---- a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/decoder/mod.rs
-+++ b/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/decoder/mod.rs
-@@ -191,9 +191,7 @@ impl<R: Read> Decoder<R> {
-         while self.read_decoder.info().is_none() {
-             buf.clear();
-             if self.read_decoder.decode_next(&mut buf)?.is_none() {
--                return Err(DecodingError::Format(
--                    FormatErrorInner::UnexpectedEof.into(),
--                ));
-+                return Err(DecodingError::IoError(std::io::ErrorKind::UnexpectedEof.into()));
-             }
-         }
-         Ok(self.read_decoder.info().unwrap())
-@@ -303,9 +301,7 @@ impl<R: Read> ReadDecoder<R> {
-             let (consumed, result) = {
-                 let buf = self.reader.fill_buf()?;
-                 if buf.is_empty() {
--                    return Err(DecodingError::Format(
--                        FormatErrorInner::UnexpectedEof.into(),
--                    ));
-+                    return Err(DecodingError::IoError(std::io::ErrorKind::UnexpectedEof.into()));
-                 }
-                 self.decoder.update(buf, image_data)?
-             };
-@@ -323,9 +319,7 @@ impl<R: Read> ReadDecoder<R> {
-         while !self.at_eof {
-             let buf = self.reader.fill_buf()?;
-             if buf.is_empty() {
--                return Err(DecodingError::Format(
--                    FormatErrorInner::UnexpectedEof.into(),
--                ));
-+                return Err(DecodingError::IoError(std::io::ErrorKind::UnexpectedEof.into()));
-             }
-             let (consumed, event) = self.decoder.update(buf, &mut vec![])?;
-             self.reader.consume(consumed);
-@@ -340,9 +334,7 @@ impl<R: Read> ReadDecoder<R> {
-             }
-         }
- 
--        Err(DecodingError::Format(
--            FormatErrorInner::UnexpectedEof.into(),
--        ))
-+        Err(DecodingError::IoError(std::io::ErrorKind::UnexpectedEof.into()))
-     }
- 
-     fn info(&self) -> Option<&Info<'static>> {
-@@ -702,9 +694,7 @@ impl<R: Read> Reader<R> {
-         // Read image data until we have at least one full row (but possibly more than one).
-         while self.data_stream.len() - self.current_start < rowlen {
-             if self.subframe.consumed_and_flushed {
--                return Err(DecodingError::Format(
--                    FormatErrorInner::NoMoreImageData.into(),
--                ));
-+                return Err(DecodingError::IoError(std::io::ErrorKind::UnexpectedEof.into()));
-             }
- 
-             // Clear the current buffer before appending more data.
-@@ -722,14 +712,7 @@ impl<R: Read> Reader<R> {
-                     self.subframe.consumed_and_flushed = true;
-                 }
-                 None => {
--                    return Err(DecodingError::Format(
--                        if self.data_stream.is_empty() {
--                            FormatErrorInner::NoMoreImageData
--                        } else {
--                            FormatErrorInner::UnexpectedEndOfChunk
--                        }
--                        .into(),
--                    ));
-+                    return Err(DecodingError::IoError(std::io::ErrorKind::UnexpectedEof.into()));
-                 }
-                 _ => (),
-             }
-diff --git a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/decoder/stream.rs b/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/decoder/stream.rs
-index 0f0c58d..3b6ccb6 100644
---- a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/decoder/stream.rs
-+++ b/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/decoder/stream.rs
-@@ -160,10 +160,6 @@ pub(crate) enum FormatErrorInner {
-     },
-     /// Not a PNG, the magic signature is missing.
-     InvalidSignature,
--    /// End of file, within a chunk event.
--    UnexpectedEof,
--    /// End of file, while expecting more image data.
--    UnexpectedEndOfChunk,
-     // Errors of chunk level ordering, missing etc.
-     /// Ihdr must occur.
-     MissingIhdr,
-@@ -232,8 +228,6 @@ pub(crate) enum FormatErrorInner {
-     CorruptFlateStream {
-         err: fdeflate::DecompressionError,
-     },
--    /// The image data chunk was too short for the expected pixel count.
--    NoMoreImageData,
-     /// Bad text encoding
-     BadTextEncoding(TextDecodingError),
-     /// fdAT shorter than 4 bytes
-@@ -323,9 +317,6 @@ impl fmt::Display for FormatError {
-             UnknownInterlaceMethod(nr) => write!(fmt, "Unknown interlace method {}.", nr),
-             BadSubFrameBounds {} => write!(fmt, "Sub frame is out-of-bounds."),
-             InvalidSignature => write!(fmt, "Invalid PNG signature."),
--            UnexpectedEof => write!(fmt, "Unexpected end of data before image end."),
--            UnexpectedEndOfChunk => write!(fmt, "Unexpected end of data within a chunk."),
--            NoMoreImageData => write!(fmt, "IDAT or fDAT chunk is has not enough data for image."),
-             CorruptFlateStream { err } => {
-                 write!(fmt, "Corrupt deflate stream. ")?;
-                 write!(fmt, "{:?}", err)
--- 
-2.46.0.662.g92d0881bb0-goog
-
diff --git a/third_party/rust/chromium_crates_io/patches/png/0203-Support-for-resuming-decoding-after-UnexpectedEof.patch b/third_party/rust/chromium_crates_io/patches/png/0203-Support-for-resuming-decoding-after-UnexpectedEof.patch
deleted file mode 100644
index e008f0d1a731ab..00000000000000
--- a/third_party/rust/chromium_crates_io/patches/png/0203-Support-for-resuming-decoding-after-UnexpectedEof.patch
+++ /dev/null
@@ -1,336 +0,0 @@
-From 5efbb60ab8eb1ac928b7ddc1a5946d0ed7f47e7b Mon Sep 17 00:00:00 2001
-From: Lukasz Anforowicz <lukasza@chromium.org>
-Date: Wed, 4 Sep 2024 02:18:49 +0000
-Subject: [PATCH 203/203] Support for resuming decoding after `UnexpectedEof`.
-
-This commit supports resuming decoding after `UnexpectedEof`:
-
-* Before this commit `fn next_interlaced_row` would unconditionally call
-  `InterlaceInfoIter.next` - advancing to the next row.  After this
-  commit this will only happen after a row has been successfully
-  decoded (inside `next_interlaced_row_impl` because advancing needs
-  to be synchronized across the public `next_frame` and
-  `next_interlaced_row` APIs)..
-* Before this commit `fn next_frame` would always start decoding into
-  the very beginning of `buf`, even if these initial rows have already
-  been successfully decoded earlier.  After this commit an offset is
-  calculated based on `InterlaceInfo.line_number`.
-* Before this commit `fn next_frame` would always reset `data_stream`,
-  `current_start`, and `prev_start`.  After this commit, this got moved
-  and only happens inside `read_until_image_data`.
----
- src/decoder/mod.rs    |  30 ++++---
- src/decoder/stream.rs | 181 +++++++++++++++++++++++++++++++++++++++++-
- 2 files changed, 200 insertions(+), 11 deletions(-)
-
-diff --git a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/decoder/mod.rs b/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/decoder/mod.rs
-index 94a95bb..91adbc9 100644
---- a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/decoder/mod.rs
-+++ b/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/decoder/mod.rs
-@@ -381,12 +381,13 @@ struct SubframeInfo {
-     width: u32,
-     height: u32,
-     rowlen: usize,
--    interlace: InterlaceInfoIter,
-+    current_interlace_info: Option<InterlaceInfo>,
-+    interlace_info_iter: InterlaceInfoIter,
-     consumed_and_flushed: bool,
- }
- 
- /// Denote a frame as given by sequence numbers.
--#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
-+#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
- enum SubframeIdx {
-     /// The initial frame in an IDAT chunk without fcTL chunk applying to it.
-     /// Note that this variant precedes `Some` as IDAT frames precede fdAT frames and all fdAT
-@@ -439,6 +440,9 @@ impl<R: Read> Reader<R> {
-             .ok_or(DecodingError::Format(FormatErrorInner::MissingIhdr.into()))?;
-         self.bpp = info.bpp_in_prediction();
-         self.subframe = SubframeInfo::new(info);
-+        self.data_stream.clear();
-+        self.current_start = 0;
-+        self.prev_start = 0;
- 
-         // Allocate output buffer.
-         let buflen = self.output_line_size(self.subframe.width);
-@@ -503,9 +507,6 @@ impl<R: Read> Reader<R> {
-             line_size: self.output_line_size(self.subframe.width),
-         };
- 
--        self.data_stream.clear();
--        self.current_start = 0;
--        self.prev_start = 0;
-         if self.info().interlaced {
-             let stride = self.output_line_size(self.info().width);
-             let samples = color_type.samples() as u8;
-@@ -521,9 +522,15 @@ impl<R: Read> Reader<R> {
-                 adam7::expand_pass(buf, stride, row, adam7info, bits_pp);
-             }
-         } else {
-+            let current_interlace_info = self.subframe.current_interlace_info.as_ref();
-+            let already_done_rows = current_interlace_info
-+                .map(|info| info.line_number())
-+                .unwrap_or(self.subframe.height);
-+
-             for row in buf
-                 .chunks_exact_mut(output_info.line_size)
-                 .take(self.subframe.height as usize)
-+                .skip(already_done_rows as usize)
-             {
-                 self.next_interlaced_row_impl(self.subframe.rowlen, row)?;
-             }
-@@ -563,9 +570,9 @@ impl<R: Read> Reader<R> {
- 
-     /// Returns the next processed row of the image
-     pub fn next_interlaced_row(&mut self) -> Result<Option<InterlacedRow>, DecodingError> {
--        let interlace = match self.subframe.interlace.next() {
-+        let interlace = match self.subframe.current_interlace_info.as_ref() {
-             None => return Ok(None),
--            Some(interlace) => interlace,
-+            Some(interlace) => *interlace,
-         };
-         if interlace.line_number() == 0 {
-             self.prev_start = self.current_start;
-@@ -634,6 +641,7 @@ impl<R: Read> Reader<R> {
-         };
-         transform_fn(row, output_buffer, self.info());
- 
-+        self.subframe.current_interlace_info = self.subframe.interlace_info_iter.next();
-         Ok(())
-     }
- 
-@@ -745,7 +753,8 @@ impl SubframeInfo {
-             width: 0,
-             height: 0,
-             rowlen: 0,
--            interlace: InterlaceInfoIter::empty(),
-+            current_interlace_info: None,
-+            interlace_info_iter: InterlaceInfoIter::empty(),
-             consumed_and_flushed: false,
-         }
-     }
-@@ -759,11 +768,14 @@ impl SubframeInfo {
-             (info.width, info.height)
-         };
- 
-+        let mut interlace_info_iter = InterlaceInfoIter::new(width, height, info.interlaced);
-+        let current_interlace_info = interlace_info_iter.next();
-         SubframeInfo {
-             width,
-             height,
-             rowlen: info.raw_row_length_from_width(width),
--            interlace: InterlaceInfoIter::new(width, height, info.interlaced),
-+            current_interlace_info,
-+            interlace_info_iter,
-             consumed_and_flushed: false,
-         }
-     }
-diff --git a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/decoder/stream.rs b/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/decoder/stream.rs
-index 3b6ccb6..6afaf19 100644
---- a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/decoder/stream.rs
-+++ b/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/decoder/stream.rs
-@@ -108,6 +108,11 @@ pub enum Decoded {
- #[derive(Debug)]
- pub enum DecodingError {
-     /// An error in IO of the underlying reader.
-+    ///
-+    /// Note that some IO errors may be recoverable - decoding may be retried after the
-+    /// error is resolved.  For example, decoding from a slow stream of data (e.g. decoding from a
-+    /// network stream) may occasionally result in [std::io::ErrorKind::UnexpectedEof] kind of
-+    /// error, but decoding can resume when more data becomes available.
-     IoError(io::Error),
-     /// The input image was not a valid PNG.
-     ///
-@@ -1498,10 +1503,12 @@ mod tests {
-     use super::ScaledFloat;
-     use super::SourceChromaticities;
-     use crate::test_utils::*;
--    use crate::{Decoder, DecodingError};
-+    use crate::{Decoder, DecodingError, Reader};
-     use byteorder::WriteBytesExt;
-+    use std::cell::RefCell;
-     use std::fs::File;
--    use std::io::Write;
-+    use std::io::{ErrorKind, Read, Write};
-+    use std::rc::Rc;
- 
-     #[test]
-     fn image_gamma() -> Result<(), ()> {
-@@ -1964,4 +1971,174 @@ mod tests {
-         reader.next_frame(&mut buf).unwrap();
-         assert_eq!(3093270825, crc32fast::hash(&buf));
-     }
-+
-+    /// `StremingInput` can be used by tests to simulate a streaming input
-+    /// (e.g. a slow http response, where all bytes are not immediately available).
-+    #[derive(Clone)]
-+    struct StreamingInput(Rc<RefCell<StreamingInputState>>);
-+
-+    struct StreamingInputState {
-+        full_input: Vec<u8>,
-+        current_pos: usize,
-+        available_len: usize,
-+    }
-+
-+    impl StreamingInput {
-+        fn new(full_input: Vec<u8>) -> Self {
-+            Self(Rc::new(RefCell::new(StreamingInputState {
-+                full_input,
-+                current_pos: 0,
-+                available_len: 0,
-+            })))
-+        }
-+
-+        fn with_noncompressed_png(width: u32, idat_size: usize) -> Self {
-+            let mut png = Vec::new();
-+            write_noncompressed_png(&mut png, width, idat_size);
-+            Self::new(png)
-+        }
-+
-+        fn expose_next_byte(&self) {
-+            let mut state = self.0.borrow_mut();
-+            assert!(state.available_len < state.full_input.len());
-+            state.available_len += 1;
-+        }
-+
-+        fn stream_input_until_reader_is_available(&self) -> Reader<StreamingInput> {
-+            loop {
-+                self.0.borrow_mut().current_pos = 0;
-+                match Decoder::new(self.clone()).read_info() {
-+                    Ok(reader) => {
-+                        break reader;
-+                    }
-+                    Err(DecodingError::IoError(e)) if e.kind() == ErrorKind::UnexpectedEof => {
-+                        self.expose_next_byte();
-+                    }
-+                    _ => panic!("Unexpected error"),
-+                }
-+            }
-+        }
-+
-+        fn decode_full_input<F, R>(&self, f: F) -> R
-+        where
-+            F: FnOnce(Reader<&[u8]>) -> R,
-+        {
-+            let state = self.0.borrow();
-+            let decoder = Decoder::new(state.full_input.as_slice());
-+            f(decoder.read_info().unwrap())
-+        }
-+    }
-+
-+    impl Read for StreamingInput {
-+        fn read(&mut self, buf: &mut [u8]) -> std::io::Result<usize> {
-+            let mut state = self.0.borrow_mut();
-+            let mut available_bytes = &state.full_input[state.current_pos..state.available_len];
-+            let number_of_read_bytes = available_bytes.read(buf)?;
-+            state.current_pos += number_of_read_bytes;
-+            assert!(state.current_pos <= state.available_len);
-+            Ok(number_of_read_bytes)
-+        }
-+    }
-+
-+    /// Test resuming/retrying `Reader.next_frame` after `UnexpectedEof`.
-+    #[test]
-+    fn test_streaming_input_and_decoding_via_next_frame() {
-+        const WIDTH: u32 = 16;
-+        const IDAT_SIZE: usize = 512;
-+        let streaming_input = StreamingInput::with_noncompressed_png(WIDTH, IDAT_SIZE);
-+
-+        let (whole_output_info, decoded_from_whole_input) =
-+            streaming_input.decode_full_input(|mut r| {
-+                let mut buf = vec![0; r.output_buffer_size()];
-+                let output_info = r.next_frame(&mut buf).unwrap();
-+                (output_info, buf)
-+            });
-+
-+        let mut png_reader = streaming_input.stream_input_until_reader_is_available();
-+        let mut decoded_from_streaming_input = vec![0; png_reader.output_buffer_size()];
-+        let streaming_output_info = loop {
-+            match png_reader.next_frame(decoded_from_streaming_input.as_mut_slice()) {
-+                Ok(output_info) => break output_info,
-+                Err(DecodingError::IoError(e)) if e.kind() == ErrorKind::UnexpectedEof => {
-+                    streaming_input.expose_next_byte()
-+                }
-+                e => panic!("Unexpected error: {:?}", e),
-+            }
-+        };
-+        assert_eq!(whole_output_info, streaming_output_info);
-+        assert_eq!(
-+            crc32fast::hash(&decoded_from_whole_input),
-+            crc32fast::hash(&decoded_from_streaming_input)
-+        );
-+    }
-+
-+    /// Test resuming/retrying `Reader.next_row` after `UnexpectedEof`.
-+    #[test]
-+    fn test_streaming_input_and_decoding_via_next_row() {
-+        const WIDTH: u32 = 16;
-+        const IDAT_SIZE: usize = 512;
-+        let streaming_input = StreamingInput::with_noncompressed_png(WIDTH, IDAT_SIZE);
-+
-+        let decoded_from_whole_input = streaming_input.decode_full_input(|mut r| {
-+            let mut buf = vec![0; r.output_buffer_size()];
-+            r.next_frame(&mut buf).unwrap();
-+            buf
-+        });
-+
-+        let mut png_reader = streaming_input.stream_input_until_reader_is_available();
-+        let mut decoded_from_streaming_input = Vec::new();
-+        loop {
-+            match png_reader.next_row() {
-+                Ok(None) => break,
-+                Ok(Some(row)) => decoded_from_streaming_input.extend_from_slice(row.data()),
-+                Err(DecodingError::IoError(e)) if e.kind() == ErrorKind::UnexpectedEof => {
-+                    streaming_input.expose_next_byte()
-+                }
-+                e => panic!("Unexpected error: {:?}", e),
-+            }
-+        }
-+        assert_eq!(
-+            crc32fast::hash(&decoded_from_whole_input),
-+            crc32fast::hash(&decoded_from_streaming_input)
-+        );
-+    }
-+
-+    /// Test resuming/retrying `Decoder.read_header_info` after `UnexpectedEof`.
-+    #[test]
-+    fn test_streaming_input_and_reading_header_info() {
-+        const WIDTH: u32 = 16;
-+        const IDAT_SIZE: usize = 512;
-+        let streaming_input = StreamingInput::with_noncompressed_png(WIDTH, IDAT_SIZE);
-+
-+        let info_from_whole_input = streaming_input.decode_full_input(|r| r.info().clone());
-+
-+        let mut decoder = Decoder::new(streaming_input.clone());
-+        let info_from_streaming_input = loop {
-+            match decoder.read_header_info() {
-+                Ok(info) => break info.clone(),
-+                Err(DecodingError::IoError(e)) if e.kind() == ErrorKind::UnexpectedEof => {
-+                    streaming_input.expose_next_byte()
-+                }
-+                e => panic!("Unexpected error: {:?}", e),
-+            }
-+        };
-+
-+        assert_eq!(info_from_whole_input.width, info_from_streaming_input.width);
-+        assert_eq!(
-+            info_from_whole_input.height,
-+            info_from_streaming_input.height
-+        );
-+        assert_eq!(
-+            info_from_whole_input.bit_depth,
-+            info_from_streaming_input.bit_depth
-+        );
-+        assert_eq!(
-+            info_from_whole_input.color_type,
-+            info_from_streaming_input.color_type
-+        );
-+        assert_eq!(
-+            info_from_whole_input.interlaced,
-+            info_from_streaming_input.interlaced
-+        );
-+    }
- }
--- 
-2.46.0.662.g92d0881bb0-goog
-
diff --git a/third_party/rust/chromium_crates_io/supply-chain/audits.toml b/third_party/rust/chromium_crates_io/supply-chain/audits.toml
index 620603e9e91821..a60488cd9cf73c 100644
--- a/third_party/rust/chromium_crates_io/supply-chain/audits.toml
+++ b/third_party/rust/chromium_crates_io/supply-chain/audits.toml
@@ -1288,6 +1288,11 @@ Note that some additional, internal notes about an older version of this crate
 can be found at go/image-crate-chromium-security-review.
 '''
 
+[[audits.png]]
+who = "Lukasz Anforowicz <lukasza@chromium.org>"
+criteria = ["safe-to-deploy", "does-not-implement-crypto", "ub-risk-0"]
+delta = "0.17.13 -> 0.17.14"
+
 [[audits.ppv-lite86]]
 who = "danakj@chromium.org"
 criteria = ["safe-to-run", "does-not-implement-crypto"]
diff --git a/third_party/rust/chromium_crates_io/supply-chain/config.toml b/third_party/rust/chromium_crates_io/supply-chain/config.toml
index 06197fc8034054..ebde89384a7169 100644
--- a/third_party/rust/chromium_crates_io/supply-chain/config.toml
+++ b/third_party/rust/chromium_crates_io/supply-chain/config.toml
@@ -44,9 +44,6 @@ ub-risk-4 = "ub-risk-4"
 [policy."adler2:2.0.0"]
 criteria = ["crypto-safe", "safe-to-deploy", "ub-risk-2"]
 
-[policy."adler:1.0.2"]
-criteria = ["crypto-safe", "safe-to-deploy", "ub-risk-2"]
-
 [policy."aho-corasick:1.1.3"]
 criteria = ["crypto-safe", "safe-to-run"]
 
@@ -164,16 +161,13 @@ criteria = ["crypto-safe", "safe-to-deploy", "ub-risk-2"]
 [policy."minimal-lexical:0.2.1"]
 criteria = []
 
-[policy."miniz_oxide:0.7.4"]
-criteria = ["crypto-safe", "safe-to-deploy", "ub-risk-2"]
-
 [policy."miniz_oxide:0.8.0"]
 criteria = ["crypto-safe", "safe-to-deploy", "ub-risk-2"]
 
 [policy."nom:7.1.3"]
 criteria = ["crypto-safe", "safe-to-deploy", "ub-risk-2"]
 
-[policy."png:0.17.13"]
+[policy."png:0.17.14"]
 criteria = ["crypto-safe", "safe-to-deploy", "ub-risk-2"]
 
 [policy."ppv-lite86:0.2.20"]
diff --git a/third_party/rust/chromium_crates_io/vendor/adler-1.0.2/.cargo_vcs_info.json b/third_party/rust/chromium_crates_io/vendor/adler-1.0.2/.cargo_vcs_info.json
deleted file mode 100644
index b40982aec65323..00000000000000
--- a/third_party/rust/chromium_crates_io/vendor/adler-1.0.2/.cargo_vcs_info.json
+++ /dev/null
@@ -1,5 +0,0 @@
-{
-  "git": {
-    "sha1": "a94f525f62698d699d1fb3cc9112db8c35662b16"
-  }
-}
diff --git a/third_party/rust/chromium_crates_io/vendor/adler-1.0.2/.github/workflows/ci.yml b/third_party/rust/chromium_crates_io/vendor/adler-1.0.2/.github/workflows/ci.yml
deleted file mode 100644
index cf3189463bdb48..00000000000000
--- a/third_party/rust/chromium_crates_io/vendor/adler-1.0.2/.github/workflows/ci.yml
+++ /dev/null
@@ -1,81 +0,0 @@
-name: CI
-
-on:
-  push:
-    branches:
-    - master
-    - staging
-    - trying
-  pull_request:
-    branches:
-    - master
-
-env:
-  CARGO_TERM_COLOR: always
-  RUSTFLAGS: "--deny warnings"
-  MSRV: 1.31.0
-  NO_STD_TARGET: thumbv6m-none-eabi
-
-jobs:
-  test:
-    strategy:
-      matrix:
-        rust:
-          - stable
-          - nightly
-        os:
-          - ubuntu-latest
-          - macOS-latest
-          - windows-latest
-    runs-on: ${{ matrix.os }}
-    steps:
-    - uses: actions/checkout@v2
-    - uses: actions-rs/toolchain@v1
-      with:
-        profile: minimal
-        toolchain: ${{ matrix.rust }}
-        override: true
-    - name: Build
-      run: cargo build --all --all-targets
-    - name: Run tests
-      run: |
-        cargo test --all --all-targets
-        cargo test --all --no-default-features
-
-  no-std:
-    runs-on: ubuntu-latest
-    steps:
-    - uses: actions/checkout@v2
-    - uses: actions-rs/toolchain@v1
-      with:
-        profile: minimal
-        toolchain: stable
-        override: true
-        target: ${{ env.NO_STD_TARGET }}
-    - name: Build
-      run: cargo build --verbose --no-default-features --target ${{ env.NO_STD_TARGET }}
-
-  msrv:
-    runs-on: ubuntu-latest
-    steps:
-    - uses: actions/checkout@v2
-    - uses: actions-rs/toolchain@v1
-      with:
-        profile: minimal
-        toolchain: ${{ env.MSRV }}
-        override: true
-    - name: Build
-      run: cargo build --verbose
-
-  lint:
-    runs-on: ubuntu-latest
-    steps:
-    - uses: actions/checkout@v2
-    - uses: actions-rs/toolchain@v1
-      with:
-        profile: minimal
-        toolchain: stable
-        override: true
-        components: rustfmt
-    - name: Check code formatting
-      run: cargo fmt -- --check
diff --git a/third_party/rust/chromium_crates_io/vendor/adler-1.0.2/.gitignore b/third_party/rust/chromium_crates_io/vendor/adler-1.0.2/.gitignore
deleted file mode 100644
index a9d37c560c6ab8..00000000000000
--- a/third_party/rust/chromium_crates_io/vendor/adler-1.0.2/.gitignore
+++ /dev/null
@@ -1,2 +0,0 @@
-target
-Cargo.lock
diff --git a/third_party/rust/chromium_crates_io/vendor/adler-1.0.2/CHANGELOG.md b/third_party/rust/chromium_crates_io/vendor/adler-1.0.2/CHANGELOG.md
deleted file mode 100644
index 87994376e50f38..00000000000000
--- a/third_party/rust/chromium_crates_io/vendor/adler-1.0.2/CHANGELOG.md
+++ /dev/null
@@ -1,63 +0,0 @@
-# Changelog
-
-## Unreleased
-
-No changes.
-
-## [1.0.2 - 2021-02-26](https://github.com/jonas-schievink/adler/releases/tag/v1.0.2)
-
-- Fix doctest on big-endian systems ([#9]).
-
-[#9]: https://github.com/jonas-schievink/adler/pull/9
-
-## [1.0.1 - 2020-11-08](https://github.com/jonas-schievink/adler/releases/tag/v1.0.1)
-
-### Fixes
-
-- Fix documentation on docs.rs.
-
-## [1.0.0 - 2020-11-08](https://github.com/jonas-schievink/adler/releases/tag/v1.0.0)
-
-### Fixes
-
-- Fix `cargo test --no-default-features` ([#5]).
-
-### Improvements
-
-- Extended and clarified documentation.
-- Added more rustdoc examples.
-- Extended CI to test the crate with `--no-default-features`.
-
-### Breaking Changes
-
-- `adler32_reader` now takes its generic argument by value instead of as a `&mut`.
-- Renamed `adler32_reader` to `adler32`.
-
-## [0.2.3 - 2020-07-11](https://github.com/jonas-schievink/adler/releases/tag/v0.2.3)
-
-- Process 4 Bytes at a time, improving performance by up to 50% ([#2]).
-
-## [0.2.2 - 2020-06-27](https://github.com/jonas-schievink/adler/releases/tag/v0.2.2)
-
-- Bump MSRV to 1.31.0.
-
-## [0.2.1 - 2020-06-27](https://github.com/jonas-schievink/adler/releases/tag/v0.2.1)
-
-- Add a few `#[inline]` annotations to small functions.
-- Fix CI badge.
-- Allow integration into libstd.
-
-## [0.2.0 - 2020-06-27](https://github.com/jonas-schievink/adler/releases/tag/v0.2.0)
-
-- Support `#![no_std]` when using `default-features = false`.
-- Improve performance by around 7x.
-- Support Rust 1.8.0.
-- Improve API naming.
-
-## [0.1.0 - 2020-06-26](https://github.com/jonas-schievink/adler/releases/tag/v0.1.0)
-
-Initial release.
-
-
-[#2]: https://github.com/jonas-schievink/adler/pull/2
-[#5]: https://github.com/jonas-schievink/adler/pull/5
diff --git a/third_party/rust/chromium_crates_io/vendor/adler-1.0.2/Cargo.toml b/third_party/rust/chromium_crates_io/vendor/adler-1.0.2/Cargo.toml
deleted file mode 100644
index 1dacd2c70fec5e..00000000000000
--- a/third_party/rust/chromium_crates_io/vendor/adler-1.0.2/Cargo.toml
+++ /dev/null
@@ -1,64 +0,0 @@
-# THIS FILE IS AUTOMATICALLY GENERATED BY CARGO
-#
-# When uploading crates to the registry Cargo will automatically
-# "normalize" Cargo.toml files for maximal compatibility
-# with all versions of Cargo and also rewrite `path` dependencies
-# to registry (e.g., crates.io) dependencies
-#
-# If you believe there's an error in this file please file an
-# issue against the rust-lang/cargo repository. If you're
-# editing this file be aware that the upstream Cargo.toml
-# will likely look very different (and much more reasonable)
-
-[package]
-name = "adler"
-version = "1.0.2"
-authors = ["Jonas Schievink <jonasschievink@gmail.com>"]
-description = "A simple clean-room implementation of the Adler-32 checksum"
-documentation = "https://docs.rs/adler/"
-readme = "README.md"
-keywords = ["checksum", "integrity", "hash", "adler32", "zlib"]
-categories = ["algorithms"]
-license = "0BSD OR MIT OR Apache-2.0"
-repository = "https://github.com/jonas-schievink/adler.git"
-[package.metadata.docs.rs]
-rustdoc-args = ["--cfg=docsrs"]
-
-[package.metadata.release]
-no-dev-version = true
-pre-release-commit-message = "Release {{version}}"
-tag-message = "{{version}}"
-
-[[package.metadata.release.pre-release-replacements]]
-file = "CHANGELOG.md"
-replace = "## Unreleased\n\nNo changes.\n\n## [{{version}} - {{date}}](https://github.com/jonas-schievink/adler/releases/tag/v{{version}})\n"
-search = "## Unreleased\n"
-
-[[package.metadata.release.pre-release-replacements]]
-file = "README.md"
-replace = "adler = \"{{version}}\""
-search = "adler = \"[a-z0-9\\\\.-]+\""
-
-[[package.metadata.release.pre-release-replacements]]
-file = "src/lib.rs"
-replace = "https://docs.rs/adler/{{version}}"
-search = "https://docs.rs/adler/[a-z0-9\\.-]+"
-
-[[bench]]
-name = "bench"
-harness = false
-[dependencies.compiler_builtins]
-version = "0.1.2"
-optional = true
-
-[dependencies.core]
-version = "1.0.0"
-optional = true
-package = "rustc-std-workspace-core"
-[dev-dependencies.criterion]
-version = "0.3.2"
-
-[features]
-default = ["std"]
-rustc-dep-of-std = ["core", "compiler_builtins"]
-std = []
diff --git a/third_party/rust/chromium_crates_io/vendor/adler-1.0.2/Cargo.toml.orig b/third_party/rust/chromium_crates_io/vendor/adler-1.0.2/Cargo.toml.orig
deleted file mode 100644
index 8c3865b1af354f..00000000000000
--- a/third_party/rust/chromium_crates_io/vendor/adler-1.0.2/Cargo.toml.orig
+++ /dev/null
@@ -1,68 +0,0 @@
-[package]
-name = "adler"
-version = "1.0.2"
-authors = ["Jonas Schievink <jonasschievink@gmail.com>"]
-description = "A simple clean-room implementation of the Adler-32 checksum"
-documentation = "https://docs.rs/adler/"
-repository = "https://github.com/jonas-schievink/adler.git"
-keywords = ["checksum", "integrity", "hash", "adler32", "zlib"]
-categories = ["algorithms"]
-readme = "README.md"
-license = "0BSD OR MIT OR Apache-2.0"
-
-[[bench]]
-name = "bench"
-harness = false
-
-[dependencies]
-# Internal features, only used when building as part of libstd, not part of the
-# stable interface of this crate.
-core = { version = '1.0.0', optional = true, package = 'rustc-std-workspace-core' }
-compiler_builtins = { version = '0.1.2', optional = true }
-
-[dev-dependencies]
-criterion = "0.3.2"
-
-[features]
-# Disable default features to enable `#![no_std]` support.
-default = ["std"]
-std = []
-
-# Internal feature, only used when building as part of libstd, not part of the
-# stable interface of this crate.
-rustc-dep-of-std = ['core', 'compiler_builtins']
-
-
-[package.metadata.docs.rs]
-rustdoc-args = [ "--cfg=docsrs" ]
-
-# cargo-release configuration
-[package.metadata.release]
-tag-message = "{{version}}"
-no-dev-version = true
-pre-release-commit-message = "Release {{version}}"
-
-# Change the changelog's `Unreleased` section to refer to this release and
-# prepend a new `Unreleased` section
-[[package.metadata.release.pre-release-replacements]]
-file    = "CHANGELOG.md"
-search  = "## Unreleased\n"
-replace = """
-## Unreleased
-
-No changes.
-
-## [{{version}} - {{date}}](https://github.com/jonas-schievink/adler/releases/tag/v{{version}})
-"""
-
-# Bump the version inside the example manifest in `README.md`
-[[package.metadata.release.pre-release-replacements]]
-file    = "README.md"
-search  = 'adler = "[a-z0-9\\.-]+"'
-replace = 'adler = "{{version}}"'
-
-# Bump the version referenced by the `html_root_url` attribute in `lib.rs`
-[[package.metadata.release.pre-release-replacements]]
-file    = "src/lib.rs"
-search  = "https://docs.rs/adler/[a-z0-9\\.-]+"
-replace = "https://docs.rs/adler/{{version}}"
diff --git a/third_party/rust/chromium_crates_io/vendor/adler-1.0.2/LICENSE-0BSD b/third_party/rust/chromium_crates_io/vendor/adler-1.0.2/LICENSE-0BSD
deleted file mode 100644
index 89336aaca55db4..00000000000000
--- a/third_party/rust/chromium_crates_io/vendor/adler-1.0.2/LICENSE-0BSD
+++ /dev/null
@@ -1,12 +0,0 @@
-Copyright (C) Jonas Schievink <jonasschievink@gmail.com>
-
-Permission to use, copy, modify, and/or distribute this software for
-any purpose with or without fee is hereby granted.
-
-THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
-WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
-MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
-ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
-WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
-AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
-OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
diff --git a/third_party/rust/chromium_crates_io/vendor/adler-1.0.2/LICENSE-APACHE b/third_party/rust/chromium_crates_io/vendor/adler-1.0.2/LICENSE-APACHE
deleted file mode 100644
index c98d27d4f32d56..00000000000000
--- a/third_party/rust/chromium_crates_io/vendor/adler-1.0.2/LICENSE-APACHE
+++ /dev/null
@@ -1,201 +0,0 @@
-                              Apache License
-                        Version 2.0, January 2004
-                     https://www.apache.org/licenses/LICENSE-2.0
-
-TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
-
-1. Definitions.
-
-   "License" shall mean the terms and conditions for use, reproduction,
-   and distribution as defined by Sections 1 through 9 of this document.
-
-   "Licensor" shall mean the copyright owner or entity authorized by
-   the copyright owner that is granting the License.
-
-   "Legal Entity" shall mean the union of the acting entity and all
-   other entities that control, are controlled by, or are under common
-   control with that entity. For the purposes of this definition,
-   "control" means (i) the power, direct or indirect, to cause the
-   direction or management of such entity, whether by contract or
-   otherwise, or (ii) ownership of fifty percent (50%) or more of the
-   outstanding shares, or (iii) beneficial ownership of such entity.
-
-   "You" (or "Your") shall mean an individual or Legal Entity
-   exercising permissions granted by this License.
-
-   "Source" form shall mean the preferred form for making modifications,
-   including but not limited to software source code, documentation
-   source, and configuration files.
-
-   "Object" form shall mean any form resulting from mechanical
-   transformation or translation of a Source form, including but
-   not limited to compiled object code, generated documentation,
-   and conversions to other media types.
-
-   "Work" shall mean the work of authorship, whether in Source or
-   Object form, made available under the License, as indicated by a
-   copyright notice that is included in or attached to the work
-   (an example is provided in the Appendix below).
-
-   "Derivative Works" shall mean any work, whether in Source or Object
-   form, that is based on (or derived from) the Work and for which the
-   editorial revisions, annotations, elaborations, or other modifications
-   represent, as a whole, an original work of authorship. For the purposes
-   of this License, Derivative Works shall not include works that remain
-   separable from, or merely link (or bind by name) to the interfaces of,
-   the Work and Derivative Works thereof.
-
-   "Contribution" shall mean any work of authorship, including
-   the original version of the Work and any modifications or additions
-   to that Work or Derivative Works thereof, that is intentionally
-   submitted to Licensor for inclusion in the Work by the copyright owner
-   or by an individual or Legal Entity authorized to submit on behalf of
-   the copyright owner. For the purposes of this definition, "submitted"
-   means any form of electronic, verbal, or written communication sent
-   to the Licensor or its representatives, including but not limited to
-   communication on electronic mailing lists, source code control systems,
-   and issue tracking systems that are managed by, or on behalf of, the
-   Licensor for the purpose of discussing and improving the Work, but
-   excluding communication that is conspicuously marked or otherwise
-   designated in writing by the copyright owner as "Not a Contribution."
-
-   "Contributor" shall mean Licensor and any individual or Legal Entity
-   on behalf of whom a Contribution has been received by Licensor and
-   subsequently incorporated within the Work.
-
-2. Grant of Copyright License. Subject to the terms and conditions of
-   this License, each Contributor hereby grants to You a perpetual,
-   worldwide, non-exclusive, no-charge, royalty-free, irrevocable
-   copyright license to reproduce, prepare Derivative Works of,
-   publicly display, publicly perform, sublicense, and distribute the
-   Work and such Derivative Works in Source or Object form.
-
-3. Grant of Patent License. Subject to the terms and conditions of
-   this License, each Contributor hereby grants to You a perpetual,
-   worldwide, non-exclusive, no-charge, royalty-free, irrevocable
-   (except as stated in this section) patent license to make, have made,
-   use, offer to sell, sell, import, and otherwise transfer the Work,
-   where such license applies only to those patent claims licensable
-   by such Contributor that are necessarily infringed by their
-   Contribution(s) alone or by combination of their Contribution(s)
-   with the Work to which such Contribution(s) was submitted. If You
-   institute patent litigation against any entity (including a
-   cross-claim or counterclaim in a lawsuit) alleging that the Work
-   or a Contribution incorporated within the Work constitutes direct
-   or contributory patent infringement, then any patent licenses
-   granted to You under this License for that Work shall terminate
-   as of the date such litigation is filed.
-
-4. Redistribution. You may reproduce and distribute copies of the
-   Work or Derivative Works thereof in any medium, with or without
-   modifications, and in Source or Object form, provided that You
-   meet the following conditions:
-
-   (a) You must give any other recipients of the Work or
-       Derivative Works a copy of this License; and
-
-   (b) You must cause any modified files to carry prominent notices
-       stating that You changed the files; and
-
-   (c) You must retain, in the Source form of any Derivative Works
-       that You distribute, all copyright, patent, trademark, and
-       attribution notices from the Source form of the Work,
-       excluding those notices that do not pertain to any part of
-       the Derivative Works; and
-
-   (d) If the Work includes a "NOTICE" text file as part of its
-       distribution, then any Derivative Works that You distribute must
-       include a readable copy of the attribution notices contained
-       within such NOTICE file, excluding those notices that do not
-       pertain to any part of the Derivative Works, in at least one
-       of the following places: within a NOTICE text file distributed
-       as part of the Derivative Works; within the Source form or
-       documentation, if provided along with the Derivative Works; or,
-       within a display generated by the Derivative Works, if and
-       wherever such third-party notices normally appear. The contents
-       of the NOTICE file are for informational purposes only and
-       do not modify the License. You may add Your own attribution
-       notices within Derivative Works that You distribute, alongside
-       or as an addendum to the NOTICE text from the Work, provided
-       that such additional attribution notices cannot be construed
-       as modifying the License.
-
-   You may add Your own copyright statement to Your modifications and
-   may provide additional or different license terms and conditions
-   for use, reproduction, or distribution of Your modifications, or
-   for any such Derivative Works as a whole, provided Your use,
-   reproduction, and distribution of the Work otherwise complies with
-   the conditions stated in this License.
-
-5. Submission of Contributions. Unless You explicitly state otherwise,
-   any Contribution intentionally submitted for inclusion in the Work
-   by You to the Licensor shall be under the terms and conditions of
-   this License, without any additional terms or conditions.
-   Notwithstanding the above, nothing herein shall supersede or modify
-   the terms of any separate license agreement you may have executed
-   with Licensor regarding such Contributions.
-
-6. Trademarks. This License does not grant permission to use the trade
-   names, trademarks, service marks, or product names of the Licensor,
-   except as required for reasonable and customary use in describing the
-   origin of the Work and reproducing the content of the NOTICE file.
-
-7. Disclaimer of Warranty. Unless required by applicable law or
-   agreed to in writing, Licensor provides the Work (and each
-   Contributor provides its Contributions) on an "AS IS" BASIS,
-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
-   implied, including, without limitation, any warranties or conditions
-   of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
-   PARTICULAR PURPOSE. You are solely responsible for determining the
-   appropriateness of using or redistributing the Work and assume any
-   risks associated with Your exercise of permissions under this License.
-
-8. Limitation of Liability. In no event and under no legal theory,
-   whether in tort (including negligence), contract, or otherwise,
-   unless required by applicable law (such as deliberate and grossly
-   negligent acts) or agreed to in writing, shall any Contributor be
-   liable to You for damages, including any direct, indirect, special,
-   incidental, or consequential damages of any character arising as a
-   result of this License or out of the use or inability to use the
-   Work (including but not limited to damages for loss of goodwill,
-   work stoppage, computer failure or malfunction, or any and all
-   other commercial damages or losses), even if such Contributor
-   has been advised of the possibility of such damages.
-
-9. Accepting Warranty or Additional Liability. While redistributing
-   the Work or Derivative Works thereof, You may choose to offer,
-   and charge a fee for, acceptance of support, warranty, indemnity,
-   or other liability obligations and/or rights consistent with this
-   License. However, in accepting such obligations, You may act only
-   on Your own behalf and on Your sole responsibility, not on behalf
-   of any other Contributor, and only if You agree to indemnify,
-   defend, and hold each Contributor harmless for any liability
-   incurred by, or claims asserted against, such Contributor by reason
-   of your accepting any such warranty or additional liability.
-
-END OF TERMS AND CONDITIONS
-
-APPENDIX: How to apply the Apache License to your work.
-
-   To apply the Apache License to your work, attach the following
-   boilerplate notice, with the fields enclosed by brackets "[]"
-   replaced with your own identifying information. (Don't include
-   the brackets!)  The text should be enclosed in the appropriate
-   comment syntax for the file format. We also recommend that a
-   file or class name and description of purpose be included on the
-   same "printed page" as the copyright notice for easier
-   identification within third-party archives.
-
-Copyright [yyyy] [name of copyright owner]
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-	https://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
diff --git a/third_party/rust/chromium_crates_io/vendor/adler-1.0.2/LICENSE-MIT b/third_party/rust/chromium_crates_io/vendor/adler-1.0.2/LICENSE-MIT
deleted file mode 100644
index 31aa79387f27e7..00000000000000
--- a/third_party/rust/chromium_crates_io/vendor/adler-1.0.2/LICENSE-MIT
+++ /dev/null
@@ -1,23 +0,0 @@
-Permission is hereby granted, free of charge, to any
-person obtaining a copy of this software and associated
-documentation files (the "Software"), to deal in the
-Software without restriction, including without
-limitation the rights to use, copy, modify, merge,
-publish, distribute, sublicense, and/or sell copies of
-the Software, and to permit persons to whom the Software
-is furnished to do so, subject to the following
-conditions:
-
-The above copyright notice and this permission notice
-shall be included in all copies or substantial portions
-of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF
-ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
-TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
-PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT
-SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
-OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
-IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-DEALINGS IN THE SOFTWARE.
diff --git a/third_party/rust/chromium_crates_io/vendor/adler-1.0.2/README.md b/third_party/rust/chromium_crates_io/vendor/adler-1.0.2/README.md
deleted file mode 100644
index ba140d52a3928a..00000000000000
--- a/third_party/rust/chromium_crates_io/vendor/adler-1.0.2/README.md
+++ /dev/null
@@ -1,39 +0,0 @@
-# Adler-32 checksums for Rust
-
-[![crates.io](https://img.shields.io/crates/v/adler.svg)](https://crates.io/crates/adler)
-[![docs.rs](https://docs.rs/adler/badge.svg)](https://docs.rs/adler/)
-![CI](https://github.com/jonas-schievink/adler/workflows/CI/badge.svg)
-
-This crate provides a simple implementation of the Adler-32 checksum, used in
-the zlib compression format.
-
-Please refer to the [changelog](CHANGELOG.md) to see what changed in the last
-releases.
-
-## Features
-
-- Permissively licensed (0BSD) clean-room implementation.
-- Zero dependencies.
-- Zero `unsafe`.
-- Decent performance (3-4 GB/s).
-- Supports `#![no_std]` (with `default-features = false`).
-
-## Usage
-
-Add an entry to your `Cargo.toml`:
-
-```toml
-[dependencies]
-adler = "1.0.2"
-```
-
-Check the [API Documentation](https://docs.rs/adler/) for how to use the
-crate's functionality.
-
-## Rust version support
-
-Currently, this crate supports all Rust versions starting at Rust 1.31.0.
-
-Bumping the Minimum Supported Rust Version (MSRV) is *not* considered a breaking
-change, but will not be done without good reasons. The latest 3 stable Rust
-versions will always be supported no matter what.
diff --git a/third_party/rust/chromium_crates_io/vendor/adler-1.0.2/RELEASE_PROCESS.md b/third_party/rust/chromium_crates_io/vendor/adler-1.0.2/RELEASE_PROCESS.md
deleted file mode 100644
index 71a36734159e8a..00000000000000
--- a/third_party/rust/chromium_crates_io/vendor/adler-1.0.2/RELEASE_PROCESS.md
+++ /dev/null
@@ -1,13 +0,0 @@
-# What to do to publish a new release
-
-1. Ensure all notable changes are in the changelog under "Unreleased".
-
-2. Execute `cargo release <level>` to bump version(s), tag and publish
-   everything. External subcommand, must be installed with `cargo install
-   cargo-release`.
-   
-   `<level>` can be one of `major|minor|patch`. If this is the first release
-   (`0.1.0`), use `minor`, since the version starts out as `0.0.0`.
-
-3. Go to the GitHub releases, edit the just-pushed tag. Copy the release notes
-   from the changelog.
diff --git a/third_party/rust/chromium_crates_io/vendor/adler-1.0.2/benches/bench.rs b/third_party/rust/chromium_crates_io/vendor/adler-1.0.2/benches/bench.rs
deleted file mode 100644
index 0969f59483ef9f..00000000000000
--- a/third_party/rust/chromium_crates_io/vendor/adler-1.0.2/benches/bench.rs
+++ /dev/null
@@ -1,109 +0,0 @@
-extern crate adler;
-extern crate criterion;
-
-use adler::{adler32_slice, Adler32};
-use criterion::{criterion_group, criterion_main, Criterion, Throughput};
-
-fn simple(c: &mut Criterion) {
-    {
-        const SIZE: usize = 100;
-
-        let mut group = c.benchmark_group("simple-100b");
-        group.throughput(Throughput::Bytes(SIZE as u64));
-        group.bench_function("zeroes-100", |bencher| {
-            bencher.iter(|| {
-                adler32_slice(&[0; SIZE]);
-            });
-        });
-        group.bench_function("ones-100", |bencher| {
-            bencher.iter(|| {
-                adler32_slice(&[0xff; SIZE]);
-            });
-        });
-    }
-
-    {
-        const SIZE: usize = 1024;
-
-        let mut group = c.benchmark_group("simple-1k");
-        group.throughput(Throughput::Bytes(SIZE as u64));
-
-        group.bench_function("zeroes-1k", |bencher| {
-            bencher.iter(|| {
-                adler32_slice(&[0; SIZE]);
-            });
-        });
-
-        group.bench_function("ones-1k", |bencher| {
-            bencher.iter(|| {
-                adler32_slice(&[0xff; SIZE]);
-            });
-        });
-    }
-
-    {
-        const SIZE: usize = 1024 * 1024;
-
-        let mut group = c.benchmark_group("simple-1m");
-        group.throughput(Throughput::Bytes(SIZE as u64));
-        group.bench_function("zeroes-1m", |bencher| {
-            bencher.iter(|| {
-                adler32_slice(&[0; SIZE]);
-            });
-        });
-
-        group.bench_function("ones-1m", |bencher| {
-            bencher.iter(|| {
-                adler32_slice(&[0xff; SIZE]);
-            });
-        });
-    }
-}
-
-fn chunked(c: &mut Criterion) {
-    const SIZE: usize = 16 * 1024 * 1024;
-
-    let data = vec![0xAB; SIZE];
-
-    let mut group = c.benchmark_group("chunked-16m");
-    group.throughput(Throughput::Bytes(SIZE as u64));
-    group.bench_function("5552", |bencher| {
-        bencher.iter(|| {
-            let mut h = Adler32::new();
-            for chunk in data.chunks(5552) {
-                h.write_slice(chunk);
-            }
-            h.checksum()
-        });
-    });
-    group.bench_function("8k", |bencher| {
-        bencher.iter(|| {
-            let mut h = Adler32::new();
-            for chunk in data.chunks(8 * 1024) {
-                h.write_slice(chunk);
-            }
-            h.checksum()
-        });
-    });
-    group.bench_function("64k", |bencher| {
-        bencher.iter(|| {
-            let mut h = Adler32::new();
-            for chunk in data.chunks(64 * 1024) {
-                h.write_slice(chunk);
-            }
-            h.checksum()
-        });
-    });
-    group.bench_function("1m", |bencher| {
-        bencher.iter(|| {
-            let mut h = Adler32::new();
-            for chunk in data.chunks(1024 * 1024) {
-                h.write_slice(chunk);
-            }
-            h.checksum()
-        });
-    });
-}
-
-criterion_group!(benches, simple, chunked);
-criterion_main!(benches);
diff --git a/third_party/rust/chromium_crates_io/vendor/adler-1.0.2/src/algo.rs b/third_party/rust/chromium_crates_io/vendor/adler-1.0.2/src/algo.rs
deleted file mode 100644
index 650cffa6cdd40a..00000000000000
--- a/third_party/rust/chromium_crates_io/vendor/adler-1.0.2/src/algo.rs
+++ /dev/null
@@ -1,146 +0,0 @@
-use crate::Adler32;
-use std::ops::{AddAssign, MulAssign, RemAssign};
-
-impl Adler32 {
-    pub(crate) fn compute(&mut self, bytes: &[u8]) {
-        // The basic algorithm is, for every byte:
-        //   a = (a + byte) % MOD
-        //   b = (b + a) % MOD
-        // where MOD = 65521.
-        //
-        // For efficiency, we can defer the `% MOD` operations as long as neither a nor b overflows:
-        // - Between calls to `write`, we ensure that a and b are always in range 0..MOD.
-        // - We use 32-bit arithmetic in this function.
-        // - Therefore, a and b must not increase by more than 2^32-MOD without performing a `% MOD`
-        //   operation.
-        //
-        // According to Wikipedia, b is calculated as follows for non-incremental checksumming:
-        //   b = n√óD1 + (n‚àí1)√óD2 + (n‚àí2)√óD3 + ... + Dn + n*1 (mod 65521)
-        // Where n is the number of bytes and Di is the i-th Byte. We need to change this to account
-        // for the previous values of a and b, as well as treat every input Byte as being 255:
-        //   b_inc = n√ó255 + (n-1)√ó255 + ... + 255 + n*65520
-        // Or in other words:
-        //   b_inc = n*65520 + n(n+1)/2*255
-        // The max chunk size is thus the largest value of n so that b_inc <= 2^32-65521.
-        //   2^32-65521 = n*65520 + n(n+1)/2*255
-        // Plugging this into an equation solver since I can't math gives n = 5552.18..., so 5552.
-        //
-        // On top of the optimization outlined above, the algorithm can also be parallelized with a
-        // bit more work:
-        //
-        // Note that b is a linear combination of a vector of input bytes (D1, ..., Dn).
-        //
-        // If we fix some value k<N and rewrite indices 1, ..., N as
-        //
-        //   1_1, 1_2, ..., 1_k, 2_1, ..., 2_k, ..., (N/k)_k,
-        //
-        // then we can express a and b in terms of sums of smaller sequences kb and ka:
-        //
-        //   ka(j) := D1_j + D2_j + ... + D(N/k)_j where j <= k
-        //   kb(j) := (N/k)*D1_j + (N/k-1)*D2_j + ... + D(N/k)_j where j <= k
-        //
-        //  a = ka(1) + ka(2) + ... + ka(k) + 1
-        //  b = k*(kb(1) + kb(2) + ... + kb(k)) - 1*ka(2) - ...  - (k-1)*ka(k) + N
-        //
-        // We use this insight to unroll the main loop and process k=4 bytes at a time.
-        // The resulting code is highly amenable to SIMD acceleration, although the immediate speedups
-        // stem from increased pipeline parallelism rather than auto-vectorization.
-        //
-        // This technique is described in-depth (here:)[https://software.intel.com/content/www/us/\
-        // en/develop/articles/fast-computation-of-fletcher-checksums.html]
-
-        const MOD: u32 = 65521;
-        const CHUNK_SIZE: usize = 5552 * 4;
-
-        let mut a = u32::from(self.a);
-        let mut b = u32::from(self.b);
-        let mut a_vec = U32X4([0; 4]);
-        let mut b_vec = a_vec;
-
-        let (bytes, remainder) = bytes.split_at(bytes.len() - bytes.len() % 4);
-
-        // iterate over 4 bytes at a time
-        let chunk_iter = bytes.chunks_exact(CHUNK_SIZE);
-        let remainder_chunk = chunk_iter.remainder();
-        for chunk in chunk_iter {
-            for byte_vec in chunk.chunks_exact(4) {
-                let val = U32X4::from(byte_vec);
-                a_vec += val;
-                b_vec += a_vec;
-            }
-            b += CHUNK_SIZE as u32 * a;
-            a_vec %= MOD;
-            b_vec %= MOD;
-            b %= MOD;
-        }
-        // special-case the final chunk because it may be shorter than the rest
-        for byte_vec in remainder_chunk.chunks_exact(4) {
-            let val = U32X4::from(byte_vec);
-            a_vec += val;
-            b_vec += a_vec;
-        }
-        b += remainder_chunk.len() as u32 * a;
-        a_vec %= MOD;
-        b_vec %= MOD;
-        b %= MOD;
-
-        // combine the sub-sum results into the main sum
-        b_vec *= 4;
-        b_vec.0[1] += MOD - a_vec.0[1];
-        b_vec.0[2] += (MOD - a_vec.0[2]) * 2;
-        b_vec.0[3] += (MOD - a_vec.0[3]) * 3;
-        for &av in a_vec.0.iter() {
-            a += av;
-        }
-        for &bv in b_vec.0.iter() {
-            b += bv;
-        }
-
-        // iterate over the remaining few bytes in serial
-        for &byte in remainder.iter() {
-            a += u32::from(byte);
-            b += a;
-        }
-
-        self.a = (a % MOD) as u16;
-        self.b = (b % MOD) as u16;
-    }
-}
-
-#[derive(Copy, Clone)]
-struct U32X4([u32; 4]);
-
-impl U32X4 {
-    fn from(bytes: &[u8]) -> Self {
-        U32X4([
-            u32::from(bytes[0]),
-            u32::from(bytes[1]),
-            u32::from(bytes[2]),
-            u32::from(bytes[3]),
-        ])
-    }
-}
-
-impl AddAssign<Self> for U32X4 {
-    fn add_assign(&mut self, other: Self) {
-        for (s, o) in self.0.iter_mut().zip(other.0.iter()) {
-            *s += o;
-        }
-    }
-}
-
-impl RemAssign<u32> for U32X4 {
-    fn rem_assign(&mut self, quotient: u32) {
-        for s in self.0.iter_mut() {
-            *s %= quotient;
-        }
-    }
-}
-
-impl MulAssign<u32> for U32X4 {
-    fn mul_assign(&mut self, rhs: u32) {
-        for s in self.0.iter_mut() {
-            *s *= rhs;
-        }
-    }
-}
diff --git a/third_party/rust/chromium_crates_io/vendor/adler-1.0.2/src/lib.rs b/third_party/rust/chromium_crates_io/vendor/adler-1.0.2/src/lib.rs
deleted file mode 100644
index c7aa3805ec8fbb..00000000000000
--- a/third_party/rust/chromium_crates_io/vendor/adler-1.0.2/src/lib.rs
+++ /dev/null
@@ -1,287 +0,0 @@
-//! Adler-32 checksum implementation.
-//!
-//! This implementation features:
-//!
-//! - Permissively licensed (0BSD) clean-room implementation.
-//! - Zero dependencies.
-//! - Zero `unsafe`.
-//! - Decent performance (3-4 GB/s).
-//! - `#![no_std]` support (with `default-features = false`).
-
-#![doc(html_root_url = "https://docs.rs/adler/1.0.2")]
-// Deny a few warnings in doctests, since rustdoc `allow`s many warnings by default
-#![doc(test(attr(deny(unused_imports, unused_must_use))))]
-#![cfg_attr(docsrs, feature(doc_cfg))]
-#![warn(missing_debug_implementations)]
-#![forbid(unsafe_code)]
-#![cfg_attr(not(feature = "std"), no_std)]
-
-#[cfg(not(feature = "std"))]
-extern crate core as std;
-
-mod algo;
-
-use std::hash::Hasher;
-
-#[cfg(feature = "std")]
-use std::io::{self, BufRead};
-
-/// Adler-32 checksum calculator.
-///
-/// An instance of this type is equivalent to an Adler-32 checksum: It can be created in the default
-/// state via [`new`] (or the provided `Default` impl), or from a precalculated checksum via
-/// [`from_checksum`], and the currently stored checksum can be fetched via [`checksum`].
-///
-/// This type also implements `Hasher`, which makes it easy to calculate Adler-32 checksums of any
-/// type that implements or derives `Hash`. This also allows using Adler-32 in a `HashMap`, although
-/// that is not recommended (while every checksum is a hash function, they are not necessarily a
-/// good one).
-///
-/// # Examples
-///
-/// Basic, piecewise checksum calculation:
-///
-/// ```
-/// use adler::Adler32;
-///
-/// let mut adler = Adler32::new();
-///
-/// adler.write_slice(&[0, 1, 2]);
-/// adler.write_slice(&[3, 4, 5]);
-///
-/// assert_eq!(adler.checksum(), 0x00290010);
-/// ```
-///
-/// Using `Hash` to process structures:
-///
-/// ```
-/// use std::hash::Hash;
-/// use adler::Adler32;
-///
-/// #[derive(Hash)]
-/// struct Data {
-///     byte: u8,
-///     word: u16,
-///     big: u64,
-/// }
-///
-/// let mut adler = Adler32::new();
-///
-/// let data = Data { byte: 0x1F, word: 0xABCD, big: !0 };
-/// data.hash(&mut adler);
-///
-/// // hash value depends on architecture endianness
-/// if cfg!(target_endian = "little") {
-///     assert_eq!(adler.checksum(), 0x33410990);
-/// }
-/// if cfg!(target_endian = "big") {
-///     assert_eq!(adler.checksum(), 0x331F0990);
-/// }
-///
-/// ```
-///
-/// [`new`]: #method.new
-/// [`from_checksum`]: #method.from_checksum
-/// [`checksum`]: #method.checksum
-#[derive(Debug, Copy, Clone)]
-pub struct Adler32 {
-    a: u16,
-    b: u16,
-}
-
-impl Adler32 {
-    /// Creates a new Adler-32 instance with default state.
-    #[inline]
-    pub fn new() -> Self {
-        Self::default()
-    }
-
-    /// Creates an `Adler32` instance from a precomputed Adler-32 checksum.
-    ///
-    /// This allows resuming checksum calculation without having to keep the `Adler32` instance
-    /// around.
-    ///
-    /// # Example
-    ///
-    /// ```
-    /// # use adler::Adler32;
-    /// let parts = [
-    ///     "rust",
-    ///     "acean",
-    /// ];
-    /// let whole = adler::adler32_slice(b"rustacean");
-    ///
-    /// let mut sum = Adler32::new();
-    /// sum.write_slice(parts[0].as_bytes());
-    /// let partial = sum.checksum();
-    ///
-    /// // ...later
-    ///
-    /// let mut sum = Adler32::from_checksum(partial);
-    /// sum.write_slice(parts[1].as_bytes());
-    /// assert_eq!(sum.checksum(), whole);
-    /// ```
-    #[inline]
-    pub fn from_checksum(sum: u32) -> Self {
-        Adler32 {
-            a: sum as u16,
-            b: (sum >> 16) as u16,
-        }
-    }
-
-    /// Returns the calculated checksum at this point in time.
-    #[inline]
-    pub fn checksum(&self) -> u32 {
-        (u32::from(self.b) << 16) | u32::from(self.a)
-    }
-
-    /// Adds `bytes` to the checksum calculation.
-    ///
-    /// If efficiency matters, this should be called with Byte slices that contain at least a few
-    /// thousand Bytes.
-    pub fn write_slice(&mut self, bytes: &[u8]) {
-        self.compute(bytes);
-    }
-}
-
-impl Default for Adler32 {
-    #[inline]
-    fn default() -> Self {
-        Adler32 { a: 1, b: 0 }
-    }
-}
-
-impl Hasher for Adler32 {
-    #[inline]
-    fn finish(&self) -> u64 {
-        u64::from(self.checksum())
-    }
-
-    fn write(&mut self, bytes: &[u8]) {
-        self.write_slice(bytes);
-    }
-}
-
-/// Calculates the Adler-32 checksum of a byte slice.
-///
-/// This is a convenience function around the [`Adler32`] type.
-///
-/// [`Adler32`]: struct.Adler32.html
-pub fn adler32_slice(data: &[u8]) -> u32 {
-    let mut h = Adler32::new();
-    h.write_slice(data);
-    h.checksum()
-}
-
-/// Calculates the Adler-32 checksum of a `BufRead`'s contents.
-///
-/// The passed `BufRead` implementor will be read until it reaches EOF (or until it reports an
-/// error).
-///
-/// If you only have a `Read` implementor, you can wrap it in `std::io::BufReader` before calling
-/// this function.
-///
-/// # Errors
-///
-/// Any error returned by the reader are bubbled up by this function.
-///
-/// # Examples
-///
-/// ```no_run
-/// # fn run() -> Result<(), Box<dyn std::error::Error>> {
-/// use adler::adler32;
-///
-/// use std::fs::File;
-/// use std::io::BufReader;
-///
-/// let file = File::open("input.txt")?;
-/// let mut file = BufReader::new(file);
-///
-/// adler32(&mut file)?;
-/// # Ok(()) }
-/// # fn main() { run().unwrap() }
-/// ```
-#[cfg(feature = "std")]
-#[cfg_attr(docsrs, doc(cfg(feature = "std")))]
-pub fn adler32<R: BufRead>(mut reader: R) -> io::Result<u32> {
-    let mut h = Adler32::new();
-    loop {
-        let len = {
-            let buf = reader.fill_buf()?;
-            if buf.is_empty() {
-                return Ok(h.checksum());
-            }
-
-            h.write_slice(buf);
-            buf.len()
-        };
-        reader.consume(len);
-    }
-}
-
-#[cfg(test)]
-mod tests {
-    use super::*;
-
-    #[test]
-    fn zeroes() {
-        assert_eq!(adler32_slice(&[]), 1);
-        assert_eq!(adler32_slice(&[0]), 1 | 1 << 16);
-        assert_eq!(adler32_slice(&[0, 0]), 1 | 2 << 16);
-        assert_eq!(adler32_slice(&[0; 100]), 0x00640001);
-        assert_eq!(adler32_slice(&[0; 1024]), 0x04000001);
-        assert_eq!(adler32_slice(&[0; 1024 * 1024]), 0x00f00001);
-    }
-
-    #[test]
-    fn ones() {
-        assert_eq!(adler32_slice(&[0xff; 1024]), 0x79a6fc2e);
-        assert_eq!(adler32_slice(&[0xff; 1024 * 1024]), 0x8e88ef11);
-    }
-
-    #[test]
-    fn mixed() {
-        assert_eq!(adler32_slice(&[1]), 2 | 2 << 16);
-        assert_eq!(adler32_slice(&[40]), 41 | 41 << 16);
-
-        assert_eq!(adler32_slice(&[0xA5; 1024 * 1024]), 0xd5009ab1);
-    }
-
-    /// Example calculation from https://en.wikipedia.org/wiki/Adler-32.
-    #[test]
-    fn wiki() {
-        assert_eq!(adler32_slice(b"Wikipedia"), 0x11E60398);
-    }
-
-    #[test]
-    fn resume() {
-        let mut adler = Adler32::new();
-        adler.write_slice(&[0xff; 1024]);
-        let partial = adler.checksum();
-        assert_eq!(partial, 0x79a6fc2e); // from above
-        adler.write_slice(&[0xff; 1024 * 1024 - 1024]);
-        assert_eq!(adler.checksum(), 0x8e88ef11); // from above
-
-        // Make sure that we can resume computing from the partial checksum via `from_checksum`.
-        let mut adler = Adler32::from_checksum(partial);
-        adler.write_slice(&[0xff; 1024 * 1024 - 1024]);
-        assert_eq!(adler.checksum(), 0x8e88ef11); // from above
-    }
-
-    #[cfg(feature = "std")]
-    #[test]
-    fn bufread() {
-        use std::io::BufReader;
-        fn test(data: &[u8], checksum: u32) {
-            // `BufReader` uses an 8 KB buffer, so this will test buffer refilling.
-            let mut buf = BufReader::new(data);
-            let real_sum = adler32(&mut buf).unwrap();
-            assert_eq!(checksum, real_sum);
-        }
-
-        test(&[], 1);
-        test(&[0; 1024], 0x04000001);
-        test(&[0; 1024 * 1024], 0x00f00001);
-        test(&[0xA5; 1024 * 1024], 0xd5009ab1);
-    }
-}
diff --git a/third_party/rust/chromium_crates_io/vendor/miniz_oxide-0.7.4/.cargo-checksum.json b/third_party/rust/chromium_crates_io/vendor/miniz_oxide-0.7.4/.cargo-checksum.json
deleted file mode 100644
index 697c9ce2fbb400..00000000000000
--- a/third_party/rust/chromium_crates_io/vendor/miniz_oxide-0.7.4/.cargo-checksum.json
+++ /dev/null
@@ -1 +0,0 @@
-{"files":{}}
diff --git a/third_party/rust/chromium_crates_io/vendor/miniz_oxide-0.7.4/.cargo_vcs_info.json b/third_party/rust/chromium_crates_io/vendor/miniz_oxide-0.7.4/.cargo_vcs_info.json
deleted file mode 100644
index cfebb5129c6b04..00000000000000
--- a/third_party/rust/chromium_crates_io/vendor/miniz_oxide-0.7.4/.cargo_vcs_info.json
+++ /dev/null
@@ -1,6 +0,0 @@
-{
-  "git": {
-    "sha1": "084c21bcaa0a788f330b15af5abc1bd33bce13a6"
-  },
-  "path_in_vcs": "miniz_oxide"
-}
\ No newline at end of file
diff --git a/third_party/rust/chromium_crates_io/vendor/miniz_oxide-0.7.4/Cargo.toml b/third_party/rust/chromium_crates_io/vendor/miniz_oxide-0.7.4/Cargo.toml
deleted file mode 100644
index 6b51683bff0069..00000000000000
--- a/third_party/rust/chromium_crates_io/vendor/miniz_oxide-0.7.4/Cargo.toml
+++ /dev/null
@@ -1,74 +0,0 @@
-# THIS FILE IS AUTOMATICALLY GENERATED BY CARGO
-#
-# When uploading crates to the registry Cargo will automatically
-# "normalize" Cargo.toml files for maximal compatibility
-# with all versions of Cargo and also rewrite `path` dependencies
-# to registry (e.g., crates.io) dependencies.
-#
-# If you are reading this file be aware that the original Cargo.toml
-# will likely look very different (and much more reasonable).
-# See Cargo.toml.orig for the original contents.
-
-[package]
-edition = "2018"
-name = "miniz_oxide"
-version = "0.7.4"
-authors = [
-    "Frommi <daniil.liferenko@gmail.com>",
-    "oyvindln <oyvindln@users.noreply.github.com>",
-]
-exclude = [
-    "benches/*",
-    "tests/*",
-]
-description = "DEFLATE compression and decompression library rewritten in Rust based on miniz"
-homepage = "https://github.com/Frommi/miniz_oxide/tree/master/miniz_oxide"
-documentation = "https://docs.rs/miniz_oxide"
-readme = "Readme.md"
-keywords = [
-    "zlib",
-    "miniz",
-    "deflate",
-    "encoding",
-]
-categories = ["compression"]
-license = "MIT OR Zlib OR Apache-2.0"
-repository = "https://github.com/Frommi/miniz_oxide/tree/master/miniz_oxide"
-
-[lib]
-name = "miniz_oxide"
-
-[dependencies.adler]
-version = "1.0"
-default-features = false
-
-[dependencies.alloc]
-version = "1.0.0"
-optional = true
-package = "rustc-std-workspace-alloc"
-
-[dependencies.compiler_builtins]
-version = "0.1.2"
-optional = true
-
-[dependencies.core]
-version = "1.0.0"
-optional = true
-package = "rustc-std-workspace-core"
-
-[dependencies.simd-adler32]
-version = "0.3.3"
-optional = true
-default-features = false
-
-[features]
-default = ["with-alloc"]
-rustc-dep-of-std = [
-    "core",
-    "alloc",
-    "compiler_builtins",
-    "adler/rustc-dep-of-std",
-]
-simd = ["simd-adler32"]
-std = []
-with-alloc = []
diff --git a/third_party/rust/chromium_crates_io/vendor/miniz_oxide-0.7.4/Cargo.toml.orig b/third_party/rust/chromium_crates_io/vendor/miniz_oxide-0.7.4/Cargo.toml.orig
deleted file mode 100644
index 8a42c1dbebe703..00000000000000
--- a/third_party/rust/chromium_crates_io/vendor/miniz_oxide-0.7.4/Cargo.toml.orig
+++ /dev/null
@@ -1,38 +0,0 @@
-[package]
-name = "miniz_oxide"
-authors = ["Frommi <daniil.liferenko@gmail.com>", "oyvindln <oyvindln@users.noreply.github.com>"]
-version = "0.7.4"
-license = "MIT OR Zlib OR Apache-2.0"
-readme = "Readme.md"
-keywords = ["zlib", "miniz", "deflate", "encoding"]
-categories = ["compression"]
-repository = "https://github.com/Frommi/miniz_oxide/tree/master/miniz_oxide"
-homepage = "https://github.com/Frommi/miniz_oxide/tree/master/miniz_oxide"
-documentation = "https://docs.rs/miniz_oxide"
-description = "DEFLATE compression and decompression library rewritten in Rust based on miniz"
-edition = "2018"
-exclude = ["benches/*", "tests/*"]
-
-[lib]
-name = "miniz_oxide"
-
-[dependencies]
-adler = { version = "1.0", default-features = false }
-simd-adler32 = { version = "0.3.3", default-features = false, optional = true }
-
-# Internal feature, only used when building as part of libstd, not part of the
-# stable interface of this crate.
-core = { version = '1.0.0', optional = true, package = 'rustc-std-workspace-core' }
-alloc = { version = '1.0.0', optional = true, package = 'rustc-std-workspace-alloc' }
-compiler_builtins = { version = '0.1.2', optional = true }
-
-[features]
-default = ["with-alloc"]
-with-alloc = []
-std = []
-
-# Internal feature, only used when building as part of libstd, not part of the
-# stable interface of this crate.
-rustc-dep-of-std = ['core', 'alloc', 'compiler_builtins', 'adler/rustc-dep-of-std']
-
-simd = ['simd-adler32']
diff --git a/third_party/rust/chromium_crates_io/vendor/miniz_oxide-0.7.4/LICENSE b/third_party/rust/chromium_crates_io/vendor/miniz_oxide-0.7.4/LICENSE
deleted file mode 100644
index 64c53792ced0ff..00000000000000
--- a/third_party/rust/chromium_crates_io/vendor/miniz_oxide-0.7.4/LICENSE
+++ /dev/null
@@ -1,21 +0,0 @@
-MIT License
-
-Copyright (c) 2017 Frommi
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in all
-copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-SOFTWARE.
diff --git a/third_party/rust/chromium_crates_io/vendor/miniz_oxide-0.7.4/LICENSE-APACHE.md b/third_party/rust/chromium_crates_io/vendor/miniz_oxide-0.7.4/LICENSE-APACHE.md
deleted file mode 100644
index f433b1a53f5b83..00000000000000
--- a/third_party/rust/chromium_crates_io/vendor/miniz_oxide-0.7.4/LICENSE-APACHE.md
+++ /dev/null
@@ -1,177 +0,0 @@
-
-                                 Apache License
-                           Version 2.0, January 2004
-                        http://www.apache.org/licenses/
-
-   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
-
-   1. Definitions.
-
-      "License" shall mean the terms and conditions for use, reproduction,
-      and distribution as defined by Sections 1 through 9 of this document.
-
-      "Licensor" shall mean the copyright owner or entity authorized by
-      the copyright owner that is granting the License.
-
-      "Legal Entity" shall mean the union of the acting entity and all
-      other entities that control, are controlled by, or are under common
-      control with that entity. For the purposes of this definition,
-      "control" means (i) the power, direct or indirect, to cause the
-      direction or management of such entity, whether by contract or
-      otherwise, or (ii) ownership of fifty percent (50%) or more of the
-      outstanding shares, or (iii) beneficial ownership of such entity.
-
-      "You" (or "Your") shall mean an individual or Legal Entity
-      exercising permissions granted by this License.
-
-      "Source" form shall mean the preferred form for making modifications,
-      including but not limited to software source code, documentation
-      source, and configuration files.
-
-      "Object" form shall mean any form resulting from mechanical
-      transformation or translation of a Source form, including but
-      not limited to compiled object code, generated documentation,
-      and conversions to other media types.
-
-      "Work" shall mean the work of authorship, whether in Source or
-      Object form, made available under the License, as indicated by a
-      copyright notice that is included in or attached to the work
-      (an example is provided in the Appendix below).
-
-      "Derivative Works" shall mean any work, whether in Source or Object
-      form, that is based on (or derived from) the Work and for which the
-      editorial revisions, annotations, elaborations, or other modifications
-      represent, as a whole, an original work of authorship. For the purposes
-      of this License, Derivative Works shall not include works that remain
-      separable from, or merely link (or bind by name) to the interfaces of,
-      the Work and Derivative Works thereof.
-
-      "Contribution" shall mean any work of authorship, including
-      the original version of the Work and any modifications or additions
-      to that Work or Derivative Works thereof, that is intentionally
-      submitted to Licensor for inclusion in the Work by the copyright owner
-      or by an individual or Legal Entity authorized to submit on behalf of
-      the copyright owner. For the purposes of this definition, "submitted"
-      means any form of electronic, verbal, or written communication sent
-      to the Licensor or its representatives, including but not limited to
-      communication on electronic mailing lists, source code control systems,
-      and issue tracking systems that are managed by, or on behalf of, the
-      Licensor for the purpose of discussing and improving the Work, but
-      excluding communication that is conspicuously marked or otherwise
-      designated in writing by the copyright owner as "Not a Contribution."
-
-      "Contributor" shall mean Licensor and any individual or Legal Entity
-      on behalf of whom a Contribution has been received by Licensor and
-      subsequently incorporated within the Work.
-
-   2. Grant of Copyright License. Subject to the terms and conditions of
-      this License, each Contributor hereby grants to You a perpetual,
-      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
-      copyright license to reproduce, prepare Derivative Works of,
-      publicly display, publicly perform, sublicense, and distribute the
-      Work and such Derivative Works in Source or Object form.
-
-   3. Grant of Patent License. Subject to the terms and conditions of
-      this License, each Contributor hereby grants to You a perpetual,
-      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
-      (except as stated in this section) patent license to make, have made,
-      use, offer to sell, sell, import, and otherwise transfer the Work,
-      where such license applies only to those patent claims licensable
-      by such Contributor that are necessarily infringed by their
-      Contribution(s) alone or by combination of their Contribution(s)
-      with the Work to which such Contribution(s) was submitted. If You
-      institute patent litigation against any entity (including a
-      cross-claim or counterclaim in a lawsuit) alleging that the Work
-      or a Contribution incorporated within the Work constitutes direct
-      or contributory patent infringement, then any patent licenses
-      granted to You under this License for that Work shall terminate
-      as of the date such litigation is filed.
-
-   4. Redistribution. You may reproduce and distribute copies of the
-      Work or Derivative Works thereof in any medium, with or without
-      modifications, and in Source or Object form, provided that You
-      meet the following conditions:
-
-      (a) You must give any other recipients of the Work or
-          Derivative Works a copy of this License; and
-
-      (b) You must cause any modified files to carry prominent notices
-          stating that You changed the files; and
-
-      (c) You must retain, in the Source form of any Derivative Works
-          that You distribute, all copyright, patent, trademark, and
-          attribution notices from the Source form of the Work,
-          excluding those notices that do not pertain to any part of
-          the Derivative Works; and
-
-      (d) If the Work includes a "NOTICE" text file as part of its
-          distribution, then any Derivative Works that You distribute must
-          include a readable copy of the attribution notices contained
-          within such NOTICE file, excluding those notices that do not
-          pertain to any part of the Derivative Works, in at least one
-          of the following places: within a NOTICE text file distributed
-          as part of the Derivative Works; within the Source form or
-          documentation, if provided along with the Derivative Works; or,
-          within a display generated by the Derivative Works, if and
-          wherever such third-party notices normally appear. The contents
-          of the NOTICE file are for informational purposes only and
-          do not modify the License. You may add Your own attribution
-          notices within Derivative Works that You distribute, alongside
-          or as an addendum to the NOTICE text from the Work, provided
-          that such additional attribution notices cannot be construed
-          as modifying the License.
-
-      You may add Your own copyright statement to Your modifications and
-      may provide additional or different license terms and conditions
-      for use, reproduction, or distribution of Your modifications, or
-      for any such Derivative Works as a whole, provided Your use,
-      reproduction, and distribution of the Work otherwise complies with
-      the conditions stated in this License.
-
-   5. Submission of Contributions. Unless You explicitly state otherwise,
-      any Contribution intentionally submitted for inclusion in the Work
-      by You to the Licensor shall be under the terms and conditions of
-      this License, without any additional terms or conditions.
-      Notwithstanding the above, nothing herein shall supersede or modify
-      the terms of any separate license agreement you may have executed
-      with Licensor regarding such Contributions.
-
-   6. Trademarks. This License does not grant permission to use the trade
-      names, trademarks, service marks, or product names of the Licensor,
-      except as required for reasonable and customary use in describing the
-      origin of the Work and reproducing the content of the NOTICE file.
-
-   7. Disclaimer of Warranty. Unless required by applicable law or
-      agreed to in writing, Licensor provides the Work (and each
-      Contributor provides its Contributions) on an "AS IS" BASIS,
-      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
-      implied, including, without limitation, any warranties or conditions
-      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
-      PARTICULAR PURPOSE. You are solely responsible for determining the
-      appropriateness of using or redistributing the Work and assume any
-      risks associated with Your exercise of permissions under this License.
-
-   8. Limitation of Liability. In no event and under no legal theory,
-      whether in tort (including negligence), contract, or otherwise,
-      unless required by applicable law (such as deliberate and grossly
-      negligent acts) or agreed to in writing, shall any Contributor be
-      liable to You for damages, including any direct, indirect, special,
-      incidental, or consequential damages of any character arising as a
-      result of this License or out of the use or inability to use the
-      Work (including but not limited to damages for loss of goodwill,
-      work stoppage, computer failure or malfunction, or any and all
-      other commercial damages or losses), even if such Contributor
-      has been advised of the possibility of such damages.
-
-   9. Accepting Warranty or Additional Liability. While redistributing
-      the Work or Derivative Works thereof, You may choose to offer,
-      and charge a fee for, acceptance of support, warranty, indemnity,
-      or other liability obligations and/or rights consistent with this
-      License. However, in accepting such obligations, You may act only
-      on Your own behalf and on Your sole responsibility, not on behalf
-      of any other Contributor, and only if You agree to indemnify,
-      defend, and hold each Contributor harmless for any liability
-      incurred by, or claims asserted against, such Contributor by reason
-      of your accepting any such warranty or additional liability.
-
-   END OF TERMS AND CONDITIONS
diff --git a/third_party/rust/chromium_crates_io/vendor/miniz_oxide-0.7.4/LICENSE-MIT.md b/third_party/rust/chromium_crates_io/vendor/miniz_oxide-0.7.4/LICENSE-MIT.md
deleted file mode 100644
index 64c53792ced0ff..00000000000000
--- a/third_party/rust/chromium_crates_io/vendor/miniz_oxide-0.7.4/LICENSE-MIT.md
+++ /dev/null
@@ -1,21 +0,0 @@
-MIT License
-
-Copyright (c) 2017 Frommi
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in all
-copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-SOFTWARE.
diff --git a/third_party/rust/chromium_crates_io/vendor/miniz_oxide-0.7.4/LICENSE-ZLIB.md b/third_party/rust/chromium_crates_io/vendor/miniz_oxide-0.7.4/LICENSE-ZLIB.md
deleted file mode 100644
index 7f513d1acbab95..00000000000000
--- a/third_party/rust/chromium_crates_io/vendor/miniz_oxide-0.7.4/LICENSE-ZLIB.md
+++ /dev/null
@@ -1,11 +0,0 @@
-Copyright (c) 2020 Frommi
-
-This software is provided 'as-is', without any express or implied warranty. In no event will the authors be held liable for any damages arising from the use of this software.
-
-Permission is granted to anyone to use this software for any purpose, including commercial applications, and to alter it and redistribute it freely, subject to the following restrictions:
-
-1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
-
-2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
-
-3. This notice may not be removed or altered from any source distribution.
diff --git a/third_party/rust/chromium_crates_io/vendor/miniz_oxide-0.7.4/Readme.md b/third_party/rust/chromium_crates_io/vendor/miniz_oxide-0.7.4/Readme.md
deleted file mode 100644
index 6c177b0e1a9c44..00000000000000
--- a/third_party/rust/chromium_crates_io/vendor/miniz_oxide-0.7.4/Readme.md
+++ /dev/null
@@ -1,44 +0,0 @@
-# miniz_oxide
-
-A fully safe, pure rust replacement for the [miniz](https://github.com/richgel999/miniz) DEFLATE/zlib encoder/decoder.
-The main intention of this crate is to be used as a back-end for the [flate2](https://github.com/alexcrichton/flate2-rs), but it can also be used on its own. Using flate2 with the ```rust_backend``` feature provides an easy to use streaming API for miniz_oxide.
-
-The library is fully [no_std](https://docs.rust-embedded.org/book/intro/no-std.html). By default, the `with-alloc` feature is enabled, which requires the use of the `alloc` and `collection` crates as it allocates memory.
-
-The `std` feature additionally turns on things only available if `no_std` is not used. Currently this only means implementing [Error](https://doc.rust-lang.org/stable/std/error/trait.Error.html) for the `DecompressError` error struct returned by the simple decompression functions if enabled together with `with-alloc`.
-
-Using the library with `default-features = false` removes the dependency on `alloc`
-and `collection` crates, making it suitable for systems without an allocator.
-Running without allocation reduces crate functionality:
-
-- The `deflate` module is removed completely
-- Some `inflate` functions which return a `Vec` are removed
-
-miniz_oxide 0.5.x and 0.6.x Requires at least rust 1.40.0 0.3.x requires at least rust 0.36.0.
-
-miniz_oxide features no use of unsafe code.
-
-miniz_oxide can optionally be made to use a simd-accelerated version of adler32 via the [simd-adler32](https://crates.io/crates/simd-adler32) crate by enabling the 'simd' feature. This is not enabled by default as due to the use of simd intrinsics, the simd-adler32 has to use unsafe. The default setup uses the [adler](https://crates.io/crates/adler) crate which features no unsafe code.
-
-## Usage
-Simple compression/decompression:
-```rust
-
-use miniz_oxide::deflate::compress_to_vec;
-use miniz_oxide::inflate::decompress_to_vec;
-
-fn roundtrip(data: &[u8]) {
-    // Compress the input
-    let compressed = compress_to_vec(data, 6);
-    // Decompress the compressed input and limit max output size to avoid going out of memory on large/malformed input.
-    let decompressed = decompress_to_vec_with_limit(compressed.as_slice(), 60000).expect("Failed to decompress!");
-    // Check roundtrip succeeded
-    assert_eq!(data, decompressed);
-}
-
-fn main() {
-    roundtrip("Hello, world!".as_bytes());
-}
-
-```
-These simple functions will do everything in one go and are thus not recommended for use cases outside of prototyping/testing as real world data can have any size and thus result in very large memory allocations for the output Vector. Consider using miniz_oxide via [flate2](https://github.com/alexcrichton/flate2-rs) which makes it easy to do streaming (de)compression or the low-level streaming functions instead.
diff --git a/third_party/rust/chromium_crates_io/vendor/miniz_oxide-0.7.4/src/deflate/buffer.rs b/third_party/rust/chromium_crates_io/vendor/miniz_oxide-0.7.4/src/deflate/buffer.rs
deleted file mode 100644
index f246c07dfbeffd..00000000000000
--- a/third_party/rust/chromium_crates_io/vendor/miniz_oxide-0.7.4/src/deflate/buffer.rs
+++ /dev/null
@@ -1,58 +0,0 @@
-//! Buffer wrappers implementing default so we can allocate the buffers with `Box::default()`
-//! to avoid stack copies. Box::new() doesn't at the moment, and using a vec means we would lose
-//! static length info.
-
-use crate::deflate::core::{LZ_DICT_SIZE, MAX_MATCH_LEN};
-
-/// Size of the buffer of lz77 encoded data.
-pub const LZ_CODE_BUF_SIZE: usize = 64 * 1024;
-/// Size of the output buffer.
-pub const OUT_BUF_SIZE: usize = (LZ_CODE_BUF_SIZE * 13) / 10;
-pub const LZ_DICT_FULL_SIZE: usize = LZ_DICT_SIZE + MAX_MATCH_LEN - 1 + 1;
-
-/// Size of hash values in the hash chains.
-pub const LZ_HASH_BITS: i32 = 15;
-/// How many bits to shift when updating the current hash value.
-pub const LZ_HASH_SHIFT: i32 = (LZ_HASH_BITS + 2) / 3;
-/// Size of the chained hash tables.
-pub const LZ_HASH_SIZE: usize = 1 << LZ_HASH_BITS;
-
-#[inline]
-pub fn update_hash(current_hash: u16, byte: u8) -> u16 {
-    ((current_hash << LZ_HASH_SHIFT) ^ u16::from(byte)) & (LZ_HASH_SIZE as u16 - 1)
-}
-
-pub struct HashBuffers {
-    pub dict: [u8; LZ_DICT_FULL_SIZE],
-    pub next: [u16; LZ_DICT_SIZE],
-    pub hash: [u16; LZ_DICT_SIZE],
-}
-
-impl HashBuffers {
-    #[inline]
-    pub fn reset(&mut self) {
-        *self = HashBuffers::default();
-    }
-}
-
-impl Default for HashBuffers {
-    fn default() -> HashBuffers {
-        HashBuffers {
-            dict: [0; LZ_DICT_FULL_SIZE],
-            next: [0; LZ_DICT_SIZE],
-            hash: [0; LZ_DICT_SIZE],
-        }
-    }
-}
-
-pub struct LocalBuf {
-    pub b: [u8; OUT_BUF_SIZE],
-}
-
-impl Default for LocalBuf {
-    fn default() -> LocalBuf {
-        LocalBuf {
-            b: [0; OUT_BUF_SIZE],
-        }
-    }
-}
diff --git a/third_party/rust/chromium_crates_io/vendor/miniz_oxide-0.7.4/src/deflate/core.rs b/third_party/rust/chromium_crates_io/vendor/miniz_oxide-0.7.4/src/deflate/core.rs
deleted file mode 100644
index 111e596b25126b..00000000000000
--- a/third_party/rust/chromium_crates_io/vendor/miniz_oxide-0.7.4/src/deflate/core.rs
+++ /dev/null
@@ -1,2469 +0,0 @@
-//! Streaming compression functionality.
-
-use alloc::boxed::Box;
-use core::convert::TryInto;
-use core::{cmp, mem};
-
-use super::super::*;
-use super::deflate_flags::*;
-use super::CompressionLevel;
-use crate::deflate::buffer::{
-    update_hash, HashBuffers, LocalBuf, LZ_CODE_BUF_SIZE, LZ_DICT_FULL_SIZE, LZ_HASH_BITS,
-    LZ_HASH_SHIFT, LZ_HASH_SIZE, OUT_BUF_SIZE,
-};
-use crate::shared::{update_adler32, HUFFMAN_LENGTH_ORDER, MZ_ADLER32_INIT};
-use crate::DataFormat;
-
-// Currently not bubbled up outside this module, so can fill in with more
-// context eventually if needed.
-type Result<T, E = Error> = core::result::Result<T, E>;
-struct Error {}
-
-const MAX_PROBES_MASK: i32 = 0xFFF;
-
-const MAX_SUPPORTED_HUFF_CODESIZE: usize = 32;
-
-/// Length code for length values.
-#[rustfmt::skip]
-const LEN_SYM: [u16; 256] = [
-    257, 258, 259, 260, 261, 262, 263, 264, 265, 265, 266, 266, 267, 267, 268, 268,
-    269, 269, 269, 269, 270, 270, 270, 270, 271, 271, 271, 271, 272, 272, 272, 272,
-    273, 273, 273, 273, 273, 273, 273, 273, 274, 274, 274, 274, 274, 274, 274, 274,
-    275, 275, 275, 275, 275, 275, 275, 275, 276, 276, 276, 276, 276, 276, 276, 276,
-    277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277,
-    278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278,
-    279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279,
-    280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280,
-    281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281,
-    281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281,
-    282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282,
-    282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282,
-    283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283,
-    283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283,
-    284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284,
-    284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 285
-];
-
-/// Number of extra bits for length values.
-#[rustfmt::skip]
-const LEN_EXTRA: [u8; 256] = [
-    0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
-    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
-    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
-    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
-    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
-    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
-    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
-    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
-    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
-    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
-    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
-    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
-    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
-    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
-    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
-    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0
-];
-
-/// Distance codes for distances smaller than 512.
-#[rustfmt::skip]
-const SMALL_DIST_SYM: [u8; 512] = [
-     0,  1,  2,  3,  4,  4,  5,  5,  6,  6,  6,  6,  7,  7,  7,  7,
-     8,  8,  8,  8,  8,  8,  8,  8,  9,  9,  9,  9,  9,  9,  9,  9,
-    10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
-    11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
-    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
-    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
-    13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
-    13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
-    14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
-    14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
-    14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
-    14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
-    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
-    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
-    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
-    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
-    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
-    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
-    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
-    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
-    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
-    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
-    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
-    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
-    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
-    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
-    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
-    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
-    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
-    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
-    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
-    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17
-];
-
-/// Number of extra bits for distances smaller than 512.
-#[rustfmt::skip]
-const SMALL_DIST_EXTRA: [u8; 512] = [
-    0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
-    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
-    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
-    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
-    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
-    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
-    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
-    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
-    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
-    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
-    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
-    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
-    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
-    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
-    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
-    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7
-];
-
-/// Base values to calculate distances above 512.
-#[rustfmt::skip]
-const LARGE_DIST_SYM: [u8; 128] = [
-     0,  0, 18, 19, 20, 20, 21, 21, 22, 22, 22, 22, 23, 23, 23, 23,
-    24, 24, 24, 24, 24, 24, 24, 24, 25, 25, 25, 25, 25, 25, 25, 25,
-    26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
-    27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
-    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
-    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
-    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
-    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29
-];
-
-/// Number of extra bits distances above 512.
-#[rustfmt::skip]
-const LARGE_DIST_EXTRA: [u8; 128] = [
-     0,  0,  8,  8,  9,  9,  9,  9, 10, 10, 10, 10, 10, 10, 10, 10,
-    11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
-    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
-    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
-    13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
-    13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
-    13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
-    13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13
-];
-
-#[rustfmt::skip]
-const BITMASKS: [u32; 17] = [
-    0x0000, 0x0001, 0x0003, 0x0007, 0x000F, 0x001F, 0x003F, 0x007F, 0x00FF,
-    0x01FF, 0x03FF, 0x07FF, 0x0FFF, 0x1FFF, 0x3FFF, 0x7FFF, 0xFFFF
-];
-
-/// The maximum number of checks for matches in the hash table the compressor will make for each
-/// compression level.
-const NUM_PROBES: [u32; 11] = [0, 1, 6, 32, 16, 32, 128, 256, 512, 768, 1500];
-
-#[derive(Copy, Clone)]
-struct SymFreq {
-    key: u16,
-    sym_index: u16,
-}
-
-pub mod deflate_flags {
-    /// Whether to use a zlib wrapper.
-    pub const TDEFL_WRITE_ZLIB_HEADER: u32 = 0x0000_1000;
-    /// Should we compute the adler32 checksum.
-    pub const TDEFL_COMPUTE_ADLER32: u32 = 0x0000_2000;
-    /// Should we use greedy parsing (as opposed to lazy parsing where look ahead one or more
-    /// bytes to check for better matches.)
-    pub const TDEFL_GREEDY_PARSING_FLAG: u32 = 0x0000_4000;
-    /// Used in miniz to skip zero-initializing hash and dict. We don't do this here, so
-    /// this flag is ignored.
-    pub const TDEFL_NONDETERMINISTIC_PARSING_FLAG: u32 = 0x0000_8000;
-    /// Only look for matches with a distance of 0.
-    pub const TDEFL_RLE_MATCHES: u32 = 0x0001_0000;
-    /// Only use matches that are at least 6 bytes long.
-    pub const TDEFL_FILTER_MATCHES: u32 = 0x0002_0000;
-    /// Force the compressor to only output static blocks. (Blocks using the default huffman codes
-    /// specified in the deflate specification.)
-    pub const TDEFL_FORCE_ALL_STATIC_BLOCKS: u32 = 0x0004_0000;
-    /// Force the compressor to only output raw/uncompressed blocks.
-    pub const TDEFL_FORCE_ALL_RAW_BLOCKS: u32 = 0x0008_0000;
-}
-
-/// Strategy setting for compression.
-///
-/// The non-default settings offer some special-case compression variants.
-#[repr(i32)]
-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
-pub enum CompressionStrategy {
-    /// Don't use any of the special strategies.
-    Default = 0,
-    /// Only use matches that are at least 5 bytes long.
-    Filtered = 1,
-    /// Don't look for matches, only huffman encode the literals.
-    HuffmanOnly = 2,
-    /// Only look for matches with a distance of 1, i.e do run-length encoding only.
-    RLE = 3,
-    /// Only use static/fixed blocks. (Blocks using the default huffman codes
-    /// specified in the deflate specification.)
-    Fixed = 4,
-}
-
-/// A list of deflate flush types.
-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
-pub enum TDEFLFlush {
-    /// Normal operation.
-    ///
-    /// Compress as much as there is space for, and then return waiting for more input.
-    None = 0,
-
-    /// Try to flush all the current data and output an empty raw block.
-    Sync = 2,
-
-    /// Same as [`Sync`][Self::Sync], but reset the dictionary so that the following data does not
-    /// depend on previous data.
-    Full = 3,
-
-    /// Try to flush everything and end the deflate stream.
-    ///
-    /// On success this will yield a [`TDEFLStatus::Done`] return status.
-    Finish = 4,
-}
-
-impl From<MZFlush> for TDEFLFlush {
-    fn from(flush: MZFlush) -> Self {
-        match flush {
-            MZFlush::None => TDEFLFlush::None,
-            MZFlush::Sync => TDEFLFlush::Sync,
-            MZFlush::Full => TDEFLFlush::Full,
-            MZFlush::Finish => TDEFLFlush::Finish,
-            _ => TDEFLFlush::None, // TODO: ??? What to do ???
-        }
-    }
-}
-
-impl TDEFLFlush {
-    pub fn new(flush: i32) -> Result<Self, MZError> {
-        match flush {
-            0 => Ok(TDEFLFlush::None),
-            2 => Ok(TDEFLFlush::Sync),
-            3 => Ok(TDEFLFlush::Full),
-            4 => Ok(TDEFLFlush::Finish),
-            _ => Err(MZError::Param),
-        }
-    }
-}
-
-/// Return status of compression.
-#[repr(i32)]
-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
-pub enum TDEFLStatus {
-    /// Usage error.
-    ///
-    /// This indicates that either the [`CompressorOxide`] experienced a previous error, or the
-    /// stream has already been [`TDEFLFlush::Finish`]'d.
-    BadParam = -2,
-
-    /// Error putting data into output buffer.
-    ///
-    /// This usually indicates a too-small buffer.
-    PutBufFailed = -1,
-
-    /// Compression succeeded normally.
-    Okay = 0,
-
-    /// Compression succeeded and the deflate stream was ended.
-    ///
-    /// This is the result of calling compression with [`TDEFLFlush::Finish`].
-    Done = 1,
-}
-
-const MAX_HUFF_SYMBOLS: usize = 288;
-/// Size of hash chain for fast compression mode.
-const LEVEL1_HASH_SIZE_MASK: u32 = 4095;
-/// The number of huffman tables used by the compressor.
-/// Literal/length, Distances and Length of the huffman codes for the other two tables.
-const MAX_HUFF_TABLES: usize = 3;
-/// Literal/length codes
-const MAX_HUFF_SYMBOLS_0: usize = 288;
-/// Distance codes.
-const MAX_HUFF_SYMBOLS_1: usize = 32;
-/// Huffman length values.
-const MAX_HUFF_SYMBOLS_2: usize = 19;
-/// Size of the chained hash table.
-pub(crate) const LZ_DICT_SIZE: usize = 32_768;
-/// Mask used when stepping through the hash chains.
-const LZ_DICT_SIZE_MASK: usize = (LZ_DICT_SIZE as u32 - 1) as usize;
-/// The minimum length of a match.
-const MIN_MATCH_LEN: u8 = 3;
-/// The maximum length of a match.
-pub(crate) const MAX_MATCH_LEN: usize = 258;
-
-const DEFAULT_FLAGS: u32 = NUM_PROBES[4] | TDEFL_WRITE_ZLIB_HEADER;
-
-mod zlib {
-    const DEFAULT_CM: u8 = 8;
-    const DEFAULT_CINFO: u8 = 7 << 4;
-    const _DEFAULT_FDICT: u8 = 0;
-    const DEFAULT_CMF: u8 = DEFAULT_CM | DEFAULT_CINFO;
-    /// The 16-bit value consisting of CMF and FLG must be divisible by this to be valid.
-    const FCHECK_DIVISOR: u8 = 31;
-
-    /// Generate FCHECK from CMF and FLG (without FCKECH )so that they are correct according to the
-    /// specification, i.e (CMF*256 + FCHK) % 31 = 0.
-    /// Returns flg with the FCHKECK bits added (any existing FCHECK bits are ignored).
-    fn add_fcheck(cmf: u8, flg: u8) -> u8 {
-        let rem = ((usize::from(cmf) * 256) + usize::from(flg)) % usize::from(FCHECK_DIVISOR);
-
-        // Clear existing FCHECK if any
-        let flg = flg & 0b11100000;
-
-        // Casting is safe as rem can't overflow since it is a value mod 31
-        // We can simply add the value to flg as (31 - rem) will never be above 2^5
-        flg + (FCHECK_DIVISOR - rem as u8)
-    }
-
-    fn zlib_level_from_flags(flags: u32) -> u8 {
-        use super::NUM_PROBES;
-
-        let num_probes = flags & (super::MAX_PROBES_MASK as u32);
-        if flags & super::TDEFL_GREEDY_PARSING_FLAG != 0 {
-            if num_probes <= 1 {
-                0
-            } else {
-                1
-            }
-        } else if num_probes >= NUM_PROBES[9] {
-            3
-        } else {
-            2
-        }
-    }
-
-    /// Get the zlib header for the level using the default window size and no
-    /// dictionary.
-    fn header_from_level(level: u8) -> [u8; 2] {
-        let cmf = DEFAULT_CMF;
-        [cmf, add_fcheck(cmf, level << 6)]
-    }
-
-    /// Create a zlib header from the given compression flags.
-    /// Only level is considered.
-    pub fn header_from_flags(flags: u32) -> [u8; 2] {
-        let level = zlib_level_from_flags(flags);
-        header_from_level(level)
-    }
-
-    #[cfg(test)]
-    mod test {
-        #[test]
-        fn zlib() {
-            use super::super::*;
-            use super::*;
-
-            let test_level = |level, expected| {
-                let flags = create_comp_flags_from_zip_params(
-                    level,
-                    MZ_DEFAULT_WINDOW_BITS,
-                    CompressionStrategy::Default as i32,
-                );
-                assert_eq!(zlib_level_from_flags(flags), expected);
-            };
-
-            assert_eq!(zlib_level_from_flags(DEFAULT_FLAGS), 2);
-            test_level(0, 0);
-            test_level(1, 0);
-            test_level(2, 1);
-            test_level(3, 1);
-            for i in 4..=8 {
-                test_level(i, 2)
-            }
-            test_level(9, 3);
-            test_level(10, 3);
-        }
-
-        #[test]
-        fn test_header() {
-            let header = super::header_from_level(3);
-            assert_eq!(
-                ((usize::from(header[0]) * 256) + usize::from(header[1])) % 31,
-                0
-            );
-        }
-    }
-}
-
-fn memset<T: Copy>(slice: &mut [T], val: T) {
-    for x in slice {
-        *x = val
-    }
-}
-
-#[cfg(test)]
-#[inline]
-fn write_u16_le(val: u16, slice: &mut [u8], pos: usize) {
-    slice[pos] = val as u8;
-    slice[pos + 1] = (val >> 8) as u8;
-}
-
-// Read the two bytes starting at pos and interpret them as an u16.
-#[inline]
-const fn read_u16_le(slice: &[u8], pos: usize) -> u16 {
-    // The compiler is smart enough to optimize this into an unaligned load.
-    slice[pos] as u16 | ((slice[pos + 1] as u16) << 8)
-}
-
-/// Main compression struct.
-pub struct CompressorOxide {
-    lz: LZOxide,
-    params: ParamsOxide,
-    /// Put HuffmanOxide on the heap with default trick to avoid
-    /// excessive stack copies.
-    huff: Box<HuffmanOxide>,
-    dict: DictOxide,
-}
-
-impl CompressorOxide {
-    /// Create a new `CompressorOxide` with the given flags.
-    ///
-    /// # Notes
-    /// This function may be changed to take different parameters in the future.
-    pub fn new(flags: u32) -> Self {
-        CompressorOxide {
-            lz: LZOxide::new(),
-            params: ParamsOxide::new(flags),
-            huff: Box::default(),
-            dict: DictOxide::new(flags),
-        }
-    }
-
-    /// Get the adler32 checksum of the currently encoded data.
-    pub const fn adler32(&self) -> u32 {
-        self.params.adler32
-    }
-
-    /// Get the return status of the previous [`compress`](fn.compress.html)
-    /// call with this compressor.
-    pub const fn prev_return_status(&self) -> TDEFLStatus {
-        self.params.prev_return_status
-    }
-
-    /// Get the raw compressor flags.
-    ///
-    /// # Notes
-    /// This function may be deprecated or changed in the future to use more rust-style flags.
-    pub const fn flags(&self) -> i32 {
-        self.params.flags as i32
-    }
-
-    /// Returns whether the compressor is wrapping the data in a zlib format or not.
-    pub fn data_format(&self) -> DataFormat {
-        if (self.params.flags & TDEFL_WRITE_ZLIB_HEADER) != 0 {
-            DataFormat::Zlib
-        } else {
-            DataFormat::Raw
-        }
-    }
-
-    /// Reset the state of the compressor, keeping the same parameters.
-    ///
-    /// This avoids re-allocating data.
-    pub fn reset(&mut self) {
-        // LZ buf and huffman has no settings or dynamic memory
-        // that needs to be saved, so we simply replace them.
-        self.lz = LZOxide::new();
-        self.params.reset();
-        *self.huff = HuffmanOxide::default();
-        self.dict.reset();
-    }
-
-    /// Set the compression level of the compressor.
-    ///
-    /// Using this to change level after compression has started is supported.
-    /// # Notes
-    /// The compression strategy will be reset to the default one when this is called.
-    pub fn set_compression_level(&mut self, level: CompressionLevel) {
-        let format = self.data_format();
-        self.set_format_and_level(format, level as u8);
-    }
-
-    /// Set the compression level of the compressor using an integer value.
-    ///
-    /// Using this to change level after compression has started is supported.
-    /// # Notes
-    /// The compression strategy will be reset to the default one when this is called.
-    pub fn set_compression_level_raw(&mut self, level: u8) {
-        let format = self.data_format();
-        self.set_format_and_level(format, level);
-    }
-
-    /// Update the compression settings of the compressor.
-    ///
-    /// Changing the `DataFormat` after compression has started will result in
-    /// a corrupted stream.
-    ///
-    /// # Notes
-    /// This function mainly intended for setting the initial settings after e.g creating with
-    /// `default` or after calling `CompressorOxide::reset()`, and behaviour may be changed
-    /// to disallow calling it after starting compression in the future.
-    pub fn set_format_and_level(&mut self, data_format: DataFormat, level: u8) {
-        let flags = create_comp_flags_from_zip_params(
-            level.into(),
-            data_format.to_window_bits(),
-            CompressionStrategy::Default as i32,
-        );
-        self.params.update_flags(flags);
-        self.dict.update_flags(flags);
-    }
-}
-
-impl Default for CompressorOxide {
-    /// Initialize the compressor with a level of 4, zlib wrapper and
-    /// the default strategy.
-    fn default() -> Self {
-        CompressorOxide {
-            lz: LZOxide::new(),
-            params: ParamsOxide::new(DEFAULT_FLAGS),
-            huff: Box::default(),
-            dict: DictOxide::new(DEFAULT_FLAGS),
-        }
-    }
-}
-
-/// Callback function and user used in `compress_to_output`.
-pub struct CallbackFunc<'a> {
-    pub put_buf_func: &'a mut dyn FnMut(&[u8]) -> bool,
-}
-
-impl<'a> CallbackFunc<'a> {
-    fn flush_output(
-        &mut self,
-        saved_output: SavedOutputBufferOxide,
-        params: &mut ParamsOxide,
-    ) -> i32 {
-        // TODO: As this could be unsafe since
-        // we can't verify the function pointer
-        // this whole function should maybe be unsafe as well.
-        let call_success = (self.put_buf_func)(&params.local_buf.b[0..saved_output.pos]);
-
-        if !call_success {
-            params.prev_return_status = TDEFLStatus::PutBufFailed;
-            return params.prev_return_status as i32;
-        }
-
-        params.flush_remaining as i32
-    }
-}
-
-struct CallbackBuf<'a> {
-    pub out_buf: &'a mut [u8],
-}
-
-impl<'a> CallbackBuf<'a> {
-    fn flush_output(
-        &mut self,
-        saved_output: SavedOutputBufferOxide,
-        params: &mut ParamsOxide,
-    ) -> i32 {
-        if saved_output.local {
-            let n = cmp::min(saved_output.pos, self.out_buf.len() - params.out_buf_ofs);
-            (self.out_buf[params.out_buf_ofs..params.out_buf_ofs + n])
-                .copy_from_slice(&params.local_buf.b[..n]);
-
-            params.out_buf_ofs += n;
-            if saved_output.pos != n {
-                params.flush_ofs = n as u32;
-                params.flush_remaining = (saved_output.pos - n) as u32;
-            }
-        } else {
-            params.out_buf_ofs += saved_output.pos;
-        }
-
-        params.flush_remaining as i32
-    }
-}
-
-enum CallbackOut<'a> {
-    Func(CallbackFunc<'a>),
-    Buf(CallbackBuf<'a>),
-}
-
-impl<'a> CallbackOut<'a> {
-    fn new_output_buffer<'b>(
-        &'b mut self,
-        local_buf: &'b mut [u8],
-        out_buf_ofs: usize,
-    ) -> OutputBufferOxide<'b> {
-        let is_local;
-        let buf_len = OUT_BUF_SIZE - 16;
-        let chosen_buffer = match *self {
-            CallbackOut::Buf(ref mut cb) if cb.out_buf.len() - out_buf_ofs >= OUT_BUF_SIZE => {
-                is_local = false;
-                &mut cb.out_buf[out_buf_ofs..out_buf_ofs + buf_len]
-            }
-            _ => {
-                is_local = true;
-                &mut local_buf[..buf_len]
-            }
-        };
-
-        OutputBufferOxide {
-            inner: chosen_buffer,
-            inner_pos: 0,
-            local: is_local,
-            bit_buffer: 0,
-            bits_in: 0,
-        }
-    }
-}
-
-struct CallbackOxide<'a> {
-    in_buf: Option<&'a [u8]>,
-    in_buf_size: Option<&'a mut usize>,
-    out_buf_size: Option<&'a mut usize>,
-    out: CallbackOut<'a>,
-}
-
-impl<'a> CallbackOxide<'a> {
-    fn new_callback_buf(in_buf: &'a [u8], out_buf: &'a mut [u8]) -> Self {
-        CallbackOxide {
-            in_buf: Some(in_buf),
-            in_buf_size: None,
-            out_buf_size: None,
-            out: CallbackOut::Buf(CallbackBuf { out_buf }),
-        }
-    }
-
-    fn new_callback_func(in_buf: &'a [u8], callback_func: CallbackFunc<'a>) -> Self {
-        CallbackOxide {
-            in_buf: Some(in_buf),
-            in_buf_size: None,
-            out_buf_size: None,
-            out: CallbackOut::Func(callback_func),
-        }
-    }
-
-    fn update_size(&mut self, in_size: Option<usize>, out_size: Option<usize>) {
-        if let (Some(in_size), Some(size)) = (in_size, self.in_buf_size.as_mut()) {
-            **size = in_size;
-        }
-
-        if let (Some(out_size), Some(size)) = (out_size, self.out_buf_size.as_mut()) {
-            **size = out_size
-        }
-    }
-
-    fn flush_output(
-        &mut self,
-        saved_output: SavedOutputBufferOxide,
-        params: &mut ParamsOxide,
-    ) -> i32 {
-        if saved_output.pos == 0 {
-            return params.flush_remaining as i32;
-        }
-
-        self.update_size(Some(params.src_pos), None);
-        match self.out {
-            CallbackOut::Func(ref mut cf) => cf.flush_output(saved_output, params),
-            CallbackOut::Buf(ref mut cb) => cb.flush_output(saved_output, params),
-        }
-    }
-}
-
-struct OutputBufferOxide<'a> {
-    pub inner: &'a mut [u8],
-    pub inner_pos: usize,
-    pub local: bool,
-
-    pub bit_buffer: u32,
-    pub bits_in: u32,
-}
-
-impl<'a> OutputBufferOxide<'a> {
-    fn put_bits(&mut self, bits: u32, len: u32) {
-        // TODO: Removing this assertion worsens performance
-        // Need to figure out why
-        assert!(bits <= ((1u32 << len) - 1u32));
-        self.bit_buffer |= bits << self.bits_in;
-        self.bits_in += len;
-
-        while self.bits_in >= 8 {
-            self.inner[self.inner_pos] = self.bit_buffer as u8;
-            self.inner_pos += 1;
-            self.bit_buffer >>= 8;
-            self.bits_in -= 8;
-        }
-    }
-
-    const fn save(&self) -> SavedOutputBufferOxide {
-        SavedOutputBufferOxide {
-            pos: self.inner_pos,
-            bit_buffer: self.bit_buffer,
-            bits_in: self.bits_in,
-            local: self.local,
-        }
-    }
-
-    fn load(&mut self, saved: SavedOutputBufferOxide) {
-        self.inner_pos = saved.pos;
-        self.bit_buffer = saved.bit_buffer;
-        self.bits_in = saved.bits_in;
-        self.local = saved.local;
-    }
-
-    fn pad_to_bytes(&mut self) {
-        if self.bits_in != 0 {
-            let len = 8 - self.bits_in;
-            self.put_bits(0, len);
-        }
-    }
-}
-
-struct SavedOutputBufferOxide {
-    pub pos: usize,
-    pub bit_buffer: u32,
-    pub bits_in: u32,
-    pub local: bool,
-}
-
-struct BitBuffer {
-    pub bit_buffer: u64,
-    pub bits_in: u32,
-}
-
-impl BitBuffer {
-    fn put_fast(&mut self, bits: u64, len: u32) {
-        self.bit_buffer |= bits << self.bits_in;
-        self.bits_in += len;
-    }
-
-    fn flush(&mut self, output: &mut OutputBufferOxide) -> Result<()> {
-        let pos = output.inner_pos;
-        {
-            // isolation to please borrow checker
-            let inner = &mut output.inner[pos..pos + 8];
-            let bytes = u64::to_le_bytes(self.bit_buffer);
-            inner.copy_from_slice(&bytes);
-        }
-        match output.inner_pos.checked_add((self.bits_in >> 3) as usize) {
-            Some(n) if n <= output.inner.len() => output.inner_pos = n,
-            _ => return Err(Error {}),
-        }
-        self.bit_buffer >>= self.bits_in & !7;
-        self.bits_in &= 7;
-        Ok(())
-    }
-}
-
-/// A struct containing data about huffman codes and symbol frequencies.
-///
-/// NOTE: Only the literal/lengths have enough symbols to actually use
-/// the full array. It's unclear why it's defined like this in miniz,
-/// it could be for cache/alignment reasons.
-struct HuffmanOxide {
-    /// Number of occurrences of each symbol.
-    pub count: [[u16; MAX_HUFF_SYMBOLS]; MAX_HUFF_TABLES],
-    /// The bits of the huffman code assigned to the symbol
-    pub codes: [[u16; MAX_HUFF_SYMBOLS]; MAX_HUFF_TABLES],
-    /// The length of the huffman code assigned to the symbol.
-    pub code_sizes: [[u8; MAX_HUFF_SYMBOLS]; MAX_HUFF_TABLES],
-}
-
-/// Tables used for literal/lengths in `HuffmanOxide`.
-const LITLEN_TABLE: usize = 0;
-/// Tables for distances.
-const DIST_TABLE: usize = 1;
-/// Tables for the run-length encoded huffman lengths for literals/lengths/distances.
-const HUFF_CODES_TABLE: usize = 2;
-
-/// Status of RLE encoding of huffman code lengths.
-struct Rle {
-    pub z_count: u32,
-    pub repeat_count: u32,
-    pub prev_code_size: u8,
-}
-
-impl Rle {
-    fn prev_code_size(
-        &mut self,
-        packed_code_sizes: &mut [u8],
-        packed_pos: &mut usize,
-        h: &mut HuffmanOxide,
-    ) -> Result<()> {
-        let mut write = |buf| write(buf, packed_code_sizes, packed_pos);
-        let counts = &mut h.count[HUFF_CODES_TABLE];
-        if self.repeat_count != 0 {
-            if self.repeat_count < 3 {
-                counts[self.prev_code_size as usize] =
-                    counts[self.prev_code_size as usize].wrapping_add(self.repeat_count as u16);
-                let code = self.prev_code_size;
-                write(&[code, code, code][..self.repeat_count as usize])?;
-            } else {
-                counts[16] = counts[16].wrapping_add(1);
-                write(&[16, (self.repeat_count - 3) as u8][..])?;
-            }
-            self.repeat_count = 0;
-        }
-
-        Ok(())
-    }
-
-    fn zero_code_size(
-        &mut self,
-        packed_code_sizes: &mut [u8],
-        packed_pos: &mut usize,
-        h: &mut HuffmanOxide,
-    ) -> Result<()> {
-        let mut write = |buf| write(buf, packed_code_sizes, packed_pos);
-        let counts = &mut h.count[HUFF_CODES_TABLE];
-        if self.z_count != 0 {
-            if self.z_count < 3 {
-                counts[0] = counts[0].wrapping_add(self.z_count as u16);
-                write(&[0, 0, 0][..self.z_count as usize])?;
-            } else if self.z_count <= 10 {
-                counts[17] = counts[17].wrapping_add(1);
-                write(&[17, (self.z_count - 3) as u8][..])?;
-            } else {
-                counts[18] = counts[18].wrapping_add(1);
-                write(&[18, (self.z_count - 11) as u8][..])?;
-            }
-            self.z_count = 0;
-        }
-
-        Ok(())
-    }
-}
-
-fn write(src: &[u8], dst: &mut [u8], dst_pos: &mut usize) -> Result<()> {
-    match dst.get_mut(*dst_pos..*dst_pos + src.len()) {
-        Some(s) => s.copy_from_slice(src),
-        None => return Err(Error {}),
-    }
-    *dst_pos += src.len();
-    Ok(())
-}
-
-impl Default for HuffmanOxide {
-    fn default() -> Self {
-        HuffmanOxide {
-            count: [[0; MAX_HUFF_SYMBOLS]; MAX_HUFF_TABLES],
-            codes: [[0; MAX_HUFF_SYMBOLS]; MAX_HUFF_TABLES],
-            code_sizes: [[0; MAX_HUFF_SYMBOLS]; MAX_HUFF_TABLES],
-        }
-    }
-}
-
-impl HuffmanOxide {
-    fn radix_sort_symbols<'a>(
-        symbols0: &'a mut [SymFreq],
-        symbols1: &'a mut [SymFreq],
-    ) -> &'a mut [SymFreq] {
-        let mut hist = [[0; 256]; 2];
-
-        for freq in symbols0.iter() {
-            hist[0][(freq.key & 0xFF) as usize] += 1;
-            hist[1][((freq.key >> 8) & 0xFF) as usize] += 1;
-        }
-
-        let mut n_passes = 2;
-        if symbols0.len() == hist[1][0] {
-            n_passes -= 1;
-        }
-
-        let mut current_symbols = symbols0;
-        let mut new_symbols = symbols1;
-
-        for (pass, hist_item) in hist.iter().enumerate().take(n_passes) {
-            let mut offsets = [0; 256];
-            let mut offset = 0;
-            for i in 0..256 {
-                offsets[i] = offset;
-                offset += hist_item[i];
-            }
-
-            for sym in current_symbols.iter() {
-                let j = ((sym.key >> (pass * 8)) & 0xFF) as usize;
-                new_symbols[offsets[j]] = *sym;
-                offsets[j] += 1;
-            }
-
-            mem::swap(&mut current_symbols, &mut new_symbols);
-        }
-
-        current_symbols
-    }
-
-    fn calculate_minimum_redundancy(symbols: &mut [SymFreq]) {
-        match symbols.len() {
-            0 => (),
-            1 => symbols[0].key = 1,
-            n => {
-                symbols[0].key += symbols[1].key;
-                let mut root = 0;
-                let mut leaf = 2;
-                for next in 1..n - 1 {
-                    if (leaf >= n) || (symbols[root].key < symbols[leaf].key) {
-                        symbols[next].key = symbols[root].key;
-                        symbols[root].key = next as u16;
-                        root += 1;
-                    } else {
-                        symbols[next].key = symbols[leaf].key;
-                        leaf += 1;
-                    }
-
-                    if (leaf >= n) || (root < next && symbols[root].key < symbols[leaf].key) {
-                        symbols[next].key = symbols[next].key.wrapping_add(symbols[root].key);
-                        symbols[root].key = next as u16;
-                        root += 1;
-                    } else {
-                        symbols[next].key = symbols[next].key.wrapping_add(symbols[leaf].key);
-                        leaf += 1;
-                    }
-                }
-
-                symbols[n - 2].key = 0;
-                for next in (0..n - 2).rev() {
-                    symbols[next].key = symbols[symbols[next].key as usize].key + 1;
-                }
-
-                let mut avbl = 1;
-                let mut used = 0;
-                let mut dpth = 0;
-                let mut root = (n - 2) as i32;
-                let mut next = (n - 1) as i32;
-                while avbl > 0 {
-                    while (root >= 0) && (symbols[root as usize].key == dpth) {
-                        used += 1;
-                        root -= 1;
-                    }
-                    while avbl > used {
-                        symbols[next as usize].key = dpth;
-                        next -= 1;
-                        avbl -= 1;
-                    }
-                    avbl = 2 * used;
-                    dpth += 1;
-                    used = 0;
-                }
-            }
-        }
-    }
-
-    fn enforce_max_code_size(num_codes: &mut [i32], code_list_len: usize, max_code_size: usize) {
-        if code_list_len <= 1 {
-            return;
-        }
-
-        num_codes[max_code_size] += num_codes[max_code_size + 1..].iter().sum::<i32>();
-        let total = num_codes[1..=max_code_size]
-            .iter()
-            .rev()
-            .enumerate()
-            .fold(0u32, |total, (i, &x)| total + ((x as u32) << i));
-
-        for _ in (1 << max_code_size)..total {
-            num_codes[max_code_size] -= 1;
-            for i in (1..max_code_size).rev() {
-                if num_codes[i] != 0 {
-                    num_codes[i] -= 1;
-                    num_codes[i + 1] += 2;
-                    break;
-                }
-            }
-        }
-    }
-
-    fn optimize_table(
-        &mut self,
-        table_num: usize,
-        table_len: usize,
-        code_size_limit: usize,
-        static_table: bool,
-    ) {
-        let mut num_codes = [0i32; MAX_SUPPORTED_HUFF_CODESIZE + 1];
-        let mut next_code = [0u32; MAX_SUPPORTED_HUFF_CODESIZE + 1];
-
-        if static_table {
-            for &code_size in &self.code_sizes[table_num][..table_len] {
-                num_codes[code_size as usize] += 1;
-            }
-        } else {
-            let mut symbols0 = [SymFreq {
-                key: 0,
-                sym_index: 0,
-            }; MAX_HUFF_SYMBOLS];
-            let mut symbols1 = [SymFreq {
-                key: 0,
-                sym_index: 0,
-            }; MAX_HUFF_SYMBOLS];
-
-            let mut num_used_symbols = 0;
-            for i in 0..table_len {
-                if self.count[table_num][i] != 0 {
-                    symbols0[num_used_symbols] = SymFreq {
-                        key: self.count[table_num][i],
-                        sym_index: i as u16,
-                    };
-                    num_used_symbols += 1;
-                }
-            }
-
-            let symbols = Self::radix_sort_symbols(
-                &mut symbols0[..num_used_symbols],
-                &mut symbols1[..num_used_symbols],
-            );
-            Self::calculate_minimum_redundancy(symbols);
-
-            for symbol in symbols.iter() {
-                num_codes[symbol.key as usize] += 1;
-            }
-
-            Self::enforce_max_code_size(&mut num_codes, num_used_symbols, code_size_limit);
-
-            memset(&mut self.code_sizes[table_num][..], 0);
-            memset(&mut self.codes[table_num][..], 0);
-
-            let mut last = num_used_symbols;
-            for (i, &num_item) in num_codes
-                .iter()
-                .enumerate()
-                .take(code_size_limit + 1)
-                .skip(1)
-            {
-                let first = last - num_item as usize;
-                for symbol in &symbols[first..last] {
-                    self.code_sizes[table_num][symbol.sym_index as usize] = i as u8;
-                }
-                last = first;
-            }
-        }
-
-        let mut j = 0;
-        next_code[1] = 0;
-        for i in 2..=code_size_limit {
-            j = (j + num_codes[i - 1]) << 1;
-            next_code[i] = j as u32;
-        }
-
-        for (&code_size, huff_code) in self.code_sizes[table_num]
-            .iter()
-            .take(table_len)
-            .zip(self.codes[table_num].iter_mut().take(table_len))
-        {
-            if code_size == 0 {
-                continue;
-            }
-
-            let mut code = next_code[code_size as usize];
-            next_code[code_size as usize] += 1;
-
-            let mut rev_code = 0;
-            for _ in 0..code_size {
-                rev_code = (rev_code << 1) | (code & 1);
-                code >>= 1;
-            }
-            *huff_code = rev_code as u16;
-        }
-    }
-
-    fn start_static_block(&mut self, output: &mut OutputBufferOxide) {
-        memset(&mut self.code_sizes[LITLEN_TABLE][0..144], 8);
-        memset(&mut self.code_sizes[LITLEN_TABLE][144..256], 9);
-        memset(&mut self.code_sizes[LITLEN_TABLE][256..280], 7);
-        memset(&mut self.code_sizes[LITLEN_TABLE][280..288], 8);
-
-        memset(&mut self.code_sizes[DIST_TABLE][..32], 5);
-
-        self.optimize_table(LITLEN_TABLE, 288, 15, true);
-        self.optimize_table(DIST_TABLE, 32, 15, true);
-
-        output.put_bits(0b01, 2)
-    }
-
-    fn start_dynamic_block(&mut self, output: &mut OutputBufferOxide) -> Result<()> {
-        // There will always be one, and only one end of block code.
-        self.count[0][256] = 1;
-
-        self.optimize_table(0, MAX_HUFF_SYMBOLS_0, 15, false);
-        self.optimize_table(1, MAX_HUFF_SYMBOLS_1, 15, false);
-
-        let num_lit_codes = 286
-            - &self.code_sizes[0][257..286]
-                .iter()
-                .rev()
-                .take_while(|&x| *x == 0)
-                .count();
-
-        let num_dist_codes = 30
-            - &self.code_sizes[1][1..30]
-                .iter()
-                .rev()
-                .take_while(|&x| *x == 0)
-                .count();
-
-        let mut code_sizes_to_pack = [0u8; MAX_HUFF_SYMBOLS_0 + MAX_HUFF_SYMBOLS_1];
-        let mut packed_code_sizes = [0u8; MAX_HUFF_SYMBOLS_0 + MAX_HUFF_SYMBOLS_1];
-
-        let total_code_sizes_to_pack = num_lit_codes + num_dist_codes;
-
-        code_sizes_to_pack[..num_lit_codes].copy_from_slice(&self.code_sizes[0][..num_lit_codes]);
-
-        code_sizes_to_pack[num_lit_codes..total_code_sizes_to_pack]
-            .copy_from_slice(&self.code_sizes[1][..num_dist_codes]);
-
-        let mut rle = Rle {
-            z_count: 0,
-            repeat_count: 0,
-            prev_code_size: 0xFF,
-        };
-
-        memset(&mut self.count[HUFF_CODES_TABLE][..MAX_HUFF_SYMBOLS_2], 0);
-
-        let mut packed_pos = 0;
-        for &code_size in &code_sizes_to_pack[..total_code_sizes_to_pack] {
-            if code_size == 0 {
-                rle.prev_code_size(&mut packed_code_sizes, &mut packed_pos, self)?;
-                rle.z_count += 1;
-                if rle.z_count == 138 {
-                    rle.zero_code_size(&mut packed_code_sizes, &mut packed_pos, self)?;
-                }
-            } else {
-                rle.zero_code_size(&mut packed_code_sizes, &mut packed_pos, self)?;
-                if code_size != rle.prev_code_size {
-                    rle.prev_code_size(&mut packed_code_sizes, &mut packed_pos, self)?;
-                    self.count[HUFF_CODES_TABLE][code_size as usize] =
-                        self.count[HUFF_CODES_TABLE][code_size as usize].wrapping_add(1);
-                    write(&[code_size], &mut packed_code_sizes, &mut packed_pos)?;
-                } else {
-                    rle.repeat_count += 1;
-                    if rle.repeat_count == 6 {
-                        rle.prev_code_size(&mut packed_code_sizes, &mut packed_pos, self)?;
-                    }
-                }
-            }
-            rle.prev_code_size = code_size;
-        }
-
-        if rle.repeat_count != 0 {
-            rle.prev_code_size(&mut packed_code_sizes, &mut packed_pos, self)?;
-        } else {
-            rle.zero_code_size(&mut packed_code_sizes, &mut packed_pos, self)?;
-        }
-
-        self.optimize_table(2, MAX_HUFF_SYMBOLS_2, 7, false);
-
-        output.put_bits(2, 2);
-
-        output.put_bits((num_lit_codes - 257) as u32, 5);
-        output.put_bits((num_dist_codes - 1) as u32, 5);
-
-        let mut num_bit_lengths = 18
-            - HUFFMAN_LENGTH_ORDER
-                .iter()
-                .rev()
-                .take_while(|&swizzle| self.code_sizes[HUFF_CODES_TABLE][*swizzle as usize] == 0)
-                .count();
-
-        num_bit_lengths = cmp::max(4, num_bit_lengths + 1);
-        output.put_bits(num_bit_lengths as u32 - 4, 4);
-        for &swizzle in &HUFFMAN_LENGTH_ORDER[..num_bit_lengths] {
-            output.put_bits(
-                u32::from(self.code_sizes[HUFF_CODES_TABLE][swizzle as usize]),
-                3,
-            );
-        }
-
-        let mut packed_code_size_index = 0;
-        while packed_code_size_index < packed_pos {
-            let code = packed_code_sizes[packed_code_size_index] as usize;
-            packed_code_size_index += 1;
-            assert!(code < MAX_HUFF_SYMBOLS_2);
-            output.put_bits(
-                u32::from(self.codes[HUFF_CODES_TABLE][code]),
-                u32::from(self.code_sizes[HUFF_CODES_TABLE][code]),
-            );
-            if code >= 16 {
-                output.put_bits(
-                    u32::from(packed_code_sizes[packed_code_size_index]),
-                    [2, 3, 7][code - 16],
-                );
-                packed_code_size_index += 1;
-            }
-        }
-
-        Ok(())
-    }
-}
-
-struct DictOxide {
-    /// The maximum number of checks in the hash chain, for the initial,
-    /// and the lazy match respectively.
-    pub max_probes: [u32; 2],
-    /// Buffer of input data.
-    /// Padded with 1 byte to simplify matching code in `compress_fast`.
-    pub b: Box<HashBuffers>,
-
-    pub code_buf_dict_pos: usize,
-    pub lookahead_size: usize,
-    pub lookahead_pos: usize,
-    pub size: usize,
-}
-
-const fn probes_from_flags(flags: u32) -> [u32; 2] {
-    [
-        1 + ((flags & 0xFFF) + 2) / 3,
-        1 + (((flags & 0xFFF) >> 2) + 2) / 3,
-    ]
-}
-
-impl DictOxide {
-    fn new(flags: u32) -> Self {
-        DictOxide {
-            max_probes: probes_from_flags(flags),
-            b: Box::default(),
-            code_buf_dict_pos: 0,
-            lookahead_size: 0,
-            lookahead_pos: 0,
-            size: 0,
-        }
-    }
-
-    fn update_flags(&mut self, flags: u32) {
-        self.max_probes = probes_from_flags(flags);
-    }
-
-    fn reset(&mut self) {
-        self.b.reset();
-        self.code_buf_dict_pos = 0;
-        self.lookahead_size = 0;
-        self.lookahead_pos = 0;
-        self.size = 0;
-    }
-
-    /// Do an unaligned read of the data at `pos` in the dictionary and treat it as if it was of
-    /// type T.
-    #[inline]
-    fn read_unaligned_u32(&self, pos: usize) -> u32 {
-        // Masking the value here helps avoid bounds checks.
-        let pos = pos & LZ_DICT_SIZE_MASK;
-        let end = pos + 4;
-        // Somehow this assertion makes things faster.
-        // TODO: as of may 2024 this does not seem to make any difference
-        // so consider removing.
-        assert!(end < LZ_DICT_FULL_SIZE);
-
-        let bytes: [u8; 4] = self.b.dict[pos..end].try_into().unwrap();
-        u32::from_le_bytes(bytes)
-    }
-
-    /// Do an unaligned read of the data at `pos` in the dictionary and treat it as if it was of
-    /// type T.
-    #[inline]
-    fn read_unaligned_u64(&self, pos: usize) -> u64 {
-        // Help evade bounds/panic code check by masking the position value
-        // This provides a small speedup at the cost of an instruction or two instead of
-        // having to use unsafe.
-        let pos = pos & LZ_DICT_SIZE_MASK;
-        let bytes: [u8; 8] = self.b.dict[pos..pos + 8].try_into().unwrap();
-        u64::from_le_bytes(bytes)
-    }
-
-    /// Do an unaligned read of the data at `pos` in the dictionary and treat it as if it was of
-    /// type T.
-    #[inline]
-    fn read_as_u16(&self, pos: usize) -> u16 {
-        read_u16_le(&self.b.dict[..], pos)
-    }
-
-    /// Try to find a match for the data at lookahead_pos in the dictionary that is
-    /// longer than `match_len`.
-    /// Returns a tuple containing (match_distance, match_length). Will be equal to the input
-    /// values if no better matches were found.
-    fn find_match(
-        &self,
-        lookahead_pos: usize,
-        max_dist: usize,
-        max_match_len: u32,
-        mut match_dist: u32,
-        mut match_len: u32,
-    ) -> (u32, u32) {
-        // Clamp the match len and max_match_len to be valid. (It should be when this is called, but
-        // do it for now just in case for safety reasons.)
-        // This should normally end up as at worst conditional moves,
-        // so it shouldn't slow us down much.
-        // TODO: Statically verify these so we don't need to do this.
-        let max_match_len = cmp::min(MAX_MATCH_LEN as u32, max_match_len);
-        match_len = cmp::max(match_len, 1);
-
-        let pos = lookahead_pos & LZ_DICT_SIZE_MASK;
-        let mut probe_pos = pos;
-        // Number of probes into the hash chains.
-        let mut num_probes_left = self.max_probes[(match_len >= 32) as usize];
-
-        // If we already have a match of the full length don't bother searching for another one.
-        if max_match_len <= match_len {
-            return (match_dist, match_len);
-        }
-
-        // Read the last byte of the current match, and the next one, used to compare matches.
-        let mut c01: u16 = self.read_as_u16(pos + match_len as usize - 1);
-        // Read the two bytes at the end position of the current match.
-        let s01: u16 = self.read_as_u16(pos);
-
-        'outer: loop {
-            let mut dist;
-            'found: loop {
-                num_probes_left -= 1;
-                if num_probes_left == 0 {
-                    // We have done as many probes in the hash chain as the current compression
-                    // settings allow, so return the best match we found, if any.
-                    return (match_dist, match_len);
-                }
-
-                for _ in 0..3 {
-                    let next_probe_pos = self.b.next[probe_pos] as usize;
-
-                    dist = (lookahead_pos - next_probe_pos) & 0xFFFF;
-                    if next_probe_pos == 0 || dist > max_dist {
-                        // We reached the end of the hash chain, or the next value is further away
-                        // than the maximum allowed distance, so return the best match we found, if
-                        // any.
-                        return (match_dist, match_len);
-                    }
-
-                    // Mask the position value to get the position in the hash chain of the next
-                    // position to match against.
-                    probe_pos = next_probe_pos & LZ_DICT_SIZE_MASK;
-
-                    if self.read_as_u16(probe_pos + match_len as usize - 1) == c01 {
-                        break 'found;
-                    }
-                }
-            }
-
-            if dist == 0 {
-                // We've looked through the whole match range, so return the best match we
-                // found.
-                return (match_dist, match_len);
-            }
-
-            // Check if the two first bytes match.
-            if self.read_as_u16(probe_pos) != s01 {
-                continue;
-            }
-
-            let mut p = pos + 2;
-            let mut q = probe_pos + 2;
-            // The first two bytes matched, so check the full length of the match.
-            for _ in 0..32 {
-                let p_data: u64 = self.read_unaligned_u64(p);
-                let q_data: u64 = self.read_unaligned_u64(q);
-                // Compare of 8 bytes at a time by using unaligned loads of 64-bit integers.
-                let xor_data = p_data ^ q_data;
-                if xor_data == 0 {
-                    p += 8;
-                    q += 8;
-                } else {
-                    // If not all of the last 8 bytes matched, check how may of them did.
-                    let trailing = xor_data.trailing_zeros();
-
-                    let probe_len = p - pos + (trailing as usize >> 3);
-                    if probe_len > match_len as usize {
-                        match_dist = dist as u32;
-                        match_len = cmp::min(max_match_len, probe_len as u32);
-                        if match_len == max_match_len {
-                            // We found a match that had the maximum allowed length,
-                            // so there is now point searching further.
-                            return (match_dist, match_len);
-                        }
-                        // We found a better match, so save the last two bytes for further match
-                        // comparisons.
-                        c01 = self.read_as_u16(pos + match_len as usize - 1)
-                    }
-                    continue 'outer;
-                }
-            }
-
-            return (dist as u32, cmp::min(max_match_len, MAX_MATCH_LEN as u32));
-        }
-    }
-}
-
-struct ParamsOxide {
-    pub flags: u32,
-    pub greedy_parsing: bool,
-    pub block_index: u32,
-
-    pub saved_match_dist: u32,
-    pub saved_match_len: u32,
-    pub saved_lit: u8,
-
-    pub flush: TDEFLFlush,
-    pub flush_ofs: u32,
-    pub flush_remaining: u32,
-    pub finished: bool,
-
-    pub adler32: u32,
-
-    pub src_pos: usize,
-
-    pub out_buf_ofs: usize,
-    pub prev_return_status: TDEFLStatus,
-
-    pub saved_bit_buffer: u32,
-    pub saved_bits_in: u32,
-
-    pub local_buf: Box<LocalBuf>,
-}
-
-impl ParamsOxide {
-    fn new(flags: u32) -> Self {
-        ParamsOxide {
-            flags,
-            greedy_parsing: flags & TDEFL_GREEDY_PARSING_FLAG != 0,
-            block_index: 0,
-            saved_match_dist: 0,
-            saved_match_len: 0,
-            saved_lit: 0,
-            flush: TDEFLFlush::None,
-            flush_ofs: 0,
-            flush_remaining: 0,
-            finished: false,
-            adler32: MZ_ADLER32_INIT,
-            src_pos: 0,
-            out_buf_ofs: 0,
-            prev_return_status: TDEFLStatus::Okay,
-            saved_bit_buffer: 0,
-            saved_bits_in: 0,
-            local_buf: Box::default(),
-        }
-    }
-
-    fn update_flags(&mut self, flags: u32) {
-        self.flags = flags;
-        self.greedy_parsing = self.flags & TDEFL_GREEDY_PARSING_FLAG != 0;
-    }
-
-    /// Reset state, saving settings.
-    fn reset(&mut self) {
-        self.block_index = 0;
-        self.saved_match_len = 0;
-        self.saved_match_dist = 0;
-        self.saved_lit = 0;
-        self.flush = TDEFLFlush::None;
-        self.flush_ofs = 0;
-        self.flush_remaining = 0;
-        self.finished = false;
-        self.adler32 = MZ_ADLER32_INIT;
-        self.src_pos = 0;
-        self.out_buf_ofs = 0;
-        self.prev_return_status = TDEFLStatus::Okay;
-        self.saved_bit_buffer = 0;
-        self.saved_bits_in = 0;
-        self.local_buf.b = [0; OUT_BUF_SIZE];
-    }
-}
-
-struct LZOxide {
-    pub codes: [u8; LZ_CODE_BUF_SIZE],
-    pub code_position: usize,
-    pub flag_position: usize,
-
-    // The total number of bytes in the current block.
-    pub total_bytes: u32,
-    pub num_flags_left: u32,
-}
-
-impl LZOxide {
-    const fn new() -> Self {
-        LZOxide {
-            codes: [0; LZ_CODE_BUF_SIZE],
-            code_position: 1,
-            flag_position: 0,
-            total_bytes: 0,
-            num_flags_left: 8,
-        }
-    }
-
-    fn write_code(&mut self, val: u8) {
-        // Perf - go via u16 to help evade bounds check
-        // TODO: see if we can use u16 for flag_position in general.
-        self.codes[usize::from(self.code_position as u16)] = val;
-        self.code_position += 1;
-    }
-
-    fn init_flag(&mut self) {
-        if self.num_flags_left == 8 {
-            *self.get_flag() = 0;
-            self.code_position -= 1;
-        } else {
-            *self.get_flag() >>= self.num_flags_left;
-        }
-    }
-
-    fn get_flag(&mut self) -> &mut u8 {
-        // Perf - go via u16 to help evade bounds check
-        // TODO: see if we can use u16 for flag_position in general.
-        &mut self.codes[usize::from(self.flag_position as u16)]
-    }
-
-    fn plant_flag(&mut self) {
-        self.flag_position = self.code_position;
-        self.code_position += 1;
-    }
-
-    fn consume_flag(&mut self) {
-        self.num_flags_left -= 1;
-        if self.num_flags_left == 0 {
-            self.num_flags_left = 8;
-            self.plant_flag();
-        }
-    }
-}
-
-fn compress_lz_codes(
-    huff: &HuffmanOxide,
-    output: &mut OutputBufferOxide,
-    lz_code_buf: &[u8],
-) -> Result<bool> {
-    let mut flags = 1;
-    let mut bb = BitBuffer {
-        bit_buffer: u64::from(output.bit_buffer),
-        bits_in: output.bits_in,
-    };
-
-    let mut i: usize = 0;
-    while i < lz_code_buf.len() {
-        if flags == 1 {
-            flags = u32::from(lz_code_buf[i]) | 0x100;
-            i += 1;
-        }
-
-        // The lz code was a length code
-        if flags & 1 == 1 {
-            flags >>= 1;
-
-            let sym;
-            let num_extra_bits;
-
-            let match_len = lz_code_buf[i] as usize;
-
-            let match_dist = read_u16_le(lz_code_buf, i + 1);
-
-            i += 3;
-
-            debug_assert!(huff.code_sizes[0][LEN_SYM[match_len] as usize] != 0);
-            bb.put_fast(
-                u64::from(huff.codes[0][LEN_SYM[match_len] as usize]),
-                u32::from(huff.code_sizes[0][LEN_SYM[match_len] as usize]),
-            );
-            bb.put_fast(
-                match_len as u64 & u64::from(BITMASKS[LEN_EXTRA[match_len] as usize]),
-                u32::from(LEN_EXTRA[match_len]),
-            );
-
-            if match_dist < 512 {
-                sym = SMALL_DIST_SYM[match_dist as usize] as usize;
-                num_extra_bits = SMALL_DIST_EXTRA[match_dist as usize] as usize;
-            } else {
-                sym = LARGE_DIST_SYM[(match_dist >> 8) as usize] as usize;
-                num_extra_bits = LARGE_DIST_EXTRA[(match_dist >> 8) as usize] as usize;
-            }
-
-            debug_assert!(huff.code_sizes[1][sym] != 0);
-            bb.put_fast(
-                u64::from(huff.codes[1][sym]),
-                u32::from(huff.code_sizes[1][sym]),
-            );
-            bb.put_fast(
-                u64::from(match_dist) & u64::from(BITMASKS[num_extra_bits]),
-                num_extra_bits as u32,
-            );
-        } else {
-            // The lz code was a literal
-            for _ in 0..3 {
-                flags >>= 1;
-                let lit = lz_code_buf[i];
-                i += 1;
-
-                debug_assert!(huff.code_sizes[0][lit as usize] != 0);
-                bb.put_fast(
-                    u64::from(huff.codes[0][lit as usize]),
-                    u32::from(huff.code_sizes[0][lit as usize]),
-                );
-
-                if flags & 1 == 1 || i >= lz_code_buf.len() {
-                    break;
-                }
-            }
-        }
-
-        bb.flush(output)?;
-    }
-
-    output.bits_in = 0;
-    output.bit_buffer = 0;
-    while bb.bits_in != 0 {
-        let n = cmp::min(bb.bits_in, 16);
-        output.put_bits(bb.bit_buffer as u32 & BITMASKS[n as usize], n);
-        bb.bit_buffer >>= n;
-        bb.bits_in -= n;
-    }
-
-    // Output the end of block symbol.
-    output.put_bits(
-        u32::from(huff.codes[0][256]),
-        u32::from(huff.code_sizes[0][256]),
-    );
-
-    Ok(true)
-}
-
-fn compress_block(
-    huff: &mut HuffmanOxide,
-    output: &mut OutputBufferOxide,
-    lz: &LZOxide,
-    static_block: bool,
-) -> Result<bool> {
-    if static_block {
-        huff.start_static_block(output);
-    } else {
-        huff.start_dynamic_block(output)?;
-    }
-
-    compress_lz_codes(huff, output, &lz.codes[..lz.code_position])
-}
-
-fn flush_block(
-    d: &mut CompressorOxide,
-    callback: &mut CallbackOxide,
-    flush: TDEFLFlush,
-) -> Result<i32> {
-    let mut saved_buffer;
-    {
-        let mut output = callback
-            .out
-            .new_output_buffer(&mut d.params.local_buf.b, d.params.out_buf_ofs);
-        output.bit_buffer = d.params.saved_bit_buffer;
-        output.bits_in = d.params.saved_bits_in;
-
-        let use_raw_block = (d.params.flags & TDEFL_FORCE_ALL_RAW_BLOCKS != 0)
-            && (d.dict.lookahead_pos - d.dict.code_buf_dict_pos) <= d.dict.size;
-
-        assert!(d.params.flush_remaining == 0);
-        d.params.flush_ofs = 0;
-        d.params.flush_remaining = 0;
-
-        d.lz.init_flag();
-
-        // If we are at the start of the stream, write the zlib header if requested.
-        if d.params.flags & TDEFL_WRITE_ZLIB_HEADER != 0 && d.params.block_index == 0 {
-            let header = zlib::header_from_flags(d.params.flags);
-            output.put_bits(header[0].into(), 8);
-            output.put_bits(header[1].into(), 8);
-        }
-
-        // Output the block header.
-        output.put_bits((flush == TDEFLFlush::Finish) as u32, 1);
-
-        saved_buffer = output.save();
-
-        let comp_success = if !use_raw_block {
-            let use_static =
-                (d.params.flags & TDEFL_FORCE_ALL_STATIC_BLOCKS != 0) || (d.lz.total_bytes < 48);
-            compress_block(&mut d.huff, &mut output, &d.lz, use_static)?
-        } else {
-            false
-        };
-
-        // If we failed to compress anything and the output would take up more space than the output
-        // data, output a stored block instead, which has at most 5 bytes of overhead.
-        // We only use some simple heuristics for now.
-        // A stored block will have an overhead of at least 4 bytes containing the block length
-        // but usually more due to the length parameters having to start at a byte boundary and thus
-        // requiring up to 5 bytes of padding.
-        // As a static block will have an overhead of at most 1 bit per byte
-        // (as literals are either 8 or 9 bytes), a raw block will
-        // never take up less space if the number of input bytes are less than 32.
-        let expanded = (d.lz.total_bytes > 32)
-            && (output.inner_pos - saved_buffer.pos + 1 >= (d.lz.total_bytes as usize))
-            && (d.dict.lookahead_pos - d.dict.code_buf_dict_pos <= d.dict.size);
-
-        if use_raw_block || expanded {
-            output.load(saved_buffer);
-
-            // Block header.
-            output.put_bits(0, 2);
-
-            // Block length has to start on a byte boundary, s opad.
-            output.pad_to_bytes();
-
-            // Block length and ones complement of block length.
-            output.put_bits(d.lz.total_bytes & 0xFFFF, 16);
-            output.put_bits(!d.lz.total_bytes & 0xFFFF, 16);
-
-            // Write the actual bytes.
-            for i in 0..d.lz.total_bytes {
-                let pos = (d.dict.code_buf_dict_pos + i as usize) & LZ_DICT_SIZE_MASK;
-                output.put_bits(u32::from(d.dict.b.dict[pos]), 8);
-            }
-        } else if !comp_success {
-            output.load(saved_buffer);
-            compress_block(&mut d.huff, &mut output, &d.lz, true)?;
-        }
-
-        if flush != TDEFLFlush::None {
-            if flush == TDEFLFlush::Finish {
-                output.pad_to_bytes();
-                if d.params.flags & TDEFL_WRITE_ZLIB_HEADER != 0 {
-                    let mut adler = d.params.adler32;
-                    for _ in 0..4 {
-                        output.put_bits((adler >> 24) & 0xFF, 8);
-                        adler <<= 8;
-                    }
-                }
-            } else {
-                // Sync or Full flush.
-                // Output an empty raw block.
-                output.put_bits(0, 3);
-                output.pad_to_bytes();
-                output.put_bits(0, 16);
-                output.put_bits(0xFFFF, 16);
-            }
-        }
-
-        memset(&mut d.huff.count[0][..MAX_HUFF_SYMBOLS_0], 0);
-        memset(&mut d.huff.count[1][..MAX_HUFF_SYMBOLS_1], 0);
-
-        d.lz.code_position = 1;
-        d.lz.flag_position = 0;
-        d.lz.num_flags_left = 8;
-        d.dict.code_buf_dict_pos += d.lz.total_bytes as usize;
-        d.lz.total_bytes = 0;
-        d.params.block_index += 1;
-
-        saved_buffer = output.save();
-
-        d.params.saved_bit_buffer = saved_buffer.bit_buffer;
-        d.params.saved_bits_in = saved_buffer.bits_in;
-    }
-
-    Ok(callback.flush_output(saved_buffer, &mut d.params))
-}
-
-fn record_literal(h: &mut HuffmanOxide, lz: &mut LZOxide, lit: u8) {
-    lz.total_bytes += 1;
-    lz.write_code(lit);
-
-    *lz.get_flag() >>= 1;
-    lz.consume_flag();
-
-    h.count[0][lit as usize] += 1;
-}
-
-fn record_match(h: &mut HuffmanOxide, lz: &mut LZOxide, mut match_len: u32, mut match_dist: u32) {
-    debug_assert!(match_len >= MIN_MATCH_LEN.into());
-    debug_assert!(match_dist >= 1);
-    debug_assert!(match_dist as usize <= LZ_DICT_SIZE);
-
-    lz.total_bytes += match_len;
-    match_dist -= 1;
-    match_len -= u32::from(MIN_MATCH_LEN);
-    lz.write_code(match_len as u8);
-    lz.write_code(match_dist as u8);
-    lz.write_code((match_dist >> 8) as u8);
-
-    *lz.get_flag() >>= 1;
-    *lz.get_flag() |= 0x80;
-    lz.consume_flag();
-
-    let symbol = if match_dist < 512 {
-        SMALL_DIST_SYM[match_dist as usize]
-    } else {
-        LARGE_DIST_SYM[((match_dist >> 8) & 127) as usize]
-    } as usize;
-    h.count[1][symbol] += 1;
-    // Perf - go via u8 to help optimize out bounds check.
-    h.count[0][LEN_SYM[usize::from(match_len as u8)] as usize] += 1;
-}
-
-fn compress_normal(d: &mut CompressorOxide, callback: &mut CallbackOxide) -> bool {
-    let mut src_pos = d.params.src_pos;
-    let in_buf = match callback.in_buf {
-        None => return true,
-        Some(in_buf) => in_buf,
-    };
-
-    let mut lookahead_size = d.dict.lookahead_size;
-    let mut lookahead_pos = d.dict.lookahead_pos;
-    let mut saved_lit = d.params.saved_lit;
-    let mut saved_match_dist = d.params.saved_match_dist;
-    let mut saved_match_len = d.params.saved_match_len;
-
-    while src_pos < in_buf.len() || (d.params.flush != TDEFLFlush::None && lookahead_size != 0) {
-        let src_buf_left = in_buf.len() - src_pos;
-        let num_bytes_to_process = cmp::min(src_buf_left, MAX_MATCH_LEN - lookahead_size);
-
-        if lookahead_size + d.dict.size >= usize::from(MIN_MATCH_LEN) - 1
-            && num_bytes_to_process > 0
-        {
-            let dictb = &mut d.dict.b;
-
-            let mut dst_pos = (lookahead_pos + lookahead_size) & LZ_DICT_SIZE_MASK;
-            let mut ins_pos = lookahead_pos + lookahead_size - 2;
-            // Start the hash value from the first two bytes
-            let mut hash = update_hash(
-                u16::from(dictb.dict[ins_pos & LZ_DICT_SIZE_MASK]),
-                dictb.dict[(ins_pos + 1) & LZ_DICT_SIZE_MASK],
-            );
-
-            lookahead_size += num_bytes_to_process;
-
-            for &c in &in_buf[src_pos..src_pos + num_bytes_to_process] {
-                // Add byte to input buffer.
-                dictb.dict[dst_pos] = c;
-                if dst_pos < MAX_MATCH_LEN - 1 {
-                    dictb.dict[LZ_DICT_SIZE + dst_pos] = c;
-                }
-
-                // Generate hash from the current byte,
-                hash = update_hash(hash, c);
-                dictb.next[ins_pos & LZ_DICT_SIZE_MASK] = dictb.hash[hash as usize];
-                // and insert it into the hash chain.
-                dictb.hash[hash as usize] = ins_pos as u16;
-                dst_pos = (dst_pos + 1) & LZ_DICT_SIZE_MASK;
-                ins_pos += 1;
-            }
-            src_pos += num_bytes_to_process;
-        } else {
-            let dictb = &mut d.dict.b;
-            for &c in &in_buf[src_pos..src_pos + num_bytes_to_process] {
-                let dst_pos = (lookahead_pos + lookahead_size) & LZ_DICT_SIZE_MASK;
-                dictb.dict[dst_pos] = c;
-                if dst_pos < MAX_MATCH_LEN - 1 {
-                    dictb.dict[LZ_DICT_SIZE + dst_pos] = c;
-                }
-
-                lookahead_size += 1;
-                if lookahead_size + d.dict.size >= MIN_MATCH_LEN.into() {
-                    let ins_pos = lookahead_pos + lookahead_size - 3;
-                    let hash = ((u32::from(dictb.dict[ins_pos & LZ_DICT_SIZE_MASK])
-                        << (LZ_HASH_SHIFT * 2))
-                        ^ ((u32::from(dictb.dict[(ins_pos + 1) & LZ_DICT_SIZE_MASK])
-                            << LZ_HASH_SHIFT)
-                            ^ u32::from(c)))
-                        & (LZ_HASH_SIZE as u32 - 1);
-
-                    dictb.next[ins_pos & LZ_DICT_SIZE_MASK] = dictb.hash[hash as usize];
-                    dictb.hash[hash as usize] = ins_pos as u16;
-                }
-            }
-
-            src_pos += num_bytes_to_process;
-        }
-
-        d.dict.size = cmp::min(LZ_DICT_SIZE - lookahead_size, d.dict.size);
-        if d.params.flush == TDEFLFlush::None && lookahead_size < MAX_MATCH_LEN {
-            break;
-        }
-
-        let mut len_to_move = 1;
-        let mut cur_match_dist = 0;
-        let mut cur_match_len = if saved_match_len != 0 {
-            saved_match_len
-        } else {
-            u32::from(MIN_MATCH_LEN) - 1
-        };
-        let cur_pos = lookahead_pos & LZ_DICT_SIZE_MASK;
-        if d.params.flags & (TDEFL_RLE_MATCHES | TDEFL_FORCE_ALL_RAW_BLOCKS) != 0 {
-            // If TDEFL_RLE_MATCHES is set, we only look for repeating sequences of the current byte.
-            if d.dict.size != 0 && d.params.flags & TDEFL_FORCE_ALL_RAW_BLOCKS == 0 {
-                let c = d.dict.b.dict[(cur_pos.wrapping_sub(1)) & LZ_DICT_SIZE_MASK];
-                cur_match_len = d.dict.b.dict[cur_pos..(cur_pos + lookahead_size)]
-                    .iter()
-                    .take_while(|&x| *x == c)
-                    .count() as u32;
-                if cur_match_len < MIN_MATCH_LEN.into() {
-                    cur_match_len = 0
-                } else {
-                    cur_match_dist = 1
-                }
-            }
-        } else {
-            // Try to find a match for the bytes at the current position.
-            let dist_len = d.dict.find_match(
-                lookahead_pos,
-                d.dict.size,
-                lookahead_size as u32,
-                cur_match_dist,
-                cur_match_len,
-            );
-            cur_match_dist = dist_len.0;
-            cur_match_len = dist_len.1;
-        }
-
-        let far_and_small = cur_match_len == MIN_MATCH_LEN.into() && cur_match_dist >= 8 * 1024;
-        let filter_small = d.params.flags & TDEFL_FILTER_MATCHES != 0 && cur_match_len <= 5;
-        if far_and_small || filter_small || cur_pos == cur_match_dist as usize {
-            cur_match_dist = 0;
-            cur_match_len = 0;
-        }
-
-        if saved_match_len != 0 {
-            if cur_match_len > saved_match_len {
-                record_literal(&mut d.huff, &mut d.lz, saved_lit);
-                if cur_match_len >= 128 {
-                    record_match(&mut d.huff, &mut d.lz, cur_match_len, cur_match_dist);
-                    saved_match_len = 0;
-                    len_to_move = cur_match_len as usize;
-                } else {
-                    saved_lit = d.dict.b.dict[cur_pos];
-                    saved_match_dist = cur_match_dist;
-                    saved_match_len = cur_match_len;
-                }
-            } else {
-                record_match(&mut d.huff, &mut d.lz, saved_match_len, saved_match_dist);
-                len_to_move = (saved_match_len - 1) as usize;
-                saved_match_len = 0;
-            }
-        } else if cur_match_dist == 0 {
-            record_literal(
-                &mut d.huff,
-                &mut d.lz,
-                d.dict.b.dict[cmp::min(cur_pos, d.dict.b.dict.len() - 1)],
-            );
-        } else if d.params.greedy_parsing
-            || (d.params.flags & TDEFL_RLE_MATCHES != 0)
-            || cur_match_len >= 128
-        {
-            // If we are using lazy matching, check for matches at the next byte if the current
-            // match was shorter than 128 bytes.
-            record_match(&mut d.huff, &mut d.lz, cur_match_len, cur_match_dist);
-            len_to_move = cur_match_len as usize;
-        } else {
-            saved_lit = d.dict.b.dict[cmp::min(cur_pos, d.dict.b.dict.len() - 1)];
-            saved_match_dist = cur_match_dist;
-            saved_match_len = cur_match_len;
-        }
-
-        lookahead_pos += len_to_move;
-        assert!(lookahead_size >= len_to_move);
-        lookahead_size -= len_to_move;
-        d.dict.size = cmp::min(d.dict.size + len_to_move, LZ_DICT_SIZE);
-
-        let lz_buf_tight = d.lz.code_position > LZ_CODE_BUF_SIZE - 8;
-        let raw = d.params.flags & TDEFL_FORCE_ALL_RAW_BLOCKS != 0;
-        let fat = ((d.lz.code_position * 115) >> 7) >= d.lz.total_bytes as usize;
-        let fat_or_raw = (d.lz.total_bytes > 31 * 1024) && (fat || raw);
-
-        if lz_buf_tight || fat_or_raw {
-            d.params.src_pos = src_pos;
-            // These values are used in flush_block, so we need to write them back here.
-            d.dict.lookahead_size = lookahead_size;
-            d.dict.lookahead_pos = lookahead_pos;
-
-            let n = flush_block(d, callback, TDEFLFlush::None)
-                .unwrap_or(TDEFLStatus::PutBufFailed as i32);
-            if n != 0 {
-                d.params.saved_lit = saved_lit;
-                d.params.saved_match_dist = saved_match_dist;
-                d.params.saved_match_len = saved_match_len;
-                return n > 0;
-            }
-        }
-    }
-
-    d.params.src_pos = src_pos;
-    d.dict.lookahead_size = lookahead_size;
-    d.dict.lookahead_pos = lookahead_pos;
-    d.params.saved_lit = saved_lit;
-    d.params.saved_match_dist = saved_match_dist;
-    d.params.saved_match_len = saved_match_len;
-    true
-}
-
-const COMP_FAST_LOOKAHEAD_SIZE: usize = 4096;
-
-fn compress_fast(d: &mut CompressorOxide, callback: &mut CallbackOxide) -> bool {
-    let mut src_pos = d.params.src_pos;
-    let mut lookahead_size = d.dict.lookahead_size;
-    let mut lookahead_pos = d.dict.lookahead_pos;
-
-    let mut cur_pos = lookahead_pos & LZ_DICT_SIZE_MASK;
-    let in_buf = match callback.in_buf {
-        None => return true,
-        Some(in_buf) => in_buf,
-    };
-
-    debug_assert!(d.lz.code_position < LZ_CODE_BUF_SIZE - 2);
-
-    while src_pos < in_buf.len() || (d.params.flush != TDEFLFlush::None && lookahead_size > 0) {
-        let mut dst_pos = (lookahead_pos + lookahead_size) & LZ_DICT_SIZE_MASK;
-        let mut num_bytes_to_process = cmp::min(
-            in_buf.len() - src_pos,
-            COMP_FAST_LOOKAHEAD_SIZE - lookahead_size,
-        );
-        lookahead_size += num_bytes_to_process;
-
-        while num_bytes_to_process != 0 {
-            let n = cmp::min(LZ_DICT_SIZE - dst_pos, num_bytes_to_process);
-            d.dict.b.dict[dst_pos..dst_pos + n].copy_from_slice(&in_buf[src_pos..src_pos + n]);
-
-            if dst_pos < MAX_MATCH_LEN - 1 {
-                let m = cmp::min(n, MAX_MATCH_LEN - 1 - dst_pos);
-                d.dict.b.dict[dst_pos + LZ_DICT_SIZE..dst_pos + LZ_DICT_SIZE + m]
-                    .copy_from_slice(&in_buf[src_pos..src_pos + m]);
-            }
-
-            src_pos += n;
-            dst_pos = (dst_pos + n) & LZ_DICT_SIZE_MASK;
-            num_bytes_to_process -= n;
-        }
-
-        d.dict.size = cmp::min(LZ_DICT_SIZE - lookahead_size, d.dict.size);
-        if d.params.flush == TDEFLFlush::None && lookahead_size < COMP_FAST_LOOKAHEAD_SIZE {
-            break;
-        }
-
-        while lookahead_size >= 4 {
-            let mut cur_match_len = 1;
-
-            let first_trigram = d.dict.read_unaligned_u32(cur_pos) & 0xFF_FFFF;
-
-            let hash = (first_trigram ^ (first_trigram >> (24 - (LZ_HASH_BITS - 8))))
-                & LEVEL1_HASH_SIZE_MASK;
-
-            let mut probe_pos = usize::from(d.dict.b.hash[hash as usize]);
-            d.dict.b.hash[hash as usize] = lookahead_pos as u16;
-
-            let mut cur_match_dist = (lookahead_pos - probe_pos) as u16;
-            if cur_match_dist as usize <= d.dict.size {
-                probe_pos &= LZ_DICT_SIZE_MASK;
-
-                let trigram = d.dict.read_unaligned_u32(probe_pos) & 0xFF_FFFF;
-
-                if first_trigram == trigram {
-                    // Trigram was tested, so we can start with "+ 3" displacement.
-                    let mut p = cur_pos + 3;
-                    let mut q = probe_pos + 3;
-                    cur_match_len = (|| {
-                        for _ in 0..32 {
-                            let p_data: u64 = d.dict.read_unaligned_u64(p);
-                            let q_data: u64 = d.dict.read_unaligned_u64(q);
-                            let xor_data = p_data ^ q_data;
-                            if xor_data == 0 {
-                                p += 8;
-                                q += 8;
-                            } else {
-                                let trailing = xor_data.trailing_zeros();
-                                return p as u32 - cur_pos as u32 + (trailing >> 3);
-                            }
-                        }
-
-                        if cur_match_dist == 0 {
-                            0
-                        } else {
-                            MAX_MATCH_LEN as u32
-                        }
-                    })();
-
-                    if cur_match_len < MIN_MATCH_LEN.into()
-                        || (cur_match_len == MIN_MATCH_LEN.into() && cur_match_dist >= 8 * 1024)
-                    {
-                        let lit = first_trigram as u8;
-                        cur_match_len = 1;
-                        d.lz.write_code(lit);
-                        *d.lz.get_flag() >>= 1;
-                        d.huff.count[0][lit as usize] += 1;
-                    } else {
-                        // Limit the match to the length of the lookahead so we don't create a match
-                        // that ends after the end of the input data.
-                        cur_match_len = cmp::min(cur_match_len, lookahead_size as u32);
-                        debug_assert!(cur_match_len >= MIN_MATCH_LEN.into());
-                        debug_assert!(cur_match_dist >= 1);
-                        debug_assert!(cur_match_dist as usize <= LZ_DICT_SIZE);
-                        cur_match_dist -= 1;
-
-                        d.lz.write_code((cur_match_len - u32::from(MIN_MATCH_LEN)) as u8);
-                        d.lz.write_code(cur_match_dist as u8);
-                        d.lz.write_code((cur_match_dist >> 8) as u8);
-
-                        *d.lz.get_flag() >>= 1;
-                        *d.lz.get_flag() |= 0x80;
-                        if cur_match_dist < 512 {
-                            d.huff.count[1][SMALL_DIST_SYM[cur_match_dist as usize] as usize] += 1;
-                        } else {
-                            d.huff.count[1]
-                                [LARGE_DIST_SYM[(cur_match_dist >> 8) as usize] as usize] += 1;
-                        }
-
-                        d.huff.count[0][LEN_SYM[(cur_match_len - u32::from(MIN_MATCH_LEN)) as usize]
-                            as usize] += 1;
-                    }
-                } else {
-                    d.lz.write_code(first_trigram as u8);
-                    *d.lz.get_flag() >>= 1;
-                    d.huff.count[0][first_trigram as u8 as usize] += 1;
-                }
-
-                d.lz.consume_flag();
-                d.lz.total_bytes += cur_match_len;
-                lookahead_pos += cur_match_len as usize;
-                d.dict.size = cmp::min(d.dict.size + cur_match_len as usize, LZ_DICT_SIZE);
-                cur_pos = (cur_pos + cur_match_len as usize) & LZ_DICT_SIZE_MASK;
-                lookahead_size -= cur_match_len as usize;
-
-                if d.lz.code_position > LZ_CODE_BUF_SIZE - 8 {
-                    // These values are used in flush_block, so we need to write them back here.
-                    d.dict.lookahead_size = lookahead_size;
-                    d.dict.lookahead_pos = lookahead_pos;
-
-                    let n = match flush_block(d, callback, TDEFLFlush::None) {
-                        Err(_) => {
-                            d.params.src_pos = src_pos;
-                            d.params.prev_return_status = TDEFLStatus::PutBufFailed;
-                            return false;
-                        }
-                        Ok(status) => status,
-                    };
-                    if n != 0 {
-                        d.params.src_pos = src_pos;
-                        return n > 0;
-                    }
-                    debug_assert!(d.lz.code_position < LZ_CODE_BUF_SIZE - 2);
-
-                    lookahead_size = d.dict.lookahead_size;
-                    lookahead_pos = d.dict.lookahead_pos;
-                }
-            }
-        }
-
-        while lookahead_size != 0 {
-            let lit = d.dict.b.dict[cur_pos];
-            d.lz.total_bytes += 1;
-            d.lz.write_code(lit);
-            *d.lz.get_flag() >>= 1;
-            d.lz.consume_flag();
-
-            d.huff.count[0][lit as usize] += 1;
-            lookahead_pos += 1;
-            d.dict.size = cmp::min(d.dict.size + 1, LZ_DICT_SIZE);
-            cur_pos = (cur_pos + 1) & LZ_DICT_SIZE_MASK;
-            lookahead_size -= 1;
-
-            if d.lz.code_position > LZ_CODE_BUF_SIZE - 8 {
-                // These values are used in flush_block, so we need to write them back here.
-                d.dict.lookahead_size = lookahead_size;
-                d.dict.lookahead_pos = lookahead_pos;
-
-                let n = match flush_block(d, callback, TDEFLFlush::None) {
-                    Err(_) => {
-                        d.params.prev_return_status = TDEFLStatus::PutBufFailed;
-                        d.params.src_pos = src_pos;
-                        return false;
-                    }
-                    Ok(status) => status,
-                };
-                if n != 0 {
-                    d.params.src_pos = src_pos;
-                    return n > 0;
-                }
-
-                lookahead_size = d.dict.lookahead_size;
-                lookahead_pos = d.dict.lookahead_pos;
-            }
-        }
-    }
-
-    d.params.src_pos = src_pos;
-    d.dict.lookahead_size = lookahead_size;
-    d.dict.lookahead_pos = lookahead_pos;
-    true
-}
-
-fn flush_output_buffer(c: &mut CallbackOxide, p: &mut ParamsOxide) -> (TDEFLStatus, usize, usize) {
-    let mut res = (TDEFLStatus::Okay, p.src_pos, 0);
-    if let CallbackOut::Buf(ref mut cb) = c.out {
-        let n = cmp::min(cb.out_buf.len() - p.out_buf_ofs, p.flush_remaining as usize);
-        if n != 0 {
-            cb.out_buf[p.out_buf_ofs..p.out_buf_ofs + n]
-                .copy_from_slice(&p.local_buf.b[p.flush_ofs as usize..p.flush_ofs as usize + n]);
-        }
-        p.flush_ofs += n as u32;
-        p.flush_remaining -= n as u32;
-        p.out_buf_ofs += n;
-        res.2 = p.out_buf_ofs;
-    }
-
-    if p.finished && p.flush_remaining == 0 {
-        res.0 = TDEFLStatus::Done
-    }
-    res
-}
-
-/// Main compression function. Tries to compress as much as possible from `in_buf` and
-/// puts compressed output into `out_buf`.
-///
-/// The value of `flush` determines if the compressor should attempt to flush all output
-/// and alternatively try to finish the stream.
-///
-/// Use [`TDEFLFlush::Finish`] on the final call to signal that the stream is finishing.
-///
-/// Note that this function does not keep track of whether a flush marker has been output, so
-/// if called using [`TDEFLFlush::Sync`], the caller needs to ensure there is enough space in the
-/// output buffer if they want to avoid repeated flush markers.
-/// See #105 for details.
-///
-/// # Returns
-/// Returns a tuple containing the current status of the compressor, the current position
-/// in the input buffer and the current position in the output buffer.
-pub fn compress(
-    d: &mut CompressorOxide,
-    in_buf: &[u8],
-    out_buf: &mut [u8],
-    flush: TDEFLFlush,
-) -> (TDEFLStatus, usize, usize) {
-    compress_inner(
-        d,
-        &mut CallbackOxide::new_callback_buf(in_buf, out_buf),
-        flush,
-    )
-}
-
-/// Main compression function. Callbacks output.
-///
-/// # Returns
-/// Returns a tuple containing the current status of the compressor, the current position
-/// in the input buffer.
-///
-/// The caller is responsible for ensuring the `CallbackFunc` struct will not cause undefined
-/// behaviour.
-pub fn compress_to_output(
-    d: &mut CompressorOxide,
-    in_buf: &[u8],
-    flush: TDEFLFlush,
-    mut callback_func: impl FnMut(&[u8]) -> bool,
-) -> (TDEFLStatus, usize) {
-    let res = compress_inner(
-        d,
-        &mut CallbackOxide::new_callback_func(
-            in_buf,
-            CallbackFunc {
-                put_buf_func: &mut callback_func,
-            },
-        ),
-        flush,
-    );
-
-    (res.0, res.1)
-}
-
-fn compress_inner(
-    d: &mut CompressorOxide,
-    callback: &mut CallbackOxide,
-    flush: TDEFLFlush,
-) -> (TDEFLStatus, usize, usize) {
-    d.params.out_buf_ofs = 0;
-    d.params.src_pos = 0;
-
-    let prev_ok = d.params.prev_return_status == TDEFLStatus::Okay;
-    let flush_finish_once = d.params.flush != TDEFLFlush::Finish || flush == TDEFLFlush::Finish;
-
-    d.params.flush = flush;
-    if !prev_ok || !flush_finish_once {
-        d.params.prev_return_status = TDEFLStatus::BadParam;
-        return (d.params.prev_return_status, 0, 0);
-    }
-
-    if d.params.flush_remaining != 0 || d.params.finished {
-        let res = flush_output_buffer(callback, &mut d.params);
-        d.params.prev_return_status = res.0;
-        return res;
-    }
-
-    let one_probe = d.params.flags & MAX_PROBES_MASK as u32 == 1;
-    let greedy = d.params.flags & TDEFL_GREEDY_PARSING_FLAG != 0;
-    let filter_or_rle_or_raw = d.params.flags
-        & (TDEFL_FILTER_MATCHES | TDEFL_FORCE_ALL_RAW_BLOCKS | TDEFL_RLE_MATCHES)
-        != 0;
-
-    let compress_success = if one_probe && greedy && !filter_or_rle_or_raw {
-        compress_fast(d, callback)
-    } else {
-        compress_normal(d, callback)
-    };
-
-    if !compress_success {
-        return (
-            d.params.prev_return_status,
-            d.params.src_pos,
-            d.params.out_buf_ofs,
-        );
-    }
-
-    if let Some(in_buf) = callback.in_buf {
-        if d.params.flags & (TDEFL_WRITE_ZLIB_HEADER | TDEFL_COMPUTE_ADLER32) != 0 {
-            d.params.adler32 = update_adler32(d.params.adler32, &in_buf[..d.params.src_pos]);
-        }
-    }
-
-    let flush_none = d.params.flush == TDEFLFlush::None;
-    let in_left = callback.in_buf.map_or(0, |buf| buf.len()) - d.params.src_pos;
-    let remaining = in_left != 0 || d.params.flush_remaining != 0;
-    if !flush_none && d.dict.lookahead_size == 0 && !remaining {
-        let flush = d.params.flush;
-        match flush_block(d, callback, flush) {
-            Err(_) => {
-                d.params.prev_return_status = TDEFLStatus::PutBufFailed;
-                return (
-                    d.params.prev_return_status,
-                    d.params.src_pos,
-                    d.params.out_buf_ofs,
-                );
-            }
-            Ok(x) if x < 0 => {
-                return (
-                    d.params.prev_return_status,
-                    d.params.src_pos,
-                    d.params.out_buf_ofs,
-                )
-            }
-            _ => {
-                d.params.finished = d.params.flush == TDEFLFlush::Finish;
-                if d.params.flush == TDEFLFlush::Full {
-                    memset(&mut d.dict.b.hash[..], 0);
-                    memset(&mut d.dict.b.next[..], 0);
-                    d.dict.size = 0;
-                }
-            }
-        }
-    }
-
-    let res = flush_output_buffer(callback, &mut d.params);
-    d.params.prev_return_status = res.0;
-
-    res
-}
-
-/// Create a set of compression flags using parameters used by zlib and other compressors.
-/// Mainly intended for use with transition from c libraries as it deals with raw integers.
-///
-/// # Parameters
-/// `level` determines compression level. Clamped to maximum of 10. Negative values result in
-/// `CompressionLevel::DefaultLevel`.
-/// `window_bits`: Above 0, wraps the stream in a zlib wrapper, 0 or negative for a raw deflate
-/// stream.
-/// `strategy`: Sets the strategy if this conforms to any of the values in `CompressionStrategy`.
-///
-/// # Notes
-/// This function may be removed or moved to the `miniz_oxide_c_api` in the future.
-pub fn create_comp_flags_from_zip_params(level: i32, window_bits: i32, strategy: i32) -> u32 {
-    let num_probes = (if level >= 0 {
-        cmp::min(10, level)
-    } else {
-        CompressionLevel::DefaultLevel as i32
-    }) as usize;
-    let greedy = if level <= 3 {
-        TDEFL_GREEDY_PARSING_FLAG
-    } else {
-        0
-    };
-    let mut comp_flags = NUM_PROBES[num_probes] | greedy;
-
-    if window_bits > 0 {
-        comp_flags |= TDEFL_WRITE_ZLIB_HEADER;
-    }
-
-    if level == 0 {
-        comp_flags |= TDEFL_FORCE_ALL_RAW_BLOCKS;
-    } else if strategy == CompressionStrategy::Filtered as i32 {
-        comp_flags |= TDEFL_FILTER_MATCHES;
-    } else if strategy == CompressionStrategy::HuffmanOnly as i32 {
-        comp_flags &= !MAX_PROBES_MASK as u32;
-    } else if strategy == CompressionStrategy::Fixed as i32 {
-        comp_flags |= TDEFL_FORCE_ALL_STATIC_BLOCKS;
-    } else if strategy == CompressionStrategy::RLE as i32 {
-        comp_flags |= TDEFL_RLE_MATCHES;
-    }
-
-    comp_flags
-}
-
-#[cfg(test)]
-mod test {
-    use super::{
-        compress_to_output, create_comp_flags_from_zip_params, read_u16_le, write_u16_le,
-        CompressionStrategy, CompressorOxide, TDEFLFlush, TDEFLStatus, DEFAULT_FLAGS,
-        MZ_DEFAULT_WINDOW_BITS,
-    };
-    use crate::inflate::decompress_to_vec;
-    use alloc::vec;
-
-    #[test]
-    fn u16_to_slice() {
-        let mut slice = [0, 0];
-        write_u16_le(2000, &mut slice, 0);
-        assert_eq!(slice, [208, 7]);
-    }
-
-    #[test]
-    fn u16_from_slice() {
-        let slice = [208, 7];
-        assert_eq!(read_u16_le(&slice, 0), 2000);
-    }
-
-    #[test]
-    fn compress_output() {
-        assert_eq!(
-            DEFAULT_FLAGS,
-            create_comp_flags_from_zip_params(
-                4,
-                MZ_DEFAULT_WINDOW_BITS,
-                CompressionStrategy::Default as i32
-            )
-        );
-
-        let slice = [
-            1, 2, 3, 4, 1, 2, 3, 1, 2, 3, 1, 2, 6, 1, 2, 3, 1, 2, 3, 2, 3, 1, 2, 3,
-        ];
-        let mut encoded = vec![];
-        let flags = create_comp_flags_from_zip_params(6, 0, 0);
-        let mut d = CompressorOxide::new(flags);
-        let (status, in_consumed) =
-            compress_to_output(&mut d, &slice, TDEFLFlush::Finish, |out: &[u8]| {
-                encoded.extend_from_slice(out);
-                true
-            });
-
-        assert_eq!(status, TDEFLStatus::Done);
-        assert_eq!(in_consumed, slice.len());
-
-        let decoded = decompress_to_vec(&encoded[..]).unwrap();
-        assert_eq!(&decoded[..], &slice[..]);
-    }
-
-    #[test]
-    /// Check fast compress mode
-    fn compress_fast() {
-        let slice = [
-            1, 2, 3, 4, 1, 2, 3, 1, 2, 3, 1, 2, 6, 1, 2, 3, 1, 2, 3, 2, 3, 1, 2, 3,
-        ];
-        let mut encoded = vec![];
-        let flags = create_comp_flags_from_zip_params(1, 0, 0);
-        let mut d = CompressorOxide::new(flags);
-        let (status, in_consumed) =
-            compress_to_output(&mut d, &slice, TDEFLFlush::Finish, |out: &[u8]| {
-                encoded.extend_from_slice(out);
-                true
-            });
-
-        assert_eq!(status, TDEFLStatus::Done);
-        assert_eq!(in_consumed, slice.len());
-
-        // Needs to be altered if algorithm improves.
-        assert_eq!(
-            &encoded[..],
-            [99, 100, 98, 102, 1, 98, 48, 98, 3, 147, 204, 76, 204, 140, 76, 204, 0]
-        );
-
-        let decoded = decompress_to_vec(&encoded[..]).unwrap();
-        assert_eq!(&decoded[..], &slice[..]);
-    }
-}
diff --git a/third_party/rust/chromium_crates_io/vendor/miniz_oxide-0.7.4/src/deflate/mod.rs b/third_party/rust/chromium_crates_io/vendor/miniz_oxide-0.7.4/src/deflate/mod.rs
deleted file mode 100644
index f36f28c8c06ecb..00000000000000
--- a/third_party/rust/chromium_crates_io/vendor/miniz_oxide-0.7.4/src/deflate/mod.rs
+++ /dev/null
@@ -1,226 +0,0 @@
-//! This module contains functionality for compression.
-
-use crate::alloc::vec;
-use crate::alloc::vec::Vec;
-
-mod buffer;
-pub mod core;
-pub mod stream;
-use self::core::*;
-
-/// How much processing the compressor should do to compress the data.
-/// `NoCompression` and `Bestspeed` have special meanings, the other levels determine the number
-/// of checks for matches in the hash chains and whether to use lazy or greedy parsing.
-#[repr(i32)]
-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
-pub enum CompressionLevel {
-    /// Don't do any compression, only output uncompressed blocks.
-    NoCompression = 0,
-    /// Fast compression. Uses a special compression routine that is optimized for speed.
-    BestSpeed = 1,
-    /// Slow/high compression. Do a lot of checks to try to find good matches.
-    BestCompression = 9,
-    /// Even more checks, can be very slow.
-    UberCompression = 10,
-    /// Default compromise between speed and compression.
-    DefaultLevel = 6,
-    /// Use the default compression level.
-    DefaultCompression = -1,
-}
-
-// Missing safe rust analogue (this and mem-to-mem are quite similar)
-/*
-fn tdefl_compress(
-    d: Option<&mut CompressorOxide>,
-    in_buf: *const c_void,
-    in_size: Option<&mut usize>,
-    out_buf: *mut c_void,
-    out_size: Option<&mut usize>,
-    flush: TDEFLFlush,
-) -> TDEFLStatus {
-    let res = match d {
-        None => {
-            in_size.map(|size| *size = 0);
-            out_size.map(|size| *size = 0);
-            (TDEFLStatus::BadParam, 0, 0)
-        },
-        Some(compressor) => {
-            let callback_res = CallbackOxide::new(
-                compressor.callback_func.clone(),
-                in_buf,
-                in_size,
-                out_buf,
-                out_size,
-            );
-
-            if let Ok(mut callback) = callback_res {
-                let res = compress(compressor, &mut callback, flush);
-                callback.update_size(Some(res.1), Some(res.2));
-                res
-            } else {
-                (TDEFLStatus::BadParam, 0, 0)
-            }
-        }
-    };
-    res.0
-}*/
-
-// Missing safe rust analogue
-/*
-fn tdefl_init(
-    d: Option<&mut CompressorOxide>,
-    put_buf_func: PutBufFuncPtr,
-    put_buf_user: *mut c_void,
-    flags: c_int,
-) -> TDEFLStatus {
-    if let Some(d) = d {
-        *d = CompressorOxide::new(
-            put_buf_func.map(|func|
-                CallbackFunc { put_buf_func: func, put_buf_user: put_buf_user }
-            ),
-            flags as u32,
-        );
-        TDEFLStatus::Okay
-    } else {
-        TDEFLStatus::BadParam
-    }
-}*/
-
-// Missing safe rust analogue (though maybe best served by flate2 front-end instead)
-/*
-fn tdefl_compress_mem_to_output(
-    buf: *const c_void,
-    buf_len: usize,
-    put_buf_func: PutBufFuncPtr,
-    put_buf_user: *mut c_void,
-    flags: c_int,
-) -> bool*/
-
-// Missing safe Rust analogue
-/*
-fn tdefl_compress_mem_to_mem(
-    out_buf: *mut c_void,
-    out_buf_len: usize,
-    src_buf: *const c_void,
-    src_buf_len: usize,
-    flags: c_int,
-) -> usize*/
-
-/// Compress the input data to a vector, using the specified compression level (0-10).
-pub fn compress_to_vec(input: &[u8], level: u8) -> Vec<u8> {
-    compress_to_vec_inner(input, level, 0, 0)
-}
-
-/// Compress the input data to a vector, using the specified compression level (0-10), and with a
-/// zlib wrapper.
-pub fn compress_to_vec_zlib(input: &[u8], level: u8) -> Vec<u8> {
-    compress_to_vec_inner(input, level, 1, 0)
-}
-
-/// Simple function to compress data to a vec.
-fn compress_to_vec_inner(mut input: &[u8], level: u8, window_bits: i32, strategy: i32) -> Vec<u8> {
-    // The comp flags function sets the zlib flag if the window_bits parameter is > 0.
-    let flags = create_comp_flags_from_zip_params(level.into(), window_bits, strategy);
-    let mut compressor = CompressorOxide::new(flags);
-    let mut output = vec![0; ::core::cmp::max(input.len() / 2, 2)];
-
-    let mut out_pos = 0;
-    loop {
-        let (status, bytes_in, bytes_out) = compress(
-            &mut compressor,
-            input,
-            &mut output[out_pos..],
-            TDEFLFlush::Finish,
-        );
-        out_pos += bytes_out;
-
-        match status {
-            TDEFLStatus::Done => {
-                output.truncate(out_pos);
-                break;
-            }
-            TDEFLStatus::Okay if bytes_in <= input.len() => {
-                input = &input[bytes_in..];
-
-                // We need more space, so resize the vector.
-                if output.len().saturating_sub(out_pos) < 30 {
-                    output.resize(output.len() * 2, 0)
-                }
-            }
-            // Not supposed to happen unless there is a bug.
-            _ => panic!("Bug! Unexpectedly failed to compress!"),
-        }
-    }
-
-    output
-}
-
-#[cfg(test)]
-mod test {
-    use super::{compress_to_vec, compress_to_vec_inner, CompressionStrategy};
-    use crate::inflate::decompress_to_vec;
-    use alloc::vec;
-
-    /// Test deflate example.
-    ///
-    /// Check if the encoder produces the same code as the example given by Mark Adler here:
-    /// https://stackoverflow.com/questions/17398931/deflate-encoding-with-static-huffman-codes/17415203
-    #[test]
-    fn compress_small() {
-        let test_data = b"Deflate late";
-        let check = [
-            0x73, 0x49, 0x4d, 0xcb, 0x49, 0x2c, 0x49, 0x55, 0x00, 0x11, 0x00,
-        ];
-
-        let res = compress_to_vec(test_data, 1);
-        assert_eq!(&check[..], res.as_slice());
-
-        let res = compress_to_vec(test_data, 9);
-        assert_eq!(&check[..], res.as_slice());
-    }
-
-    #[test]
-    fn compress_huff_only() {
-        let test_data = b"Deflate late";
-
-        let res = compress_to_vec_inner(test_data, 1, 0, CompressionStrategy::HuffmanOnly as i32);
-        let d = decompress_to_vec(res.as_slice()).expect("Failed to decompress!");
-        assert_eq!(test_data, d.as_slice());
-    }
-
-    /// Test that a raw block compresses fine.
-    #[test]
-    fn compress_raw() {
-        let text = b"Hello, zlib!";
-        let encoded = {
-            let len = text.len();
-            let notlen = !len;
-            let mut encoded = vec![
-                1,
-                len as u8,
-                (len >> 8) as u8,
-                notlen as u8,
-                (notlen >> 8) as u8,
-            ];
-            encoded.extend_from_slice(&text[..]);
-            encoded
-        };
-
-        let res = compress_to_vec(text, 0);
-        assert_eq!(encoded, res.as_slice());
-    }
-
-    #[test]
-    fn short() {
-        let test_data = [10, 10, 10, 10, 10, 55];
-        let c = compress_to_vec(&test_data, 9);
-
-        let d = decompress_to_vec(c.as_slice()).expect("Failed to decompress!");
-        assert_eq!(&test_data, d.as_slice());
-        // Check that a static block is used here, rather than a raw block
-        // , so the data is actually compressed.
-        // (The optimal compressed length would be 5, but neither miniz nor zlib manages that either
-        // as neither checks matches against the byte at index 0.)
-        assert!(c.len() <= 6);
-    }
-}
diff --git a/third_party/rust/chromium_crates_io/vendor/miniz_oxide-0.7.4/src/deflate/stream.rs b/third_party/rust/chromium_crates_io/vendor/miniz_oxide-0.7.4/src/deflate/stream.rs
deleted file mode 100644
index 39aa82d924fed5..00000000000000
--- a/third_party/rust/chromium_crates_io/vendor/miniz_oxide-0.7.4/src/deflate/stream.rs
+++ /dev/null
@@ -1,121 +0,0 @@
-//! Extra streaming compression functionality.
-//!
-//! As of now this is mainly intended for use to build a higher-level wrapper.
-//!
-//! There is no DeflateState as the needed state is contained in the compressor struct itself.
-
-use crate::deflate::core::{compress, CompressorOxide, TDEFLFlush, TDEFLStatus};
-use crate::{MZError, MZFlush, MZStatus, StreamResult};
-
-/// Try to compress from input to output with the given [`CompressorOxide`].
-///
-/// # Errors
-///
-/// Returns [`MZError::Buf`] If the size of the `output` slice is empty or no progress was made due
-/// to lack of expected input data, or if called without [`MZFlush::Finish`] after the compression
-/// was already finished.
-///
-/// Returns [`MZError::Param`] if the compressor parameters are set wrong.
-///
-/// Returns [`MZError::Stream`] when lower-level decompressor returns a
-/// [`TDEFLStatus::PutBufFailed`]; may not actually be possible.
-pub fn deflate(
-    compressor: &mut CompressorOxide,
-    input: &[u8],
-    output: &mut [u8],
-    flush: MZFlush,
-) -> StreamResult {
-    if output.is_empty() {
-        return StreamResult::error(MZError::Buf);
-    }
-
-    if compressor.prev_return_status() == TDEFLStatus::Done {
-        return if flush == MZFlush::Finish {
-            StreamResult {
-                bytes_written: 0,
-                bytes_consumed: 0,
-                status: Ok(MZStatus::StreamEnd),
-            }
-        } else {
-            StreamResult::error(MZError::Buf)
-        };
-    }
-
-    let mut bytes_written = 0;
-    let mut bytes_consumed = 0;
-
-    let mut next_in = input;
-    let mut next_out = output;
-
-    let status = loop {
-        let in_bytes;
-        let out_bytes;
-        let defl_status = {
-            let res = compress(compressor, next_in, next_out, TDEFLFlush::from(flush));
-            in_bytes = res.1;
-            out_bytes = res.2;
-            res.0
-        };
-
-        next_in = &next_in[in_bytes..];
-        next_out = &mut next_out[out_bytes..];
-        bytes_consumed += in_bytes;
-        bytes_written += out_bytes;
-
-        // Check if we are done, or compression failed.
-        match defl_status {
-            TDEFLStatus::BadParam => break Err(MZError::Param),
-            // Don't think this can happen as we're not using a custom callback.
-            TDEFLStatus::PutBufFailed => break Err(MZError::Stream),
-            TDEFLStatus::Done => break Ok(MZStatus::StreamEnd),
-            _ => (),
-        };
-
-        // All the output space was used, so wait for more.
-        if next_out.is_empty() {
-            break Ok(MZStatus::Ok);
-        }
-
-        if next_in.is_empty() && (flush != MZFlush::Finish) {
-            let total_changed = bytes_written > 0 || bytes_consumed > 0;
-
-            break if (flush != MZFlush::None) || total_changed {
-                // We wrote or consumed something, and/or did a flush (sync/partial etc.).
-                Ok(MZStatus::Ok)
-            } else {
-                // No more input data, not flushing, and nothing was consumed or written,
-                // so couldn't make any progress.
-                Err(MZError::Buf)
-            };
-        }
-    };
-    StreamResult {
-        bytes_consumed,
-        bytes_written,
-        status,
-    }
-}
-
-#[cfg(test)]
-mod test {
-    use super::deflate;
-    use crate::deflate::CompressorOxide;
-    use crate::inflate::decompress_to_vec_zlib;
-    use crate::{MZFlush, MZStatus};
-    use alloc::boxed::Box;
-    use alloc::vec;
-
-    #[test]
-    fn test_state() {
-        let data = b"Hello zlib!";
-        let mut compressed = vec![0; 50];
-        let mut compressor = Box::<CompressorOxide>::default();
-        let res = deflate(&mut compressor, data, &mut compressed, MZFlush::Finish);
-        let status = res.status.expect("Failed to compress!");
-        let decomp =
-            decompress_to_vec_zlib(&compressed).expect("Failed to decompress compressed data");
-        assert_eq!(status, MZStatus::StreamEnd);
-        assert_eq!(decomp[..], data[..]);
-        assert_eq!(res.bytes_consumed, data.len());
-    }
-}
diff --git a/third_party/rust/chromium_crates_io/vendor/miniz_oxide-0.7.4/src/inflate/core.rs b/third_party/rust/chromium_crates_io/vendor/miniz_oxide-0.7.4/src/inflate/core.rs
deleted file mode 100644
index d9a4950b488d19..00000000000000
--- a/third_party/rust/chromium_crates_io/vendor/miniz_oxide-0.7.4/src/inflate/core.rs
+++ /dev/null
@@ -1,2052 +0,0 @@
-//! Streaming decompression functionality.
-
-use super::*;
-use crate::shared::{update_adler32, HUFFMAN_LENGTH_ORDER};
-use ::core::cell::Cell;
-
-use ::core::convert::TryInto;
-use ::core::{cmp, slice};
-
-use self::output_buffer::OutputBuffer;
-
-pub const TINFL_LZ_DICT_SIZE: usize = 32_768;
-
-/// A struct containing huffman code lengths and the huffman code tree used by the decompressor.
-struct HuffmanTable {
-    /// Length of the code at each index.
-    pub code_size: [u8; MAX_HUFF_SYMBOLS_0],
-    /// Fast lookup table for shorter huffman codes.
-    ///
-    /// See `HuffmanTable::fast_lookup`.
-    pub look_up: [i16; FAST_LOOKUP_SIZE as usize],
-    /// Full huffman tree.
-    ///
-    /// Positive values are edge nodes/symbols, negative values are
-    /// parent nodes/references to other nodes.
-    pub tree: [i16; MAX_HUFF_TREE_SIZE],
-}
-
-impl HuffmanTable {
-    const fn new() -> HuffmanTable {
-        HuffmanTable {
-            code_size: [0; MAX_HUFF_SYMBOLS_0],
-            look_up: [0; FAST_LOOKUP_SIZE as usize],
-            tree: [0; MAX_HUFF_TREE_SIZE],
-        }
-    }
-
-    /// Look for a symbol in the fast lookup table.
-    /// The symbol is stored in the lower 9 bits, the length in the next 6.
-    /// If the returned value is negative, the code wasn't found in the
-    /// fast lookup table and the full tree has to be traversed to find the code.
-    #[inline]
-    fn fast_lookup(&self, bit_buf: BitBuffer) -> i16 {
-        self.look_up[(bit_buf & BitBuffer::from(FAST_LOOKUP_SIZE - 1)) as usize]
-    }
-
-    /// Get the symbol and the code length from the huffman tree.
-    #[inline]
-    fn tree_lookup(&self, fast_symbol: i32, bit_buf: BitBuffer, mut code_len: u32) -> (i32, u32) {
-        let mut symbol = fast_symbol;
-        // We step through the tree until we encounter a positive value, which indicates a
-        // symbol.
-        loop {
-            // symbol here indicates the position of the left (0) node, if the next bit is 1
-            // we add 1 to the lookup position to get the right node.
-            let tree_index = (!symbol + ((bit_buf >> code_len) & 1) as i32) as usize;
-            debug_assert!(tree_index < self.tree.len());
-            if tree_index >= self.tree.len() {
-                break;
-            }
-            symbol = i32::from(self.tree[tree_index]);
-            code_len += 1;
-            if symbol >= 0 {
-                break;
-            }
-        }
-        (symbol, code_len)
-    }
-
-    #[inline]
-    /// Look up a symbol and code length from the bits in the provided bit buffer.
-    ///
-    /// Returns Some(symbol, length) on success,
-    /// None if the length is 0.
-    ///
-    /// It's possible we could avoid checking for 0 if we can guarantee a sane table.
-    /// TODO: Check if a smaller type for code_len helps performance.
-    fn lookup(&self, bit_buf: BitBuffer) -> Option<(i32, u32)> {
-        let symbol = self.fast_lookup(bit_buf).into();
-        if symbol >= 0 {
-            if (symbol >> 9) as u32 != 0 {
-                Some((symbol, (symbol >> 9) as u32))
-            } else {
-                // Zero-length code.
-                None
-            }
-        } else {
-            // We didn't get a symbol from the fast lookup table, so check the tree instead.
-            Some(self.tree_lookup(symbol, bit_buf, FAST_LOOKUP_BITS.into()))
-        }
-    }
-}
-
-/// The number of huffman tables used.
-const MAX_HUFF_TABLES: usize = 3;
-/// The length of the first (literal/length) huffman table.
-const MAX_HUFF_SYMBOLS_0: usize = 288;
-/// The length of the second (distance) huffman table.
-const MAX_HUFF_SYMBOLS_1: usize = 32;
-/// The length of the last (huffman code length) huffman table.
-const _MAX_HUFF_SYMBOLS_2: usize = 19;
-/// The maximum length of a code that can be looked up in the fast lookup table.
-const FAST_LOOKUP_BITS: u8 = 10;
-/// The size of the fast lookup table.
-const FAST_LOOKUP_SIZE: u32 = 1 << FAST_LOOKUP_BITS;
-const MAX_HUFF_TREE_SIZE: usize = MAX_HUFF_SYMBOLS_0 * 2;
-const LITLEN_TABLE: usize = 0;
-const DIST_TABLE: usize = 1;
-const HUFFLEN_TABLE: usize = 2;
-
-/// Flags to [`decompress()`] to control how inflation works.
-///
-/// These define bits for a bitmask argument.
-pub mod inflate_flags {
-    /// Should we try to parse a zlib header?
-    ///
-    /// If unset, the function will expect an RFC1951 deflate stream.  If set, it will expect a
-    /// RFC1950 zlib wrapper around the deflate stream.
-    pub const TINFL_FLAG_PARSE_ZLIB_HEADER: u32 = 1;
-
-    /// There will be more input that hasn't been given to the decompressor yet.
-    ///
-    /// This is useful when you want to decompress what you have so far,
-    /// even if you know there is probably more input that hasn't gotten here yet (_e.g._, over a
-    /// network connection).  When [`decompress()`][super::decompress] reaches the end of the input
-    /// without finding the end of the compressed stream, it will return
-    /// [`TINFLStatus::NeedsMoreInput`][super::TINFLStatus::NeedsMoreInput] if this is set,
-    /// indicating that you should get more data before calling again.  If not set, it will return
-    /// [`TINFLStatus::FailedCannotMakeProgress`][super::TINFLStatus::FailedCannotMakeProgress]
-    /// suggesting the stream is corrupt, since you claimed it was all there.
-    pub const TINFL_FLAG_HAS_MORE_INPUT: u32 = 2;
-
-    /// The output buffer should not wrap around.
-    pub const TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF: u32 = 4;
-
-    /// Calculate the adler32 checksum of the output data even if we're not inflating a zlib stream.
-    ///
-    /// If [`TINFL_FLAG_IGNORE_ADLER32`] is specified, it will override this.
-    ///
-    /// NOTE: Enabling/disabling this between calls to decompress will result in an incorrect
-    /// checksum.
-    pub const TINFL_FLAG_COMPUTE_ADLER32: u32 = 8;
-
-    /// Ignore adler32 checksum even if we are inflating a zlib stream.
-    ///
-    /// Overrides [`TINFL_FLAG_COMPUTE_ADLER32`] if both are enabled.
-    ///
-    /// NOTE: This flag does not exist in miniz as it does not support this and is a
-    /// custom addition for miniz_oxide.
-    ///
-    /// NOTE: Should not be changed from enabled to disabled after decompression has started,
-    /// this will result in checksum failure (outside the unlikely event where the checksum happens
-    /// to match anyway).
-    pub const TINFL_FLAG_IGNORE_ADLER32: u32 = 64;
-}
-
-use self::inflate_flags::*;
-
-const MIN_TABLE_SIZES: [u16; 3] = [257, 1, 4];
-
-#[cfg(target_pointer_width = "64")]
-type BitBuffer = u64;
-
-#[cfg(not(target_pointer_width = "64"))]
-type BitBuffer = u32;
-
-/// Main decompression struct.
-///
-pub struct DecompressorOxide {
-    /// Current state of the decompressor.
-    state: core::State,
-    /// Number of bits in the bit buffer.
-    num_bits: u32,
-    /// Zlib CMF
-    z_header0: u32,
-    /// Zlib FLG
-    z_header1: u32,
-    /// Adler32 checksum from the zlib header.
-    z_adler32: u32,
-    /// 1 if the current block is the last block, 0 otherwise.
-    finish: u32,
-    /// The type of the current block.
-    block_type: u32,
-    /// 1 if the adler32 value should be checked.
-    check_adler32: u32,
-    /// Last match distance.
-    dist: u32,
-    /// Variable used for match length, symbols, and a number of other things.
-    counter: u32,
-    /// Number of extra bits for the last length or distance code.
-    num_extra: u32,
-    /// Number of entries in each huffman table.
-    table_sizes: [u32; MAX_HUFF_TABLES],
-    /// Buffer of input data.
-    bit_buf: BitBuffer,
-    /// Huffman tables.
-    tables: [HuffmanTable; MAX_HUFF_TABLES],
-    /// Raw block header.
-    raw_header: [u8; 4],
-    /// Huffman length codes.
-    len_codes: [u8; MAX_HUFF_SYMBOLS_0 + MAX_HUFF_SYMBOLS_1 + 137],
-}
-
-impl DecompressorOxide {
-    /// Create a new tinfl_decompressor with all fields set to 0.
-    pub fn new() -> DecompressorOxide {
-        DecompressorOxide::default()
-    }
-
-    /// Set the current state to `Start`.
-    #[inline]
-    pub fn init(&mut self) {
-        // The rest of the data is reset or overwritten when used.
-        self.state = core::State::Start;
-    }
-
-    /// Returns the adler32 checksum of the currently decompressed data.
-    /// Note: Will return Some(1) if decompressing zlib but ignoring adler32.
-    #[inline]
-    pub fn adler32(&self) -> Option<u32> {
-        if self.state != State::Start && !self.state.is_failure() && self.z_header0 != 0 {
-            Some(self.check_adler32)
-        } else {
-            None
-        }
-    }
-
-    /// Returns the adler32 that was read from the zlib header if it exists.
-    #[inline]
-    pub fn adler32_header(&self) -> Option<u32> {
-        if self.state != State::Start && self.state != State::BadZlibHeader && self.z_header0 != 0 {
-            Some(self.z_adler32)
-        } else {
-            None
-        }
-    }
-}
-
-impl Default for DecompressorOxide {
-    /// Create a new tinfl_decompressor with all fields set to 0.
-    #[inline(always)]
-    fn default() -> Self {
-        DecompressorOxide {
-            state: core::State::Start,
-            num_bits: 0,
-            z_header0: 0,
-            z_header1: 0,
-            z_adler32: 0,
-            finish: 0,
-            block_type: 0,
-            check_adler32: 0,
-            dist: 0,
-            counter: 0,
-            num_extra: 0,
-            table_sizes: [0; MAX_HUFF_TABLES],
-            bit_buf: 0,
-            // TODO:(oyvindln) Check that copies here are optimized out in release mode.
-            tables: [
-                HuffmanTable::new(),
-                HuffmanTable::new(),
-                HuffmanTable::new(),
-            ],
-            raw_header: [0; 4],
-            len_codes: [0; MAX_HUFF_SYMBOLS_0 + MAX_HUFF_SYMBOLS_1 + 137],
-        }
-    }
-}
-
-#[derive(Copy, Clone, PartialEq, Eq, Debug)]
-#[non_exhaustive]
-enum State {
-    Start = 0,
-    ReadZlibCmf,
-    ReadZlibFlg,
-    ReadBlockHeader,
-    BlockTypeNoCompression,
-    RawHeader,
-    RawMemcpy1,
-    RawMemcpy2,
-    ReadTableSizes,
-    ReadHufflenTableCodeSize,
-    ReadLitlenDistTablesCodeSize,
-    ReadExtraBitsCodeSize,
-    DecodeLitlen,
-    WriteSymbol,
-    ReadExtraBitsLitlen,
-    DecodeDistance,
-    ReadExtraBitsDistance,
-    RawReadFirstByte,
-    RawStoreFirstByte,
-    WriteLenBytesToEnd,
-    BlockDone,
-    HuffDecodeOuterLoop1,
-    HuffDecodeOuterLoop2,
-    ReadAdler32,
-
-    DoneForever,
-
-    // Failure states.
-    BlockTypeUnexpected,
-    BadCodeSizeSum,
-    BadDistOrLiteralTableLength,
-    BadTotalSymbols,
-    BadZlibHeader,
-    DistanceOutOfBounds,
-    BadRawLength,
-    BadCodeSizeDistPrevLookup,
-    InvalidLitlen,
-    InvalidDist,
-    InvalidCodeLen,
-}
-
-impl State {
-    fn is_failure(self) -> bool {
-        matches!(
-            self,
-            BlockTypeUnexpected
-                | BadCodeSizeSum
-                | BadDistOrLiteralTableLength
-                | BadTotalSymbols
-                | BadZlibHeader
-                | DistanceOutOfBounds
-                | BadRawLength
-                | BadCodeSizeDistPrevLookup
-                | InvalidLitlen
-                | InvalidDist
-        )
-    }
-
-    #[inline]
-    fn begin(&mut self, new_state: State) {
-        *self = new_state;
-    }
-}
-
-use self::State::*;
-
-// Not sure why miniz uses 32-bit values for these, maybe alignment/cache again?
-// # Optimization
-// We add a extra value at the end and make the tables 32 elements long
-// so we can use a mask to avoid bounds checks.
-// The invalid values are set to something high enough to avoid underflowing
-// the match length.
-/// Base length for each length code.
-///
-/// The base is used together with the value of the extra bits to decode the actual
-/// length/distance values in a match.
-#[rustfmt::skip]
-const LENGTH_BASE: [u16; 32] = [
-    3,  4,  5,  6,  7,  8,  9,  10,  11,  13,  15,  17,  19,  23,  27,  31,
-    35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 512, 512, 512
-];
-
-/// Number of extra bits for each length code.
-#[rustfmt::skip]
-const LENGTH_EXTRA: [u8; 32] = [
-    0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,
-    3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0
-];
-
-/// Base length for each distance code.
-#[rustfmt::skip]
-const DIST_BASE: [u16; 32] = [
-    1,    2,    3,    4,    5,    7,      9,      13,     17,     25,    33,
-    49,   65,   97,   129,  193,  257,    385,    513,    769,    1025,  1537,
-    2049, 3073, 4097, 6145, 8193, 12_289, 16_385, 24_577, 32_768, 32_768
-];
-
-/// Number of extra bits for each distance code.
-#[rustfmt::skip]
-const DIST_EXTRA: [u8; 32] = [
-    0, 0, 0, 0, 1, 1, 2,  2,  3,  3,  4,  4,  5,  5,  6,  6,
-    7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 13, 13
-];
-
-/// The mask used when indexing the base/extra arrays.
-const BASE_EXTRA_MASK: usize = 32 - 1;
-
-/// Sets the value of all the elements of the slice to `val`.
-#[inline]
-fn memset<T: Copy>(slice: &mut [T], val: T) {
-    for x in slice {
-        *x = val
-    }
-}
-
-/// Read an le u16 value from the slice iterator.
-///
-/// # Panics
-/// Panics if there are less than two bytes left.
-#[inline]
-fn read_u16_le(iter: &mut slice::Iter<u8>) -> u16 {
-    let ret = {
-        let two_bytes = iter.as_ref()[..2].try_into().unwrap();
-        u16::from_le_bytes(two_bytes)
-    };
-    iter.nth(1);
-    ret
-}
-
-/// Read an le u32 value from the slice iterator.
-///
-/// # Panics
-/// Panics if there are less than four bytes left.
-#[inline(always)]
-#[cfg(target_pointer_width = "64")]
-fn read_u32_le(iter: &mut slice::Iter<u8>) -> u32 {
-    let ret = {
-        let four_bytes: [u8; 4] = iter.as_ref()[..4].try_into().unwrap();
-        u32::from_le_bytes(four_bytes)
-    };
-    iter.nth(3);
-    ret
-}
-
-/// Ensure that there is data in the bit buffer.
-///
-/// On 64-bit platform, we use a 64-bit value so this will
-/// result in there being at least 32 bits in the bit buffer.
-/// This function assumes that there is at least 4 bytes left in the input buffer.
-#[inline(always)]
-#[cfg(target_pointer_width = "64")]
-fn fill_bit_buffer(l: &mut LocalVars, in_iter: &mut slice::Iter<u8>) {
-    // Read four bytes into the buffer at once.
-    if l.num_bits < 30 {
-        l.bit_buf |= BitBuffer::from(read_u32_le(in_iter)) << l.num_bits;
-        l.num_bits += 32;
-    }
-}
-
-/// Same as previous, but for non-64-bit platforms.
-/// Ensures at least 16 bits are present, requires at least 2 bytes in the in buffer.
-#[inline(always)]
-#[cfg(not(target_pointer_width = "64"))]
-fn fill_bit_buffer(l: &mut LocalVars, in_iter: &mut slice::Iter<u8>) {
-    // If the buffer is 32-bit wide, read 2 bytes instead.
-    if l.num_bits < 15 {
-        l.bit_buf |= BitBuffer::from(read_u16_le(in_iter)) << l.num_bits;
-        l.num_bits += 16;
-    }
-}
-
-/// Check that the zlib header is correct and that there is enough space in the buffer
-/// for the window size specified in the header.
-///
-/// See https://tools.ietf.org/html/rfc1950
-#[inline]
-fn validate_zlib_header(cmf: u32, flg: u32, flags: u32, mask: usize) -> Action {
-    let mut failed =
-    // cmf + flg should be divisible by 31.
-        (((cmf * 256) + flg) % 31 != 0) ||
-    // If this flag is set, a dictionary was used for this zlib compressed data.
-    // This is currently not supported by miniz or miniz-oxide
-        ((flg & 0b0010_0000) != 0) ||
-    // Compression method. Only 8(DEFLATE) is defined by the standard.
-        ((cmf & 15) != 8);
-
-    let window_size = 1 << ((cmf >> 4) + 8);
-    if (flags & TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF) == 0 {
-        // Bail if the buffer is wrapping and the window size is larger than the buffer.
-        failed |= (mask + 1) < window_size;
-    }
-
-    // Zlib doesn't allow window sizes above 32 * 1024.
-    failed |= window_size > 32_768;
-
-    if failed {
-        Action::Jump(BadZlibHeader)
-    } else {
-        Action::Jump(ReadBlockHeader)
-    }
-}
-
-enum Action {
-    None,
-    Jump(State),
-    End(TINFLStatus),
-}
-
-/// Try to decode the next huffman code, and puts it in the counter field of the decompressor
-/// if successful.
-///
-/// # Returns
-/// The specified action returned from `f` on success,
-/// `Action::End` if there are not enough data left to decode a symbol.
-fn decode_huffman_code<F>(
-    r: &mut DecompressorOxide,
-    l: &mut LocalVars,
-    table: usize,
-    flags: u32,
-    in_iter: &mut slice::Iter<u8>,
-    f: F,
-) -> Action
-where
-    F: FnOnce(&mut DecompressorOxide, &mut LocalVars, i32) -> Action,
-{
-    // As the huffman codes can be up to 15 bits long we need at least 15 bits
-    // ready in the bit buffer to start decoding the next huffman code.
-    if l.num_bits < 15 {
-        // First, make sure there is enough data in the bit buffer to decode a huffman code.
-        if in_iter.len() < 2 {
-            // If there is less than 2 bytes left in the input buffer, we try to look up
-            // the huffman code with what's available, and return if that doesn't succeed.
-            // Original explanation in miniz:
-            // /* TINFL_HUFF_BITBUF_FILL() is only used rarely, when the number of bytes
-            //  * remaining in the input buffer falls below 2. */
-            // /* It reads just enough bytes from the input stream that are needed to decode
-            //  * the next Huffman code (and absolutely no more). It works by trying to fully
-            //  * decode a */
-            // /* Huffman code by using whatever bits are currently present in the bit buffer.
-            //  * If this fails, it reads another byte, and tries again until it succeeds or
-            //  * until the */
-            // /* bit buffer contains >=15 bits (deflate's max. Huffman code size). */
-            loop {
-                let mut temp = i32::from(r.tables[table].fast_lookup(l.bit_buf));
-
-                if temp >= 0 {
-                    let code_len = (temp >> 9) as u32;
-                    if (code_len != 0) && (l.num_bits >= code_len) {
-                        break;
-                    }
-                } else if l.num_bits > FAST_LOOKUP_BITS.into() {
-                    let mut code_len = u32::from(FAST_LOOKUP_BITS);
-                    loop {
-                        temp = i32::from(
-                            r.tables[table].tree
-                                [(!temp + ((l.bit_buf >> code_len) & 1) as i32) as usize],
-                        );
-                        code_len += 1;
-                        if temp >= 0 || l.num_bits < code_len + 1 {
-                            break;
-                        }
-                    }
-                    if temp >= 0 {
-                        break;
-                    }
-                }
-
-                // TODO: miniz jumps straight to here after getting here again after failing to read
-                // a byte.
-                // Doing that lets miniz avoid re-doing the lookup that that was done in the
-                // previous call.
-                let mut byte = 0;
-                if let a @ Action::End(_) = read_byte(in_iter, flags, |b| {
-                    byte = b;
-                    Action::None
-                }) {
-                    return a;
-                };
-
-                // Do this outside closure for now to avoid borrowing r.
-                l.bit_buf |= BitBuffer::from(byte) << l.num_bits;
-                l.num_bits += 8;
-
-                if l.num_bits >= 15 {
-                    break;
-                }
-            }
-        } else {
-            // There is enough data in the input buffer, so read the next two bytes
-            // and add them to the bit buffer.
-            // Unwrapping here is fine since we just checked that there are at least two
-            // bytes left.
-            l.bit_buf |= BitBuffer::from(read_u16_le(in_iter)) << l.num_bits;
-            l.num_bits += 16;
-        }
-    }
-
-    // We now have at least 15 bits in the input buffer.
-    let mut symbol = i32::from(r.tables[table].fast_lookup(l.bit_buf));
-    let code_len;
-    // If the symbol was found in the fast lookup table.
-    if symbol >= 0 {
-        // Get the length value from the top bits.
-        // As we shift down the sign bit, converting to an unsigned value
-        // shouldn't overflow.
-        code_len = (symbol >> 9) as u32;
-        // Mask out the length value.
-        symbol &= 511;
-    } else {
-        let res = r.tables[table].tree_lookup(symbol, l.bit_buf, u32::from(FAST_LOOKUP_BITS));
-        symbol = res.0;
-        code_len = res.1;
-    };
-
-    if code_len == 0 {
-        return Action::Jump(InvalidCodeLen);
-    }
-
-    l.bit_buf >>= code_len;
-    l.num_bits -= code_len;
-    f(r, l, symbol)
-}
-
-/// Try to read one byte from `in_iter` and call `f` with the read byte as an argument,
-/// returning the result.
-/// If reading fails, `Action::End is returned`
-#[inline]
-fn read_byte<F>(in_iter: &mut slice::Iter<u8>, flags: u32, f: F) -> Action
-where
-    F: FnOnce(u8) -> Action,
-{
-    match in_iter.next() {
-        None => end_of_input(flags),
-        Some(&byte) => f(byte),
-    }
-}
-
-// TODO: `l: &mut LocalVars` may be slow similar to decompress_fast (even with inline(always))
-/// Try to read `amount` number of bits from `in_iter` and call the function `f` with the bits as an
-/// an argument after reading, returning the result of that function, or `Action::End` if there are
-/// not enough bytes left.
-#[inline]
-#[allow(clippy::while_immutable_condition)]
-fn read_bits<F>(
-    l: &mut LocalVars,
-    amount: u32,
-    in_iter: &mut slice::Iter<u8>,
-    flags: u32,
-    f: F,
-) -> Action
-where
-    F: FnOnce(&mut LocalVars, BitBuffer) -> Action,
-{
-    // Clippy gives a false positive warning here due to the closure.
-    // Read enough bytes from the input iterator to cover the number of bits we want.
-    while l.num_bits < amount {
-        let action = read_byte(in_iter, flags, |byte| {
-            l.bit_buf |= BitBuffer::from(byte) << l.num_bits;
-            l.num_bits += 8;
-            Action::None
-        });
-
-        // If there are not enough bytes in the input iterator, return and signal that we need more.
-        if !matches!(action, Action::None) {
-            return action;
-        }
-    }
-
-    let bits = l.bit_buf & ((1 << amount) - 1);
-    l.bit_buf >>= amount;
-    l.num_bits -= amount;
-    f(l, bits)
-}
-
-#[inline]
-fn pad_to_bytes<F>(l: &mut LocalVars, in_iter: &mut slice::Iter<u8>, flags: u32, f: F) -> Action
-where
-    F: FnOnce(&mut LocalVars) -> Action,
-{
-    let num_bits = l.num_bits & 7;
-    read_bits(l, num_bits, in_iter, flags, |l, _| f(l))
-}
-
-#[inline]
-fn end_of_input(flags: u32) -> Action {
-    Action::End(if flags & TINFL_FLAG_HAS_MORE_INPUT != 0 {
-        TINFLStatus::NeedsMoreInput
-    } else {
-        TINFLStatus::FailedCannotMakeProgress
-    })
-}
-
-#[inline]
-fn undo_bytes(l: &mut LocalVars, max: u32) -> u32 {
-    let res = cmp::min(l.num_bits >> 3, max);
-    l.num_bits -= res << 3;
-    res
-}
-
-fn start_static_table(r: &mut DecompressorOxide) {
-    r.table_sizes[LITLEN_TABLE] = 288;
-    r.table_sizes[DIST_TABLE] = 32;
-    memset(&mut r.tables[LITLEN_TABLE].code_size[0..144], 8);
-    memset(&mut r.tables[LITLEN_TABLE].code_size[144..256], 9);
-    memset(&mut r.tables[LITLEN_TABLE].code_size[256..280], 7);
-    memset(&mut r.tables[LITLEN_TABLE].code_size[280..288], 8);
-    memset(&mut r.tables[DIST_TABLE].code_size[0..32], 5);
-}
-
-#[cfg(feature = "rustc-dep-of-std")]
-fn reverse_bits(n: u32) -> u32 {
-    // Lookup is not used when building as part of std to avoid wasting space
-    // for lookup table in every rust binary
-    // as it's only used for backtraces in the cold path
-    // - see #152
-    n.reverse_bits()
-}
-
-#[cfg(not(feature = "rustc-dep-of-std"))]
-fn reverse_bits(n: u32) -> u32 {
-    static REVERSED_BITS_LOOKUP: [u32; 512] = {
-        let mut table = [0; 512];
-
-        let mut i = 0;
-        while i < 512 {
-            table[i] = (i as u32).reverse_bits();
-            i += 1;
-        }
-
-        table
-    };
-
-    REVERSED_BITS_LOOKUP[n as usize]
-}
-
-fn init_tree(r: &mut DecompressorOxide, l: &mut LocalVars) -> Option<Action> {
-    loop {
-        let bt = r.block_type as usize;
-        if bt >= r.tables.len() {
-            return None;
-        }
-        let table = &mut r.tables[bt];
-        let table_size = r.table_sizes[bt] as usize;
-        if table_size > table.code_size.len() {
-            return None;
-        }
-        let mut total_symbols = [0u32; 16];
-        let mut next_code = [0u32; 17];
-        memset(&mut table.look_up[..], 0);
-        memset(&mut table.tree[..], 0);
-
-        for &code_size in &table.code_size[..table_size] {
-            let cs = code_size as usize;
-            if cs >= total_symbols.len() {
-                return None;
-            }
-            total_symbols[cs] += 1;
-        }
-
-        let mut used_symbols = 0;
-        let mut total = 0;
-        for (ts, next) in total_symbols
-            .iter()
-            .copied()
-            .zip(next_code.iter_mut().skip(1))
-            .skip(1)
-        {
-            used_symbols += ts;
-            total += ts;
-            total <<= 1;
-            *next = total;
-        }
-
-        if total != 65_536 && used_symbols > 1 {
-            return Some(Action::Jump(BadTotalSymbols));
-        }
-
-        let mut tree_next = -1;
-        for symbol_index in 0..table_size {
-            let code_size = table.code_size[symbol_index];
-            if code_size == 0 || usize::from(code_size) >= next_code.len() {
-                continue;
-            }
-
-            let cur_code = next_code[code_size as usize];
-            next_code[code_size as usize] += 1;
-
-            let n = cur_code & (u32::MAX >> (32 - code_size));
-
-            let mut rev_code = if n < 512 {
-                // Using a lookup table
-                // for a small speedup here,
-                // Seems to only really make a difference on very short
-                // inputs however.
-                // 512 seems to be around a sweet spot.
-                reverse_bits(n)
-            } else {
-                n.reverse_bits()
-            } >> (32 - code_size);
-
-            if code_size <= FAST_LOOKUP_BITS {
-                let k = (i16::from(code_size) << 9) | symbol_index as i16;
-                while rev_code < FAST_LOOKUP_SIZE {
-                    table.look_up[rev_code as usize] = k;
-                    rev_code += 1 << code_size;
-                }
-                continue;
-            }
-
-            let mut tree_cur = table.look_up[(rev_code & (FAST_LOOKUP_SIZE - 1)) as usize];
-            if tree_cur == 0 {
-                table.look_up[(rev_code & (FAST_LOOKUP_SIZE - 1)) as usize] = tree_next;
-                tree_cur = tree_next;
-                tree_next -= 2;
-            }
-
-            rev_code >>= FAST_LOOKUP_BITS - 1;
-            for _ in FAST_LOOKUP_BITS + 1..code_size {
-                rev_code >>= 1;
-                tree_cur -= (rev_code & 1) as i16;
-                let tree_index = (-tree_cur - 1) as usize;
-                if tree_index >= table.tree.len() {
-                    return None;
-                }
-                if table.tree[tree_index] == 0 {
-                    table.tree[tree_index] = tree_next;
-                    tree_cur = tree_next;
-                    tree_next -= 2;
-                } else {
-                    tree_cur = table.tree[tree_index];
-                }
-            }
-
-            rev_code >>= 1;
-            tree_cur -= (rev_code & 1) as i16;
-            let tree_index = (-tree_cur - 1) as usize;
-            if tree_index >= table.tree.len() {
-                return None;
-            }
-            table.tree[tree_index] = symbol_index as i16;
-        }
-
-        if r.block_type == 2 {
-            l.counter = 0;
-            return Some(Action::Jump(ReadLitlenDistTablesCodeSize));
-        }
-
-        if r.block_type == 0 {
-            break;
-        }
-        r.block_type -= 1;
-    }
-
-    l.counter = 0;
-    Some(Action::Jump(DecodeLitlen))
-}
-
-// A helper macro for generating the state machine.
-//
-// As Rust doesn't have fallthrough on matches, we have to return to the match statement
-// and jump for each state change. (Which would ideally be optimized away, but often isn't.)
-macro_rules! generate_state {
-    ($state: ident, $state_machine: tt, $f: expr) => {
-        loop {
-            match $f {
-                Action::None => continue,
-                Action::Jump(new_state) => {
-                    $state = new_state;
-                    continue $state_machine;
-                },
-                Action::End(result) => break $state_machine result,
-            }
-        }
-    };
-}
-
-#[derive(Copy, Clone)]
-struct LocalVars {
-    pub bit_buf: BitBuffer,
-    pub num_bits: u32,
-    pub dist: u32,
-    pub counter: u32,
-    pub num_extra: u32,
-}
-
-#[inline]
-fn transfer(
-    out_slice: &mut [u8],
-    mut source_pos: usize,
-    mut out_pos: usize,
-    match_len: usize,
-    out_buf_size_mask: usize,
-) {
-    // special case that comes up surprisingly often. in the case that `source_pos`
-    // is 1 less than `out_pos`, we can say that the entire range will be the same
-    // value and optimize this to be a simple `memset`
-    let source_diff = if source_pos > out_pos {
-        source_pos - out_pos
-    } else {
-        out_pos - source_pos
-    };
-    if out_buf_size_mask == usize::MAX && source_diff == 1 && out_pos > source_pos {
-        let init = out_slice[out_pos - 1];
-        let end = (match_len >> 2) * 4 + out_pos;
-
-        out_slice[out_pos..end].fill(init);
-        out_pos = end;
-        source_pos = end - 1;
-    // if the difference between `source_pos` and `out_pos` is greater than 3, we
-    // can do slightly better than the naive case by copying everything at once
-    } else if out_buf_size_mask == usize::MAX && source_diff >= 4 && out_pos > source_pos {
-        for _ in 0..match_len >> 2 {
-            out_slice.copy_within(source_pos..=source_pos + 3, out_pos);
-            source_pos += 4;
-            out_pos += 4;
-        }
-    } else {
-        for _ in 0..match_len >> 2 {
-            out_slice[out_pos] = out_slice[source_pos & out_buf_size_mask];
-            out_slice[out_pos + 1] = out_slice[(source_pos + 1) & out_buf_size_mask];
-            out_slice[out_pos + 2] = out_slice[(source_pos + 2) & out_buf_size_mask];
-            out_slice[out_pos + 3] = out_slice[(source_pos + 3) & out_buf_size_mask];
-            source_pos += 4;
-            out_pos += 4;
-        }
-    }
-
-    match match_len & 3 {
-        0 => (),
-        1 => out_slice[out_pos] = out_slice[source_pos & out_buf_size_mask],
-        2 => {
-            out_slice[out_pos] = out_slice[source_pos & out_buf_size_mask];
-            out_slice[out_pos + 1] = out_slice[(source_pos + 1) & out_buf_size_mask];
-        }
-        3 => {
-            out_slice[out_pos] = out_slice[source_pos & out_buf_size_mask];
-            out_slice[out_pos + 1] = out_slice[(source_pos + 1) & out_buf_size_mask];
-            out_slice[out_pos + 2] = out_slice[(source_pos + 2) & out_buf_size_mask];
-        }
-        _ => unreachable!(),
-    }
-}
-
-/// Presumes that there is at least match_len bytes in output left.
-#[inline]
-fn apply_match(
-    out_slice: &mut [u8],
-    out_pos: usize,
-    dist: usize,
-    match_len: usize,
-    out_buf_size_mask: usize,
-) {
-    debug_assert!(out_pos.checked_add(match_len).unwrap() <= out_slice.len());
-
-    let source_pos = out_pos.wrapping_sub(dist) & out_buf_size_mask;
-
-    if match_len == 3 {
-        let out_slice = Cell::from_mut(out_slice).as_slice_of_cells();
-        if let Some(dst) = out_slice.get(out_pos..out_pos + 3) {
-            // Moving bounds checks before any memory mutation allows the optimizer
-            // combine them together.
-            let src = out_slice
-                .get(source_pos)
-                .zip(out_slice.get((source_pos + 1) & out_buf_size_mask))
-                .zip(out_slice.get((source_pos + 2) & out_buf_size_mask));
-            if let Some(((a, b), c)) = src {
-                // For correctness, the memory reads and writes have to be interleaved.
-                // Cells make it possible for read and write references to overlap.
-                dst[0].set(a.get());
-                dst[1].set(b.get());
-                dst[2].set(c.get());
-            }
-        }
-        return;
-    }
-
-    if cfg!(not(any(target_arch = "x86", target_arch = "x86_64"))) {
-        // We are not on x86 so copy manually.
-        transfer(out_slice, source_pos, out_pos, match_len, out_buf_size_mask);
-        return;
-    }
-
-    if source_pos >= out_pos && (source_pos - out_pos) < match_len {
-        transfer(out_slice, source_pos, out_pos, match_len, out_buf_size_mask);
-    } else if match_len <= dist && source_pos + match_len < out_slice.len() {
-        // Destination and source segments does not intersect and source does not wrap.
-        if source_pos < out_pos {
-            let (from_slice, to_slice) = out_slice.split_at_mut(out_pos);
-            to_slice[..match_len].copy_from_slice(&from_slice[source_pos..source_pos + match_len]);
-        } else {
-            let (to_slice, from_slice) = out_slice.split_at_mut(source_pos);
-            to_slice[out_pos..out_pos + match_len].copy_from_slice(&from_slice[..match_len]);
-        }
-    } else {
-        transfer(out_slice, source_pos, out_pos, match_len, out_buf_size_mask);
-    }
-}
-
-/// Fast inner decompression loop which is run  while there is at least
-/// 259 bytes left in the output buffer, and at least 6 bytes left in the input buffer
-/// (The maximum one match would need + 1).
-///
-/// This was inspired by a similar optimization in zlib, which uses this info to do
-/// faster unchecked copies of multiple bytes at a time.
-/// Currently we don't do this here, but this function does avoid having to jump through the
-/// big match loop on each state change(as rust does not have fallthrough or gotos at the moment),
-/// and already improves decompression speed a fair bit.
-fn decompress_fast(
-    r: &mut DecompressorOxide,
-    in_iter: &mut slice::Iter<u8>,
-    out_buf: &mut OutputBuffer,
-    flags: u32,
-    local_vars: &mut LocalVars,
-    out_buf_size_mask: usize,
-) -> (TINFLStatus, State) {
-    // Make a local copy of the most used variables, to avoid having to update and read from values
-    // in a random memory location and to encourage more register use.
-    let mut l = *local_vars;
-    let mut state;
-
-    let status: TINFLStatus = 'o: loop {
-        state = State::DecodeLitlen;
-        loop {
-            // This function assumes that there is at least 259 bytes left in the output buffer,
-            // and that there is at least 14 bytes left in the input buffer. 14 input bytes:
-            // 15 (prev lit) + 15 (length) + 5 (length extra) + 15 (dist)
-            // + 29 + 32 (left in bit buf, including last 13 dist extra) = 111 bits < 14 bytes
-            // We need the one extra byte as we may write one length and one full match
-            // before checking again.
-            if out_buf.bytes_left() < 259 || in_iter.len() < 14 {
-                state = State::DecodeLitlen;
-                break 'o TINFLStatus::Done;
-            }
-
-            fill_bit_buffer(&mut l, in_iter);
-
-            if let Some((symbol, code_len)) = r.tables[LITLEN_TABLE].lookup(l.bit_buf) {
-                l.counter = symbol as u32;
-                l.bit_buf >>= code_len;
-                l.num_bits -= code_len;
-
-                if (l.counter & 256) != 0 {
-                    // The symbol is not a literal.
-                    break;
-                } else {
-                    // If we have a 32-bit buffer we need to read another two bytes now
-                    // to have enough bits to keep going.
-                    if cfg!(not(target_pointer_width = "64")) {
-                        fill_bit_buffer(&mut l, in_iter);
-                    }
-
-                    if let Some((symbol, code_len)) = r.tables[LITLEN_TABLE].lookup(l.bit_buf) {
-                        l.bit_buf >>= code_len;
-                        l.num_bits -= code_len;
-                        // The previous symbol was a literal, so write it directly and check
-                        // the next one.
-                        out_buf.write_byte(l.counter as u8);
-                        if (symbol & 256) != 0 {
-                            l.counter = symbol as u32;
-                            // The symbol is a length value.
-                            break;
-                        } else {
-                            // The symbol is a literal, so write it directly and continue.
-                            out_buf.write_byte(symbol as u8);
-                        }
-                    } else {
-                        state.begin(InvalidCodeLen);
-                        break 'o TINFLStatus::Failed;
-                    }
-                }
-            } else {
-                state.begin(InvalidCodeLen);
-                break 'o TINFLStatus::Failed;
-            }
-        }
-
-        // Mask the top bits since they may contain length info.
-        l.counter &= 511;
-        if l.counter == 256 {
-            // We hit the end of block symbol.
-            state.begin(BlockDone);
-            break 'o TINFLStatus::Done;
-        } else if l.counter > 285 {
-            // Invalid code.
-            // We already verified earlier that the code is > 256.
-            state.begin(InvalidLitlen);
-            break 'o TINFLStatus::Failed;
-        } else {
-            // The symbol was a length code.
-            // # Optimization
-            // Mask the value to avoid bounds checks
-            // We could use get_unchecked later if can statically verify that
-            // this will never go out of bounds.
-            l.num_extra = u32::from(LENGTH_EXTRA[(l.counter - 257) as usize & BASE_EXTRA_MASK]);
-            l.counter = u32::from(LENGTH_BASE[(l.counter - 257) as usize & BASE_EXTRA_MASK]);
-            // Length and distance codes have a number of extra bits depending on
-            // the base, which together with the base gives us the exact value.
-
-            fill_bit_buffer(&mut l, in_iter);
-            if l.num_extra != 0 {
-                let extra_bits = l.bit_buf & ((1 << l.num_extra) - 1);
-                l.bit_buf >>= l.num_extra;
-                l.num_bits -= l.num_extra;
-                l.counter += extra_bits as u32;
-            }
-
-            // We found a length code, so a distance code should follow.
-
-            if cfg!(not(target_pointer_width = "64")) {
-                fill_bit_buffer(&mut l, in_iter);
-            }
-
-            if let Some((mut symbol, code_len)) = r.tables[DIST_TABLE].lookup(l.bit_buf) {
-                symbol &= 511;
-                l.bit_buf >>= code_len;
-                l.num_bits -= code_len;
-                if symbol > 29 {
-                    state.begin(InvalidDist);
-                    break 'o TINFLStatus::Failed;
-                }
-
-                l.num_extra = u32::from(DIST_EXTRA[symbol as usize]);
-                l.dist = u32::from(DIST_BASE[symbol as usize]);
-            } else {
-                state.begin(InvalidCodeLen);
-                break 'o TINFLStatus::Failed;
-            }
-
-            if l.num_extra != 0 {
-                fill_bit_buffer(&mut l, in_iter);
-                let extra_bits = l.bit_buf & ((1 << l.num_extra) - 1);
-                l.bit_buf >>= l.num_extra;
-                l.num_bits -= l.num_extra;
-                l.dist += extra_bits as u32;
-            }
-
-            let position = out_buf.position();
-            if l.dist as usize > out_buf.position()
-                && (flags & TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF != 0)
-            {
-                // We encountered a distance that refers a position before
-                // the start of the decoded data, so we can't continue.
-                state.begin(DistanceOutOfBounds);
-                break TINFLStatus::Failed;
-            }
-
-            apply_match(
-                out_buf.get_mut(),
-                position,
-                l.dist as usize,
-                l.counter as usize,
-                out_buf_size_mask,
-            );
-
-            out_buf.set_position(position + l.counter as usize);
-        }
-    };
-
-    *local_vars = l;
-    (status, state)
-}
-
-/// Main decompression function. Keeps decompressing data from `in_buf` until the `in_buf` is
-/// empty, `out` is full, the end of the deflate stream is hit, or there is an error in the
-/// deflate stream.
-///
-/// # Arguments
-///
-/// `r` is a [`DecompressorOxide`] struct with the state of this stream.
-///
-/// `in_buf` is a reference to the compressed data that is to be decompressed. The decompressor will
-/// start at the first byte of this buffer.
-///
-/// `out` is a reference to the buffer that will store the decompressed data, and that
-/// stores previously decompressed data if any.
-///
-/// * The offset given by `out_pos` indicates where in the output buffer slice writing should start.
-/// * If [`TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF`] is not set, the output buffer is used in a
-/// wrapping manner, and it's size is required to be a power of 2.
-/// * The decompression function normally needs access to 32KiB of the previously decompressed data
-///(or to the beginning of the decompressed data if less than 32KiB has been decompressed.)
-///     - If this data is not available, decompression may fail.
-///     - Some deflate compressors allow specifying a window size which limits match distances to
-/// less than this, or alternatively an RLE mode where matches will only refer to the previous byte
-/// and thus allows a smaller output buffer. The window size can be specified in the zlib
-/// header structure, however, the header data should not be relied on to be correct.
-///
-/// `flags` indicates settings and status to the decompression function.
-/// * The [`TINFL_FLAG_HAS_MORE_INPUT`] has to be specified if more compressed data is to be provided
-/// in a subsequent call to this function.
-/// * See the the [`inflate_flags`] module for details on other flags.
-///
-/// # Returns
-///
-/// Returns a tuple containing the status of the compressor, the number of input bytes read, and the
-/// number of bytes output to `out`.
-///
-/// This function shouldn't panic pending any bugs.
-pub fn decompress(
-    r: &mut DecompressorOxide,
-    in_buf: &[u8],
-    out: &mut [u8],
-    out_pos: usize,
-    flags: u32,
-) -> (TINFLStatus, usize, usize) {
-    let out_buf_size_mask = if flags & TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF != 0 {
-        usize::max_value()
-    } else {
-        // In the case of zero len, any attempt to write would produce HasMoreOutput,
-        // so to gracefully process the case of there really being no output,
-        // set the mask to all zeros.
-        out.len().saturating_sub(1)
-    };
-
-    // Ensure the output buffer's size is a power of 2, unless the output buffer
-    // is large enough to hold the entire output file (in which case it doesn't
-    // matter).
-    // Also make sure that the output buffer position is not past the end of the output buffer.
-    if (out_buf_size_mask.wrapping_add(1) & out_buf_size_mask) != 0 || out_pos > out.len() {
-        return (TINFLStatus::BadParam, 0, 0);
-    }
-
-    let mut in_iter = in_buf.iter();
-
-    let mut state = r.state;
-
-    let mut out_buf = OutputBuffer::from_slice_and_pos(out, out_pos);
-
-    // Make a local copy of the important variables here so we can work with them on the stack.
-    let mut l = LocalVars {
-        bit_buf: r.bit_buf,
-        num_bits: r.num_bits,
-        dist: r.dist,
-        counter: r.counter,
-        num_extra: r.num_extra,
-    };
-
-    let mut status = 'state_machine: loop {
-        match state {
-            Start => generate_state!(state, 'state_machine, {
-                l.bit_buf = 0;
-                l.num_bits = 0;
-                l.dist = 0;
-                l.counter = 0;
-                l.num_extra = 0;
-                r.z_header0 = 0;
-                r.z_header1 = 0;
-                r.z_adler32 = 1;
-                r.check_adler32 = 1;
-                if flags & TINFL_FLAG_PARSE_ZLIB_HEADER != 0 {
-                    Action::Jump(State::ReadZlibCmf)
-                } else {
-                    Action::Jump(State::ReadBlockHeader)
-                }
-            }),
-
-            ReadZlibCmf => generate_state!(state, 'state_machine, {
-                read_byte(&mut in_iter, flags, |cmf| {
-                    r.z_header0 = u32::from(cmf);
-                    Action::Jump(State::ReadZlibFlg)
-                })
-            }),
-
-            ReadZlibFlg => generate_state!(state, 'state_machine, {
-                read_byte(&mut in_iter, flags, |flg| {
-                    r.z_header1 = u32::from(flg);
-                    validate_zlib_header(r.z_header0, r.z_header1, flags, out_buf_size_mask)
-                })
-            }),
-
-            // Read the block header and jump to the relevant section depending on the block type.
-            ReadBlockHeader => generate_state!(state, 'state_machine, {
-                read_bits(&mut l, 3, &mut in_iter, flags, |l, bits| {
-                    r.finish = (bits & 1) as u32;
-                    r.block_type = (bits >> 1) as u32 & 3;
-                    match r.block_type {
-                        0 => Action::Jump(BlockTypeNoCompression),
-                        1 => {
-                            start_static_table(r);
-                            init_tree(r, l).unwrap_or(Action::End(TINFLStatus::Failed))
-                        },
-                        2 => {
-                            l.counter = 0;
-                            Action::Jump(ReadTableSizes)
-                        },
-                        3 => Action::Jump(BlockTypeUnexpected),
-                        _ => unreachable!()
-                    }
-                })
-            }),
-
-            // Raw/Stored/uncompressed block.
-            BlockTypeNoCompression => generate_state!(state, 'state_machine, {
-                pad_to_bytes(&mut l, &mut in_iter, flags, |l| {
-                    l.counter = 0;
-                    Action::Jump(RawHeader)
-                })
-            }),
-
-            // Check that the raw block header is correct.
-            RawHeader => generate_state!(state, 'state_machine, {
-                if l.counter < 4 {
-                    // Read block length and block length check.
-                    if l.num_bits != 0 {
-                        read_bits(&mut l, 8, &mut in_iter, flags, |l, bits| {
-                            r.raw_header[l.counter as usize] = bits as u8;
-                            l.counter += 1;
-                            Action::None
-                        })
-                    } else {
-                        read_byte(&mut in_iter, flags, |byte| {
-                            r.raw_header[l.counter as usize] = byte;
-                            l.counter += 1;
-                            Action::None
-                        })
-                    }
-                } else {
-                    // Check if the length value of a raw block is correct.
-                    // The 2 first (2-byte) words in a raw header are the length and the
-                    // ones complement of the length.
-                    let length = u16::from(r.raw_header[0]) | (u16::from(r.raw_header[1]) << 8);
-                    let check = u16::from(r.raw_header[2]) | (u16::from(r.raw_header[3]) << 8);
-                    let valid = length == !check;
-                    l.counter = length.into();
-
-                    if !valid {
-                        Action::Jump(BadRawLength)
-                    } else if l.counter == 0 {
-                        // Empty raw block. Sometimes used for synchronization.
-                        Action::Jump(BlockDone)
-                    } else if l.num_bits != 0 {
-                        // There is some data in the bit buffer, so we need to write that first.
-                        Action::Jump(RawReadFirstByte)
-                    } else {
-                        // The bit buffer is empty, so memcpy the rest of the uncompressed data from
-                        // the block.
-                        Action::Jump(RawMemcpy1)
-                    }
-                }
-            }),
-
-            // Read the byte from the bit buffer.
-            RawReadFirstByte => generate_state!(state, 'state_machine, {
-                read_bits(&mut l, 8, &mut in_iter, flags, |l, bits| {
-                    l.dist = bits as u32;
-                    Action::Jump(RawStoreFirstByte)
-                })
-            }),
-
-            // Write the byte we just read to the output buffer.
-            RawStoreFirstByte => generate_state!(state, 'state_machine, {
-                if out_buf.bytes_left() == 0 {
-                    Action::End(TINFLStatus::HasMoreOutput)
-                } else {
-                    out_buf.write_byte(l.dist as u8);
-                    l.counter -= 1;
-                    if l.counter == 0 || l.num_bits == 0 {
-                        Action::Jump(RawMemcpy1)
-                    } else {
-                        // There is still some data left in the bit buffer that needs to be output.
-                        // TODO: Changed this to jump to `RawReadfirstbyte` rather than
-                        // `RawStoreFirstByte` as that seemed to be the correct path, but this
-                        // needs testing.
-                        Action::Jump(RawReadFirstByte)
-                    }
-                }
-            }),
-
-            RawMemcpy1 => generate_state!(state, 'state_machine, {
-                if l.counter == 0 {
-                    Action::Jump(BlockDone)
-                } else if out_buf.bytes_left() == 0 {
-                    Action::End(TINFLStatus::HasMoreOutput)
-                } else {
-                    Action::Jump(RawMemcpy2)
-                }
-            }),
-
-            RawMemcpy2 => generate_state!(state, 'state_machine, {
-                if in_iter.len() > 0 {
-                    // Copy as many raw bytes as possible from the input to the output using memcpy.
-                    // Raw block lengths are limited to 64 * 1024, so casting through usize and u32
-                    // is not an issue.
-                    let space_left = out_buf.bytes_left();
-                    let bytes_to_copy = cmp::min(cmp::min(
-                        space_left,
-                        in_iter.len()),
-                        l.counter as usize
-                    );
-
-                    out_buf.write_slice(&in_iter.as_slice()[..bytes_to_copy]);
-
-                    in_iter.nth(bytes_to_copy - 1);
-                    l.counter -= bytes_to_copy as u32;
-                    Action::Jump(RawMemcpy1)
-                } else {
-                    end_of_input(flags)
-                }
-            }),
-
-            // Read how many huffman codes/symbols are used for each table.
-            ReadTableSizes => generate_state!(state, 'state_machine, {
-                if l.counter < 3 {
-                    let num_bits = [5, 5, 4][l.counter as usize];
-                    read_bits(&mut l, num_bits, &mut in_iter, flags, |l, bits| {
-                        r.table_sizes[l.counter as usize] =
-                            bits as u32 + u32::from(MIN_TABLE_SIZES[l.counter as usize]);
-                        l.counter += 1;
-                        Action::None
-                    })
-                } else {
-                    memset(&mut r.tables[HUFFLEN_TABLE].code_size[..], 0);
-                    l.counter = 0;
-                    // Check that the litlen and distance are within spec.
-                    // litlen table should be <=286 acc to the RFC and
-                    // additionally zlib rejects dist table sizes larger than 30.
-                    // NOTE this the final sizes after adding back predefined values, not
-                    // raw value in the data.
-                    // See miniz_oxide issue #130 and https://github.com/madler/zlib/issues/82.
-                    if r.table_sizes[LITLEN_TABLE] <= 286 && r.table_sizes[DIST_TABLE] <= 30 {
-                        Action::Jump(ReadHufflenTableCodeSize)
-                    }
-                    else {
-                        Action::Jump(BadDistOrLiteralTableLength)
-                    }
-                }
-            }),
-
-            // Read the 3-bit lengths of the huffman codes describing the huffman code lengths used
-            // to decode the lengths of the main tables.
-            ReadHufflenTableCodeSize => generate_state!(state, 'state_machine, {
-                if l.counter < r.table_sizes[HUFFLEN_TABLE] {
-                    read_bits(&mut l, 3, &mut in_iter, flags, |l, bits| {
-                        // These lengths are not stored in a normal ascending order, but rather one
-                        // specified by the deflate specification intended to put the most used
-                        // values at the front as trailing zero lengths do not have to be stored.
-                        r.tables[HUFFLEN_TABLE]
-                            .code_size[HUFFMAN_LENGTH_ORDER[l.counter as usize] as usize] =
-                                bits as u8;
-                        l.counter += 1;
-                        Action::None
-                    })
-                } else {
-                    r.table_sizes[HUFFLEN_TABLE] = 19;
-                    init_tree(r, &mut l).unwrap_or(Action::End(TINFLStatus::Failed))
-                }
-            }),
-
-            ReadLitlenDistTablesCodeSize => generate_state!(state, 'state_machine, {
-                if l.counter < r.table_sizes[LITLEN_TABLE] + r.table_sizes[DIST_TABLE] {
-                    decode_huffman_code(
-                        r, &mut l, HUFFLEN_TABLE,
-                        flags, &mut in_iter, |r, l, symbol| {
-                            l.dist = symbol as u32;
-                            if l.dist < 16 {
-                                r.len_codes[l.counter as usize] = l.dist as u8;
-                                l.counter += 1;
-                                Action::None
-                            } else if l.dist == 16 && l.counter == 0 {
-                                Action::Jump(BadCodeSizeDistPrevLookup)
-                            } else {
-                                l.num_extra = [2, 3, 7][l.dist as usize - 16];
-                                Action::Jump(ReadExtraBitsCodeSize)
-                            }
-                        }
-                    )
-                } else if l.counter != r.table_sizes[LITLEN_TABLE] + r.table_sizes[DIST_TABLE] {
-                    Action::Jump(BadCodeSizeSum)
-                } else {
-                    r.tables[LITLEN_TABLE].code_size[..r.table_sizes[LITLEN_TABLE] as usize]
-                        .copy_from_slice(&r.len_codes[..r.table_sizes[LITLEN_TABLE] as usize]);
-
-                    let dist_table_start = r.table_sizes[LITLEN_TABLE] as usize;
-                    let dist_table_end = (r.table_sizes[LITLEN_TABLE] +
-                                          r.table_sizes[DIST_TABLE]) as usize;
-                    r.tables[DIST_TABLE].code_size[..r.table_sizes[DIST_TABLE] as usize]
-                        .copy_from_slice(&r.len_codes[dist_table_start..dist_table_end]);
-
-                    r.block_type -= 1;
-                    init_tree(r, &mut l).unwrap_or(Action::End(TINFLStatus::Failed))
-                }
-            }),
-
-            ReadExtraBitsCodeSize => generate_state!(state, 'state_machine, {
-                let num_extra = l.num_extra;
-                read_bits(&mut l, num_extra, &mut in_iter, flags, |l, mut extra_bits| {
-                    // Mask to avoid a bounds check.
-                    extra_bits += [3, 3, 11][(l.dist as usize - 16) & 3];
-                    let val = if l.dist == 16 {
-                        r.len_codes[l.counter as usize - 1]
-                    } else {
-                        0
-                    };
-
-                    memset(
-                        &mut r.len_codes[
-                            l.counter as usize..l.counter as usize + extra_bits as usize
-                        ],
-                        val,
-                    );
-                    l.counter += extra_bits as u32;
-                    Action::Jump(ReadLitlenDistTablesCodeSize)
-                })
-            }),
-
-            DecodeLitlen => generate_state!(state, 'state_machine, {
-                if in_iter.len() < 4 || out_buf.bytes_left() < 2 {
-                    // See if we can decode a literal with the data we have left.
-                    // Jumps to next state (WriteSymbol) if successful.
-                    decode_huffman_code(
-                        r,
-                        &mut l,
-                        LITLEN_TABLE,
-                        flags,
-                        &mut in_iter,
-                        |_r, l, symbol| {
-                            l.counter = symbol as u32;
-                            Action::Jump(WriteSymbol)
-                        },
-                    )
-                } else if
-                // If there is enough space, use the fast inner decompression
-                // function.
-                    out_buf.bytes_left() >= 259 &&
-                    in_iter.len() >= 14
-                {
-                    let (status, new_state) = decompress_fast(
-                        r,
-                        &mut in_iter,
-                        &mut out_buf,
-                        flags,
-                        &mut l,
-                        out_buf_size_mask,
-                    );
-
-                    state = new_state;
-                    if status == TINFLStatus::Done {
-                        Action::Jump(new_state)
-                    } else {
-                        Action::End(status)
-                    }
-                } else {
-                    fill_bit_buffer(&mut l, &mut in_iter);
-
-                    if let Some((symbol, code_len)) = r.tables[LITLEN_TABLE].lookup(l.bit_buf) {
-
-                    l.counter = symbol as u32;
-                    l.bit_buf >>= code_len;
-                    l.num_bits -= code_len;
-
-                    if (l.counter & 256) != 0 {
-                        // The symbol is not a literal.
-                        Action::Jump(HuffDecodeOuterLoop1)
-                    } else {
-                        // If we have a 32-bit buffer we need to read another two bytes now
-                        // to have enough bits to keep going.
-                        if cfg!(not(target_pointer_width = "64")) {
-                            fill_bit_buffer(&mut l, &mut in_iter);
-                        }
-
-                        if let Some((symbol, code_len)) = r.tables[LITLEN_TABLE].lookup(l.bit_buf) {
-
-                            l.bit_buf >>= code_len;
-                            l.num_bits -= code_len;
-                            // The previous symbol was a literal, so write it directly and check
-                            // the next one.
-                            out_buf.write_byte(l.counter as u8);
-                            if (symbol & 256) != 0 {
-                                l.counter = symbol as u32;
-                                // The symbol is a length value.
-                                Action::Jump(HuffDecodeOuterLoop1)
-                            } else {
-                                // The symbol is a literal, so write it directly and continue.
-                                out_buf.write_byte(symbol as u8);
-                                Action::None
-                            }
-                        } else {
-                            Action::Jump(InvalidCodeLen)
-                        }
-                    }
-                    } else {
-                        Action::Jump(InvalidCodeLen)
-                    }
-                }
-            }),
-
-            WriteSymbol => generate_state!(state, 'state_machine, {
-                if l.counter >= 256 {
-                    Action::Jump(HuffDecodeOuterLoop1)
-                } else if out_buf.bytes_left() > 0 {
-                    out_buf.write_byte(l.counter as u8);
-                    Action::Jump(DecodeLitlen)
-                } else {
-                    Action::End(TINFLStatus::HasMoreOutput)
-                }
-            }),
-
-            HuffDecodeOuterLoop1 => generate_state!(state, 'state_machine, {
-                // Mask the top bits since they may contain length info.
-                l.counter &= 511;
-
-                if l.counter
-                    == 256 {
-                    // We hit the end of block symbol.
-                    Action::Jump(BlockDone)
-                } else if l.counter > 285 {
-                    // Invalid code.
-                    // We already verified earlier that the code is > 256.
-                    Action::Jump(InvalidLitlen)
-                } else {
-                    // # Optimization
-                    // Mask the value to avoid bounds checks
-                    // We could use get_unchecked later if can statically verify that
-                    // this will never go out of bounds.
-                    l.num_extra =
-                        u32::from(LENGTH_EXTRA[(l.counter - 257) as usize & BASE_EXTRA_MASK]);
-                    l.counter = u32::from(LENGTH_BASE[(l.counter - 257) as usize & BASE_EXTRA_MASK]);
-                    // Length and distance codes have a number of extra bits depending on
-                    // the base, which together with the base gives us the exact value.
-                    if l.num_extra != 0 {
-                        Action::Jump(ReadExtraBitsLitlen)
-                    } else {
-                        Action::Jump(DecodeDistance)
-                    }
-                }
-            }),
-
-            ReadExtraBitsLitlen => generate_state!(state, 'state_machine, {
-                let num_extra = l.num_extra;
-                read_bits(&mut l, num_extra, &mut in_iter, flags, |l, extra_bits| {
-                    l.counter += extra_bits as u32;
-                    Action::Jump(DecodeDistance)
-                })
-            }),
-
-            DecodeDistance => generate_state!(state, 'state_machine, {
-                // Try to read a huffman code from the input buffer and look up what
-                // length code the decoded symbol refers to.
-                decode_huffman_code(r, &mut l, DIST_TABLE, flags, &mut in_iter, |_r, l, symbol| {
-                    if symbol > 29 {
-                        // Invalid distance code.
-                        return Action::Jump(InvalidDist)
-                    }
-                    // # Optimization
-                    // Mask the value to avoid bounds checks
-                    // We could use get_unchecked later if can statically verify that
-                    // this will never go out of bounds.
-                    l.num_extra = u32::from(DIST_EXTRA[symbol as usize & BASE_EXTRA_MASK]);
-                    l.dist = u32::from(DIST_BASE[symbol as usize & BASE_EXTRA_MASK]);
-                    if l.num_extra != 0 {
-                        // ReadEXTRA_BITS_DISTACNE
-                        Action::Jump(ReadExtraBitsDistance)
-                    } else {
-                        Action::Jump(HuffDecodeOuterLoop2)
-                    }
-                })
-            }),
-
-            ReadExtraBitsDistance => generate_state!(state, 'state_machine, {
-                let num_extra = l.num_extra;
-                read_bits(&mut l, num_extra, &mut in_iter, flags, |l, extra_bits| {
-                    l.dist += extra_bits as u32;
-                    Action::Jump(HuffDecodeOuterLoop2)
-                })
-            }),
-
-            HuffDecodeOuterLoop2 => generate_state!(state, 'state_machine, {
-                if l.dist as usize > out_buf.position() &&
-                    (flags & TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF != 0)
-                {
-                    // We encountered a distance that refers a position before
-                    // the start of the decoded data, so we can't continue.
-                    Action::Jump(DistanceOutOfBounds)
-                } else {
-                    let out_pos = out_buf.position();
-                    let source_pos = out_buf.position()
-                        .wrapping_sub(l.dist as usize) & out_buf_size_mask;
-
-                    let out_len = out_buf.get_ref().len();
-                    let match_end_pos = out_buf.position() + l.counter as usize;
-
-                    if match_end_pos > out_len ||
-                        // miniz doesn't do this check here. Not sure how it makes sure
-                        // that this case doesn't happen.
-                        (source_pos >= out_pos && (source_pos - out_pos) < l.counter as usize)
-                    {
-                        // Not enough space for all of the data in the output buffer,
-                        // so copy what we have space for.
-                        if l.counter == 0 {
-                            Action::Jump(DecodeLitlen)
-                        } else {
-                            Action::Jump(WriteLenBytesToEnd)
-                        }
-                    } else {
-                        apply_match(
-                            out_buf.get_mut(),
-                            out_pos,
-                            l.dist as usize,
-                            l.counter as usize,
-                            out_buf_size_mask
-                        );
-                        out_buf.set_position(out_pos + l.counter as usize);
-                        Action::Jump(DecodeLitlen)
-                    }
-                }
-            }),
-
-            WriteLenBytesToEnd => generate_state!(state, 'state_machine, {
-                if out_buf.bytes_left() > 0 {
-                    let out_pos = out_buf.position();
-                    let source_pos = out_buf.position()
-                        .wrapping_sub(l.dist as usize) & out_buf_size_mask;
-
-
-                    let len = cmp::min(out_buf.bytes_left(), l.counter as usize);
-
-                    transfer(out_buf.get_mut(), source_pos, out_pos, len, out_buf_size_mask);
-
-                    out_buf.set_position(out_pos + len);
-                    l.counter -= len as u32;
-                    if l.counter == 0 {
-                        Action::Jump(DecodeLitlen)
-                    } else {
-                        Action::None
-                    }
-                } else {
-                    Action::End(TINFLStatus::HasMoreOutput)
-                }
-            }),
-
-            BlockDone => generate_state!(state, 'state_machine, {
-                // End once we've read the last block.
-                if r.finish != 0 {
-                    pad_to_bytes(&mut l, &mut in_iter, flags, |_| Action::None);
-
-                    let in_consumed = in_buf.len() - in_iter.len();
-                    let undo = undo_bytes(&mut l, in_consumed as u32) as usize;
-                    in_iter = in_buf[in_consumed - undo..].iter();
-
-                    l.bit_buf &= ((1 as BitBuffer) << l.num_bits) - 1;
-                    debug_assert_eq!(l.num_bits, 0);
-
-                    if flags & TINFL_FLAG_PARSE_ZLIB_HEADER != 0 {
-                        l.counter = 0;
-                        Action::Jump(ReadAdler32)
-                    } else {
-                        Action::Jump(DoneForever)
-                    }
-                } else {
-                    Action::Jump(ReadBlockHeader)
-                }
-            }),
-
-            ReadAdler32 => generate_state!(state, 'state_machine, {
-                if l.counter < 4 {
-                    if l.num_bits != 0 {
-                        read_bits(&mut l, 8, &mut in_iter, flags, |l, bits| {
-                            r.z_adler32 <<= 8;
-                            r.z_adler32 |= bits as u32;
-                            l.counter += 1;
-                            Action::None
-                        })
-                    } else {
-                        read_byte(&mut in_iter, flags, |byte| {
-                            r.z_adler32 <<= 8;
-                            r.z_adler32 |= u32::from(byte);
-                            l.counter += 1;
-                            Action::None
-                        })
-                    }
-                } else {
-                    Action::Jump(DoneForever)
-                }
-            }),
-
-            // We are done.
-            DoneForever => break TINFLStatus::Done,
-
-            // Anything else indicates failure.
-            // BadZlibHeader | BadRawLength | BadDistOrLiteralTableLength | BlockTypeUnexpected |
-            // DistanceOutOfBounds |
-            // BadTotalSymbols | BadCodeSizeDistPrevLookup | BadCodeSizeSum | InvalidLitlen |
-            // InvalidDist | InvalidCodeLen
-            _ => break TINFLStatus::Failed,
-        };
-    };
-
-    let in_undo = if status != TINFLStatus::NeedsMoreInput
-        && status != TINFLStatus::FailedCannotMakeProgress
-    {
-        undo_bytes(&mut l, (in_buf.len() - in_iter.len()) as u32) as usize
-    } else {
-        0
-    };
-
-    // Make sure HasMoreOutput overrides NeedsMoreInput if the output buffer is full.
-    // (Unless the missing input is the adler32 value in which case we don't need to write anything.)
-    // TODO: May want to see if we can do this in a better way.
-    if status == TINFLStatus::NeedsMoreInput
-        && out_buf.bytes_left() == 0
-        && state != State::ReadAdler32
-    {
-        status = TINFLStatus::HasMoreOutput
-    }
-
-    r.state = state;
-    r.bit_buf = l.bit_buf;
-    r.num_bits = l.num_bits;
-    r.dist = l.dist;
-    r.counter = l.counter;
-    r.num_extra = l.num_extra;
-
-    r.bit_buf &= ((1 as BitBuffer) << r.num_bits) - 1;
-
-    // If this is a zlib stream, and update the adler32 checksum with the decompressed bytes if
-    // requested.
-    let need_adler = if (flags & TINFL_FLAG_IGNORE_ADLER32) == 0 {
-        flags & (TINFL_FLAG_PARSE_ZLIB_HEADER | TINFL_FLAG_COMPUTE_ADLER32) != 0
-    } else {
-        // If TINFL_FLAG_IGNORE_ADLER32 is enabled, ignore the checksum.
-        false
-    };
-    if need_adler && status as i32 >= 0 {
-        let out_buf_pos = out_buf.position();
-        r.check_adler32 = update_adler32(r.check_adler32, &out_buf.get_ref()[out_pos..out_buf_pos]);
-
-        // disabled so that random input from fuzzer would not be rejected early,
-        // before it has a chance to reach interesting parts of code
-        if !cfg!(fuzzing) {
-            // Once we are done, check if the checksum matches with the one provided in the zlib header.
-            if status == TINFLStatus::Done
-                && flags & TINFL_FLAG_PARSE_ZLIB_HEADER != 0
-                && r.check_adler32 != r.z_adler32
-            {
-                status = TINFLStatus::Adler32Mismatch;
-            }
-        }
-    }
-
-    (
-        status,
-        in_buf.len() - in_iter.len() - in_undo,
-        out_buf.position() - out_pos,
-    )
-}
-
-#[cfg(test)]
-mod test {
-    use super::*;
-
-    //TODO: Fix these.
-
-    fn tinfl_decompress_oxide<'i>(
-        r: &mut DecompressorOxide,
-        input_buffer: &'i [u8],
-        output_buffer: &mut [u8],
-        flags: u32,
-    ) -> (TINFLStatus, &'i [u8], usize) {
-        let (status, in_pos, out_pos) = decompress(r, input_buffer, output_buffer, 0, flags);
-        (status, &input_buffer[in_pos..], out_pos)
-    }
-
-    #[test]
-    fn decompress_zlib() {
-        let encoded = [
-            120, 156, 243, 72, 205, 201, 201, 215, 81, 168, 202, 201, 76, 82, 4, 0, 27, 101, 4, 19,
-        ];
-        let flags = TINFL_FLAG_COMPUTE_ADLER32 | TINFL_FLAG_PARSE_ZLIB_HEADER;
-
-        let mut b = DecompressorOxide::new();
-        const LEN: usize = 32;
-        let mut b_buf = [0; LEN];
-
-        // This should fail with the out buffer being to small.
-        let b_status = tinfl_decompress_oxide(&mut b, &encoded[..], &mut b_buf, flags);
-
-        assert_eq!(b_status.0, TINFLStatus::Failed);
-
-        let flags = flags | TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF;
-
-        b = DecompressorOxide::new();
-
-        // With TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF set this should no longer fail.
-        let b_status = tinfl_decompress_oxide(&mut b, &encoded[..], &mut b_buf, flags);
-
-        assert_eq!(b_buf[..b_status.2], b"Hello, zlib!"[..]);
-        assert_eq!(b_status.0, TINFLStatus::Done);
-    }
-
-    #[cfg(feature = "with-alloc")]
-    #[test]
-    fn raw_block() {
-        const LEN: usize = 64;
-
-        let text = b"Hello, zlib!";
-        let encoded = {
-            let len = text.len();
-            let notlen = !len;
-            let mut encoded = vec![
-                1,
-                len as u8,
-                (len >> 8) as u8,
-                notlen as u8,
-                (notlen >> 8) as u8,
-            ];
-            encoded.extend_from_slice(&text[..]);
-            encoded
-        };
-
-        //let flags = TINFL_FLAG_COMPUTE_ADLER32 | TINFL_FLAG_PARSE_ZLIB_HEADER |
-        let flags = TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF;
-
-        let mut b = DecompressorOxide::new();
-
-        let mut b_buf = [0; LEN];
-
-        let b_status = tinfl_decompress_oxide(&mut b, &encoded[..], &mut b_buf, flags);
-        assert_eq!(b_buf[..b_status.2], text[..]);
-        assert_eq!(b_status.0, TINFLStatus::Done);
-    }
-
-    fn masked_lookup(table: &HuffmanTable, bit_buf: BitBuffer) -> (i32, u32) {
-        let ret = table.lookup(bit_buf).unwrap();
-        (ret.0 & 511, ret.1)
-    }
-
-    #[test]
-    fn fixed_table_lookup() {
-        let mut d = DecompressorOxide::new();
-        d.block_type = 1;
-        start_static_table(&mut d);
-        let mut l = LocalVars {
-            bit_buf: d.bit_buf,
-            num_bits: d.num_bits,
-            dist: d.dist,
-            counter: d.counter,
-            num_extra: d.num_extra,
-        };
-        init_tree(&mut d, &mut l).unwrap();
-        let llt = &d.tables[LITLEN_TABLE];
-        let dt = &d.tables[DIST_TABLE];
-        assert_eq!(masked_lookup(llt, 0b00001100), (0, 8));
-        assert_eq!(masked_lookup(llt, 0b00011110), (72, 8));
-        assert_eq!(masked_lookup(llt, 0b01011110), (74, 8));
-        assert_eq!(masked_lookup(llt, 0b11111101), (143, 8));
-        assert_eq!(masked_lookup(llt, 0b000010011), (144, 9));
-        assert_eq!(masked_lookup(llt, 0b111111111), (255, 9));
-        assert_eq!(masked_lookup(llt, 0b00000000), (256, 7));
-        assert_eq!(masked_lookup(llt, 0b1110100), (279, 7));
-        assert_eq!(masked_lookup(llt, 0b00000011), (280, 8));
-        assert_eq!(masked_lookup(llt, 0b11100011), (287, 8));
-
-        assert_eq!(masked_lookup(dt, 0), (0, 5));
-        assert_eq!(masked_lookup(dt, 20), (5, 5));
-    }
-
-    // Only run this test with alloc enabled as it uses a larger buffer.
-    #[cfg(feature = "with-alloc")]
-    fn check_result(input: &[u8], expected_status: TINFLStatus, expected_state: State, zlib: bool) {
-        let mut r = DecompressorOxide::default();
-        let mut output_buf = vec![0; 1024 * 32];
-        let flags = if zlib {
-            inflate_flags::TINFL_FLAG_PARSE_ZLIB_HEADER
-        } else {
-            0
-        } | TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF
-            | TINFL_FLAG_HAS_MORE_INPUT;
-        let (d_status, _in_bytes, _out_bytes) =
-            decompress(&mut r, input, &mut output_buf, 0, flags);
-        assert_eq!(expected_status, d_status);
-        assert_eq!(expected_state, r.state);
-    }
-
-    #[cfg(feature = "with-alloc")]
-    #[test]
-    fn bogus_input() {
-        use self::check_result as cr;
-        const F: TINFLStatus = TINFLStatus::Failed;
-        const OK: TINFLStatus = TINFLStatus::Done;
-        // Bad CM.
-        cr(&[0x77, 0x85], F, State::BadZlibHeader, true);
-        // Bad window size (but check is correct).
-        cr(&[0x88, 0x98], F, State::BadZlibHeader, true);
-        // Bad check bits.
-        cr(&[0x78, 0x98], F, State::BadZlibHeader, true);
-
-        // Too many code lengths. (From inflate library issues)
-        cr(
-            b"M\xff\xffM*\xad\xad\xad\xad\xad\xad\xad\xcd\xcd\xcdM",
-            F,
-            State::BadDistOrLiteralTableLength,
-            false,
-        );
-
-        // Bad CLEN (also from inflate library issues)
-        cr(
-            b"\xdd\xff\xff*M\x94ffffffffff",
-            F,
-            State::BadDistOrLiteralTableLength,
-            false,
-        );
-
-        // Port of inflate coverage tests from zlib-ng
-        // https://github.com/Dead2/zlib-ng/blob/develop/test/infcover.c
-        let c = |a, b, c| cr(a, b, c, false);
-
-        // Invalid uncompressed/raw block length.
-        c(&[0, 0, 0, 0, 0], F, State::BadRawLength);
-        // Ok empty uncompressed block.
-        c(&[3, 0], OK, State::DoneForever);
-        // Invalid block type.
-        c(&[6], F, State::BlockTypeUnexpected);
-        // Ok uncompressed block.
-        c(&[1, 1, 0, 0xfe, 0xff, 0], OK, State::DoneForever);
-        // Too many litlens, we handle this later than zlib, so this test won't
-        // give the same result.
-        //        c(&[0xfc, 0, 0], F, State::BadTotalSymbols);
-        // Invalid set of code lengths - TODO Check if this is the correct error for this.
-        c(&[4, 0, 0xfe, 0xff], F, State::BadTotalSymbols);
-        // Invalid repeat in list of code lengths.
-        // (Try to repeat a non-existent code.)
-        c(&[4, 0, 0x24, 0x49, 0], F, State::BadCodeSizeDistPrevLookup);
-        // Missing end of block code (should we have a separate error for this?) - fails on further input
-        //    c(&[4, 0, 0x24, 0xe9, 0xff, 0x6d], F, State::BadTotalSymbols);
-        // Invalid set of literals/lengths
-        c(
-            &[
-                4, 0x80, 0x49, 0x92, 0x24, 0x49, 0x92, 0x24, 0x71, 0xff, 0xff, 0x93, 0x11, 0,
-            ],
-            F,
-            State::BadTotalSymbols,
-        );
-        // Invalid set of distances _ needsmoreinput
-        // c(&[4, 0x80, 0x49, 0x92, 0x24, 0x49, 0x92, 0x24, 0x0f, 0xb4, 0xff, 0xff, 0xc3, 0x84], F, State::BadTotalSymbols);
-        // Invalid distance code
-        c(&[2, 0x7e, 0xff, 0xff], F, State::InvalidDist);
-
-        // Distance refers to position before the start
-        c(
-            &[0x0c, 0xc0, 0x81, 0, 0, 0, 0, 0, 0x90, 0xff, 0x6b, 0x4, 0],
-            F,
-            State::DistanceOutOfBounds,
-        );
-
-        // Trailer
-        // Bad gzip trailer checksum GZip header not handled by miniz_oxide
-        //cr(&[0x1f, 0x8b, 0x08 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0x03, 0, 0, 0, 0, 0x01], F, State::BadCRC, false)
-        // Bad gzip trailer length
-        //cr(&[0x1f, 0x8b, 0x08 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0x03, 0, 0, 0, 0, 0, 0, 0, 0, 0x01], F, State::BadCRC, false)
-    }
-
-    #[test]
-    fn empty_output_buffer_non_wrapping() {
-        let encoded = [
-            120, 156, 243, 72, 205, 201, 201, 215, 81, 168, 202, 201, 76, 82, 4, 0, 27, 101, 4, 19,
-        ];
-        let flags = TINFL_FLAG_COMPUTE_ADLER32
-            | TINFL_FLAG_PARSE_ZLIB_HEADER
-            | TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF;
-        let mut r = DecompressorOxide::new();
-        let mut output_buf: [u8; 0] = [];
-        // Check that we handle an empty buffer properly and not panicking.
-        // https://github.com/Frommi/miniz_oxide/issues/23
-        let res = decompress(&mut r, &encoded, &mut output_buf, 0, flags);
-        assert_eq!(res, (TINFLStatus::HasMoreOutput, 4, 0));
-    }
-
-    #[test]
-    fn empty_output_buffer_wrapping() {
-        let encoded = [
-            0x73, 0x49, 0x4d, 0xcb, 0x49, 0x2c, 0x49, 0x55, 0x00, 0x11, 0x00,
-        ];
-        let flags = TINFL_FLAG_COMPUTE_ADLER32;
-        let mut r = DecompressorOxide::new();
-        let mut output_buf: [u8; 0] = [];
-        // Check that we handle an empty buffer properly and not panicking.
-        // https://github.com/Frommi/miniz_oxide/issues/23
-        let res = decompress(&mut r, &encoded, &mut output_buf, 0, flags);
-        assert_eq!(res, (TINFLStatus::HasMoreOutput, 2, 0));
-    }
-}
diff --git a/third_party/rust/chromium_crates_io/vendor/miniz_oxide-0.7.4/src/inflate/mod.rs b/third_party/rust/chromium_crates_io/vendor/miniz_oxide-0.7.4/src/inflate/mod.rs
deleted file mode 100644
index 3f787e726f1038..00000000000000
--- a/third_party/rust/chromium_crates_io/vendor/miniz_oxide-0.7.4/src/inflate/mod.rs
+++ /dev/null
@@ -1,343 +0,0 @@
-//! This module contains functionality for decompression.
-
-#[cfg(feature = "with-alloc")]
-use crate::alloc::{boxed::Box, vec, vec::Vec};
-use ::core::usize;
-#[cfg(all(feature = "std", feature = "with-alloc"))]
-use std::error::Error;
-
-pub mod core;
-mod output_buffer;
-pub mod stream;
-use self::core::*;
-
-const TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS: i32 = -4;
-const TINFL_STATUS_BAD_PARAM: i32 = -3;
-const TINFL_STATUS_ADLER32_MISMATCH: i32 = -2;
-const TINFL_STATUS_FAILED: i32 = -1;
-const TINFL_STATUS_DONE: i32 = 0;
-const TINFL_STATUS_NEEDS_MORE_INPUT: i32 = 1;
-const TINFL_STATUS_HAS_MORE_OUTPUT: i32 = 2;
-
-/// Return status codes.
-#[repr(i8)]
-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
-pub enum TINFLStatus {
-    /// More input data was expected, but the caller indicated that there was no more data, so the
-    /// input stream is likely truncated.
-    ///
-    /// This can't happen if you have provided the
-    /// [`TINFL_FLAG_HAS_MORE_INPUT`][core::inflate_flags::TINFL_FLAG_HAS_MORE_INPUT] flag to the
-    /// decompression.  By setting that flag, you indicate more input exists but is not provided,
-    /// and so reaching the end of the input data without finding the end of the compressed stream
-    /// would instead return a [`NeedsMoreInput`][Self::NeedsMoreInput] status.
-    FailedCannotMakeProgress = TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS as i8,
-
-    /// The output buffer is an invalid size; consider the `flags` parameter.
-    BadParam = TINFL_STATUS_BAD_PARAM as i8,
-
-    /// The decompression went fine, but the adler32 checksum did not match the one
-    /// provided in the header.
-    Adler32Mismatch = TINFL_STATUS_ADLER32_MISMATCH as i8,
-
-    /// Failed to decompress due to invalid data.
-    Failed = TINFL_STATUS_FAILED as i8,
-
-    /// Finished decompression without issues.
-    ///
-    /// This indicates the end of the compressed stream has been reached.
-    Done = TINFL_STATUS_DONE as i8,
-
-    /// The decompressor needs more input data to continue decompressing.
-    ///
-    /// This occurs when there's no more consumable input, but the end of the stream hasn't been
-    /// reached, and you have supplied the
-    /// [`TINFL_FLAG_HAS_MORE_INPUT`][core::inflate_flags::TINFL_FLAG_HAS_MORE_INPUT] flag to the
-    /// decompressor.  Had you not supplied that flag (which would mean you were asserting that you
-    /// believed all the data was available) you would have gotten a
-    /// [`FailedCannotMakeProcess`][Self::FailedCannotMakeProgress] instead.
-    NeedsMoreInput = TINFL_STATUS_NEEDS_MORE_INPUT as i8,
-
-    /// There is still pending data that didn't fit in the output buffer.
-    HasMoreOutput = TINFL_STATUS_HAS_MORE_OUTPUT as i8,
-}
-
-impl TINFLStatus {
-    pub fn from_i32(value: i32) -> Option<TINFLStatus> {
-        use self::TINFLStatus::*;
-        match value {
-            TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS => Some(FailedCannotMakeProgress),
-            TINFL_STATUS_BAD_PARAM => Some(BadParam),
-            TINFL_STATUS_ADLER32_MISMATCH => Some(Adler32Mismatch),
-            TINFL_STATUS_FAILED => Some(Failed),
-            TINFL_STATUS_DONE => Some(Done),
-            TINFL_STATUS_NEEDS_MORE_INPUT => Some(NeedsMoreInput),
-            TINFL_STATUS_HAS_MORE_OUTPUT => Some(HasMoreOutput),
-            _ => None,
-        }
-    }
-}
-
-/// Struct return when decompress_to_vec functions fail.
-#[cfg(feature = "with-alloc")]
-#[derive(Debug)]
-pub struct DecompressError {
-    /// Decompressor status on failure. See [TINFLStatus] for details.
-    pub status: TINFLStatus,
-    /// The currently decompressed data if any.
-    pub output: Vec<u8>,
-}
-
-#[cfg(feature = "with-alloc")]
-impl alloc::fmt::Display for DecompressError {
-    #[cold]
-    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
-        f.write_str(match self.status {
-            TINFLStatus::FailedCannotMakeProgress => "Truncated input stream",
-            TINFLStatus::BadParam => "Invalid output buffer size",
-            TINFLStatus::Adler32Mismatch => "Adler32 checksum mismatch",
-            TINFLStatus::Failed => "Invalid input data",
-            TINFLStatus::Done => "", // Unreachable
-            TINFLStatus::NeedsMoreInput => "Truncated input stream",
-            TINFLStatus::HasMoreOutput => "Output size exceeded the specified limit",
-        })
-    }
-}
-
-/// Implement Error trait only if std feature is requested as it requires std.
-#[cfg(all(feature = "std", feature = "with-alloc"))]
-impl Error for DecompressError {}
-
-#[cfg(feature = "with-alloc")]
-fn decompress_error(status: TINFLStatus, output: Vec<u8>) -> Result<Vec<u8>, DecompressError> {
-    Err(DecompressError { status, output })
-}
-
-/// Decompress the deflate-encoded data in `input` to a vector.
-///
-/// NOTE: This function will not bound the output, so if the output is large enough it can result in an out of memory error.
-/// It is therefore suggested to not use this for anything other than test programs, use the functions with a specified limit, or
-/// ideally streaming decompression via the [flate2](https://github.com/alexcrichton/flate2-rs) library instead.
-///
-/// Returns a [`Result`] containing the [`Vec`] of decompressed data on success, and a [struct][DecompressError] containing the status and so far decompressed data if any on failure.
-#[inline]
-#[cfg(feature = "with-alloc")]
-pub fn decompress_to_vec(input: &[u8]) -> Result<Vec<u8>, DecompressError> {
-    decompress_to_vec_inner(input, 0, usize::max_value())
-}
-
-/// Decompress the deflate-encoded data (with a zlib wrapper) in `input` to a vector.
-///
-/// NOTE: This function will not bound the output, so if the output is large enough it can result in an out of memory error.
-/// It is therefore suggested to not use this for anything other than test programs, use the functions with a specified limit, or
-/// ideally streaming decompression via the [flate2](https://github.com/alexcrichton/flate2-rs) library instead.
-///
-/// Returns a [`Result`] containing the [`Vec`] of decompressed data on success, and a [struct][DecompressError] containing the status and so far decompressed data if any on failure.
-#[inline]
-#[cfg(feature = "with-alloc")]
-pub fn decompress_to_vec_zlib(input: &[u8]) -> Result<Vec<u8>, DecompressError> {
-    decompress_to_vec_inner(
-        input,
-        inflate_flags::TINFL_FLAG_PARSE_ZLIB_HEADER,
-        usize::max_value(),
-    )
-}
-
-/// Decompress the deflate-encoded data in `input` to a vector.
-///
-/// The vector is grown to at most `max_size` bytes; if the data does not fit in that size,
-/// the error [struct][DecompressError] will contain the status [`TINFLStatus::HasMoreOutput`] and the data that was decompressed on failure.
-///
-/// As this function tries to decompress everything in one go, it's not ideal for general use outside of tests or where the output size is expected to be small.
-/// It is suggested to use streaming decompression via the [flate2](https://github.com/alexcrichton/flate2-rs) library instead.
-///
-/// Returns a [`Result`] containing the [`Vec`] of decompressed data on success, and a [struct][DecompressError] on failure.
-#[inline]
-#[cfg(feature = "with-alloc")]
-pub fn decompress_to_vec_with_limit(
-    input: &[u8],
-    max_size: usize,
-) -> Result<Vec<u8>, DecompressError> {
-    decompress_to_vec_inner(input, 0, max_size)
-}
-
-/// Decompress the deflate-encoded data (with a zlib wrapper) in `input` to a vector.
-/// The vector is grown to at most `max_size` bytes; if the data does not fit in that size,
-/// the error [struct][DecompressError] will contain the status [`TINFLStatus::HasMoreOutput`] and the data that was decompressed on failure.
-///
-/// As this function tries to decompress everything in one go, it's not ideal for general use outside of tests or where the output size is expected to be small.
-/// It is suggested to use streaming decompression via the [flate2](https://github.com/alexcrichton/flate2-rs) library instead.
-///
-/// Returns a [`Result`] containing the [`Vec`] of decompressed data on success, and a [struct][DecompressError] on failure.
-#[inline]
-#[cfg(feature = "with-alloc")]
-pub fn decompress_to_vec_zlib_with_limit(
-    input: &[u8],
-    max_size: usize,
-) -> Result<Vec<u8>, DecompressError> {
-    decompress_to_vec_inner(input, inflate_flags::TINFL_FLAG_PARSE_ZLIB_HEADER, max_size)
-}
-
-/// Backend of various to-[`Vec`] decompressions.
-///
-/// Returns [`Vec`] of decompressed data on success and the [error struct][DecompressError] with details on failure.
-#[cfg(feature = "with-alloc")]
-fn decompress_to_vec_inner(
-    mut input: &[u8],
-    flags: u32,
-    max_output_size: usize,
-) -> Result<Vec<u8>, DecompressError> {
-    let flags = flags | inflate_flags::TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF;
-    let mut ret: Vec<u8> = vec![0; input.len().saturating_mul(2).min(max_output_size)];
-
-    let mut decomp = Box::<DecompressorOxide>::default();
-
-    let mut out_pos = 0;
-    loop {
-        // Wrap the whole output slice so we know we have enough of the
-        // decompressed data for matches.
-        let (status, in_consumed, out_consumed) =
-            decompress(&mut decomp, input, &mut ret, out_pos, flags);
-        out_pos += out_consumed;
-
-        match status {
-            TINFLStatus::Done => {
-                ret.truncate(out_pos);
-                return Ok(ret);
-            }
-
-            TINFLStatus::HasMoreOutput => {
-                // in_consumed is not expected to be out of bounds,
-                // but the check eliminates a panicking code path
-                if in_consumed > input.len() {
-                    return decompress_error(TINFLStatus::HasMoreOutput, ret);
-                }
-                input = &input[in_consumed..];
-
-                // if the buffer has already reached the size limit, return an error
-                if ret.len() >= max_output_size {
-                    return decompress_error(TINFLStatus::HasMoreOutput, ret);
-                }
-                // calculate the new length, capped at `max_output_size`
-                let new_len = ret.len().saturating_mul(2).min(max_output_size);
-                ret.resize(new_len, 0);
-            }
-
-            _ => return decompress_error(status, ret),
-        }
-    }
-}
-
-/// Decompress one or more source slices from an iterator into the output slice.
-///
-/// * On success, returns the number of bytes that were written.
-/// * On failure, returns the failure status code.
-///
-/// This will fail if the output buffer is not large enough, but in that case
-/// the output buffer will still contain the partial decompression.
-///
-/// * `out` the output buffer.
-/// * `it` the iterator of input slices.
-/// * `zlib_header` if the first slice out of the iterator is expected to have a
-///   Zlib header. Otherwise the slices are assumed to be the deflate data only.
-/// * `ignore_adler32` if the adler32 checksum should be calculated or not.
-pub fn decompress_slice_iter_to_slice<'out, 'inp>(
-    out: &'out mut [u8],
-    it: impl Iterator<Item = &'inp [u8]>,
-    zlib_header: bool,
-    ignore_adler32: bool,
-) -> Result<usize, TINFLStatus> {
-    use self::core::inflate_flags::*;
-
-    let mut it = it.peekable();
-    let r = &mut DecompressorOxide::new();
-    let mut out_pos = 0;
-    while let Some(in_buf) = it.next() {
-        let has_more = it.peek().is_some();
-        let flags = {
-            let mut f = TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF;
-            if zlib_header {
-                f |= TINFL_FLAG_PARSE_ZLIB_HEADER;
-            }
-            if ignore_adler32 {
-                f |= TINFL_FLAG_IGNORE_ADLER32;
-            }
-            if has_more {
-                f |= TINFL_FLAG_HAS_MORE_INPUT;
-            }
-            f
-        };
-        let (status, _input_read, bytes_written) = decompress(r, in_buf, out, out_pos, flags);
-        out_pos += bytes_written;
-        match status {
-            TINFLStatus::NeedsMoreInput => continue,
-            TINFLStatus::Done => return Ok(out_pos),
-            e => return Err(e),
-        }
-    }
-    // If we ran out of source slices without getting a `Done` from the
-    // decompression we can call it a failure.
-    Err(TINFLStatus::FailedCannotMakeProgress)
-}
-
-#[cfg(all(test, feature = "with-alloc"))]
-mod test {
-    use super::{
-        decompress_slice_iter_to_slice, decompress_to_vec_zlib, decompress_to_vec_zlib_with_limit,
-        DecompressError, TINFLStatus,
-    };
-    const ENCODED: [u8; 20] = [
-        120, 156, 243, 72, 205, 201, 201, 215, 81, 168, 202, 201, 76, 82, 4, 0, 27, 101, 4, 19,
-    ];
-
-    #[test]
-    fn decompress_vec() {
-        let res = decompress_to_vec_zlib(&ENCODED[..]).unwrap();
-        assert_eq!(res.as_slice(), &b"Hello, zlib!"[..]);
-    }
-
-    #[test]
-    fn decompress_vec_with_high_limit() {
-        let res = decompress_to_vec_zlib_with_limit(&ENCODED[..], 100_000).unwrap();
-        assert_eq!(res.as_slice(), &b"Hello, zlib!"[..]);
-    }
-
-    #[test]
-    fn fail_to_decompress_with_limit() {
-        let res = decompress_to_vec_zlib_with_limit(&ENCODED[..], 8);
-        match res {
-            Err(DecompressError {
-                status: TINFLStatus::HasMoreOutput,
-                ..
-            }) => (), // expected result
-            _ => panic!("Decompression output size limit was not enforced"),
-        }
-    }
-
-    #[test]
-    fn test_decompress_slice_iter_to_slice() {
-        // one slice
-        let mut out = [0_u8; 12_usize];
-        let r =
-            decompress_slice_iter_to_slice(&mut out, Some(&ENCODED[..]).into_iter(), true, false);
-        assert_eq!(r, Ok(12));
-        assert_eq!(&out[..12], &b"Hello, zlib!"[..]);
-
-        // some chunks at a time
-        for chunk_size in 1..13 {
-            // Note: because of https://github.com/Frommi/miniz_oxide/issues/110 our
-            // out buffer needs to have +1 byte available when the chunk size cuts
-            // the adler32 data off from the last actual data.
-            let mut out = [0_u8; 12_usize + 1];
-            let r =
-                decompress_slice_iter_to_slice(&mut out, ENCODED.chunks(chunk_size), true, false);
-            assert_eq!(r, Ok(12));
-            assert_eq!(&out[..12], &b"Hello, zlib!"[..]);
-        }
-
-        // output buffer too small
-        let mut out = [0_u8; 3_usize];
-        let r = decompress_slice_iter_to_slice(&mut out, ENCODED.chunks(7), true, false);
-        assert!(r.is_err());
-    }
-}
diff --git a/third_party/rust/chromium_crates_io/vendor/miniz_oxide-0.7.4/src/inflate/output_buffer.rs b/third_party/rust/chromium_crates_io/vendor/miniz_oxide-0.7.4/src/inflate/output_buffer.rs
deleted file mode 100644
index 5218a807d3f787..00000000000000
--- a/third_party/rust/chromium_crates_io/vendor/miniz_oxide-0.7.4/src/inflate/output_buffer.rs
+++ /dev/null
@@ -1,60 +0,0 @@
-/// A wrapper for the output slice used when decompressing.
-///
-/// Using this rather than `Cursor` lets us implement the writing methods directly on
-/// the buffer and lets us use a usize rather than u64 for the position which helps with
-/// performance on 32-bit systems.
-pub struct OutputBuffer<'a> {
-    slice: &'a mut [u8],
-    position: usize,
-}
-
-impl<'a> OutputBuffer<'a> {
-    #[inline]
-    pub fn from_slice_and_pos(slice: &'a mut [u8], position: usize) -> OutputBuffer<'a> {
-        OutputBuffer { slice, position }
-    }
-
-    #[inline]
-    pub const fn position(&self) -> usize {
-        self.position
-    }
-
-    #[inline]
-    pub fn set_position(&mut self, position: usize) {
-        self.position = position;
-    }
-
-    /// Write a byte to the current position and increment
-    ///
-    /// Assumes that there is space.
-    #[inline]
-    pub fn write_byte(&mut self, byte: u8) {
-        self.slice[self.position] = byte;
-        self.position += 1;
-    }
-
-    /// Write a slice to the current position and increment
-    ///
-    /// Assumes that there is space.
-    #[inline]
-    pub fn write_slice(&mut self, data: &[u8]) {
-        let len = data.len();
-        self.slice[self.position..self.position + len].copy_from_slice(data);
-        self.position += data.len();
-    }
-
-    #[inline]
-    pub const fn bytes_left(&self) -> usize {
-        self.slice.len() - self.position
-    }
-
-    #[inline]
-    pub const fn get_ref(&self) -> &[u8] {
-        self.slice
-    }
-
-    #[inline]
-    pub fn get_mut(&mut self) -> &mut [u8] {
-        self.slice
-    }
-}
diff --git a/third_party/rust/chromium_crates_io/vendor/miniz_oxide-0.7.4/src/inflate/stream.rs b/third_party/rust/chromium_crates_io/vendor/miniz_oxide-0.7.4/src/inflate/stream.rs
deleted file mode 100644
index 5463ab0fdfd29c..00000000000000
--- a/third_party/rust/chromium_crates_io/vendor/miniz_oxide-0.7.4/src/inflate/stream.rs
+++ /dev/null
@@ -1,423 +0,0 @@
-//! Extra streaming decompression functionality.
-//!
-//! As of now this is mainly intended for use to build a higher-level wrapper.
-#[cfg(feature = "with-alloc")]
-use crate::alloc::boxed::Box;
-use core::{cmp, mem};
-
-use crate::inflate::core::{decompress, inflate_flags, DecompressorOxide, TINFL_LZ_DICT_SIZE};
-use crate::inflate::TINFLStatus;
-use crate::{DataFormat, MZError, MZFlush, MZResult, MZStatus, StreamResult};
-
-/// Tag that determines reset policy of [InflateState](struct.InflateState.html)
-pub trait ResetPolicy {
-    /// Performs reset
-    fn reset(&self, state: &mut InflateState);
-}
-
-/// Resets state, without performing expensive ops (e.g. zeroing buffer)
-///
-/// Note that not zeroing buffer can lead to security issues when dealing with untrusted input.
-pub struct MinReset;
-
-impl ResetPolicy for MinReset {
-    fn reset(&self, state: &mut InflateState) {
-        state.decompressor().init();
-        state.dict_ofs = 0;
-        state.dict_avail = 0;
-        state.first_call = true;
-        state.has_flushed = false;
-        state.last_status = TINFLStatus::NeedsMoreInput;
-    }
-}
-
-/// Resets state and zero memory, continuing to use the same data format.
-pub struct ZeroReset;
-
-impl ResetPolicy for ZeroReset {
-    #[inline]
-    fn reset(&self, state: &mut InflateState) {
-        MinReset.reset(state);
-        state.dict = [0; TINFL_LZ_DICT_SIZE];
-    }
-}
-
-/// Full reset of the state, including zeroing memory.
-///
-/// Requires to provide new data format.
-pub struct FullReset(pub DataFormat);
-
-impl ResetPolicy for FullReset {
-    #[inline]
-    fn reset(&self, state: &mut InflateState) {
-        ZeroReset.reset(state);
-        state.data_format = self.0;
-    }
-}
-
-/// A struct that compbines a decompressor with extra data for streaming decompression.
-///
-pub struct InflateState {
-    /// Inner decompressor struct
-    decomp: DecompressorOxide,
-
-    /// Buffer of input bytes for matches.
-    /// TODO: Could probably do this a bit cleaner with some
-    /// Cursor-like class.
-    /// We may also look into whether we need to keep a buffer here, or just one in the
-    /// decompressor struct.
-    dict: [u8; TINFL_LZ_DICT_SIZE],
-    /// Where in the buffer are we currently at?
-    dict_ofs: usize,
-    /// How many bytes of data to be flushed is there currently in the buffer?
-    dict_avail: usize,
-
-    first_call: bool,
-    has_flushed: bool,
-
-    /// Whether the input data is wrapped in a zlib header and checksum.
-    /// TODO: This should be stored in the decompressor.
-    data_format: DataFormat,
-    last_status: TINFLStatus,
-}
-
-impl Default for InflateState {
-    fn default() -> Self {
-        InflateState {
-            decomp: DecompressorOxide::default(),
-            dict: [0; TINFL_LZ_DICT_SIZE],
-            dict_ofs: 0,
-            dict_avail: 0,
-            first_call: true,
-            has_flushed: false,
-            data_format: DataFormat::Raw,
-            last_status: TINFLStatus::NeedsMoreInput,
-        }
-    }
-}
-impl InflateState {
-    /// Create a new state.
-    ///
-    /// Note that this struct is quite large due to internal buffers, and as such storing it on
-    /// the stack is not recommended.
-    ///
-    /// # Parameters
-    /// `data_format`: Determines whether the compressed data is assumed to wrapped with zlib
-    /// metadata.
-    pub fn new(data_format: DataFormat) -> InflateState {
-        InflateState {
-            data_format,
-            ..Default::default()
-        }
-    }
-
-    /// Create a new state on the heap.
-    ///
-    /// # Parameters
-    /// `data_format`: Determines whether the compressed data is assumed to wrapped with zlib
-    /// metadata.
-    #[cfg(feature = "with-alloc")]
-    pub fn new_boxed(data_format: DataFormat) -> Box<InflateState> {
-        let mut b: Box<InflateState> = Box::default();
-        b.data_format = data_format;
-        b
-    }
-
-    /// Access the innner decompressor.
-    pub fn decompressor(&mut self) -> &mut DecompressorOxide {
-        &mut self.decomp
-    }
-
-    /// Return the status of the last call to `inflate` with this `InflateState`.
-    pub const fn last_status(&self) -> TINFLStatus {
-        self.last_status
-    }
-
-    /// Create a new state using miniz/zlib style window bits parameter.
-    ///
-    /// The decompressor does not support different window sizes. As such,
-    /// any positive (>0) value will set the zlib header flag, while a negative one
-    /// will not.
-    #[cfg(feature = "with-alloc")]
-    pub fn new_boxed_with_window_bits(window_bits: i32) -> Box<InflateState> {
-        let mut b: Box<InflateState> = Box::default();
-        b.data_format = DataFormat::from_window_bits(window_bits);
-        b
-    }
-
-    #[inline]
-    /// Reset the decompressor without re-allocating memory, using the given
-    /// data format.
-    pub fn reset(&mut self, data_format: DataFormat) {
-        self.reset_as(FullReset(data_format));
-    }
-
-    #[inline]
-    /// Resets the state according to specified policy.
-    pub fn reset_as<T: ResetPolicy>(&mut self, policy: T) {
-        policy.reset(self)
-    }
-}
-
-/// Try to decompress from `input` to `output` with the given [`InflateState`]
-///
-/// # `flush`
-///
-/// Generally, the various [`MZFlush`] flags have meaning only on the compression side.  They can be
-/// supplied here, but the only one that has any semantic meaning is [`MZFlush::Finish`], which is a
-/// signal that the stream is expected to finish, and failing to do so is an error.  It isn't
-/// necessary to specify it when the stream ends; you'll still get returned a
-/// [`MZStatus::StreamEnd`] anyway.  Other values either have no effect or cause errors.  It's
-/// likely that you'll almost always just want to use [`MZFlush::None`].
-///
-/// # Errors
-///
-/// Returns [`MZError::Buf`] if the size of the `output` slice is empty or no progress was made due
-/// to lack of expected input data, or if called with [`MZFlush::Finish`] and input wasn't all
-/// consumed.
-///
-/// Returns [`MZError::Data`] if this or a a previous call failed with an error return from
-/// [`TINFLStatus`]; probably indicates corrupted data.
-///
-/// Returns [`MZError::Stream`] when called with [`MZFlush::Full`] (meaningless on
-/// decompression), or when called without [`MZFlush::Finish`] after an earlier call with
-/// [`MZFlush::Finish`] has been made.
-pub fn inflate(
-    state: &mut InflateState,
-    input: &[u8],
-    output: &mut [u8],
-    flush: MZFlush,
-) -> StreamResult {
-    let mut bytes_consumed = 0;
-    let mut bytes_written = 0;
-    let mut next_in = input;
-    let mut next_out = output;
-
-    if flush == MZFlush::Full {
-        return StreamResult::error(MZError::Stream);
-    }
-
-    let mut decomp_flags = if state.data_format == DataFormat::Zlib {
-        inflate_flags::TINFL_FLAG_COMPUTE_ADLER32
-    } else {
-        inflate_flags::TINFL_FLAG_IGNORE_ADLER32
-    };
-
-    if (state.data_format == DataFormat::Zlib)
-        | (state.data_format == DataFormat::ZLibIgnoreChecksum)
-    {
-        decomp_flags |= inflate_flags::TINFL_FLAG_PARSE_ZLIB_HEADER;
-    }
-
-    let first_call = state.first_call;
-    state.first_call = false;
-    if state.last_status == TINFLStatus::FailedCannotMakeProgress {
-        return StreamResult::error(MZError::Buf);
-    }
-    if (state.last_status as i32) < 0 {
-        return StreamResult::error(MZError::Data);
-    }
-
-    if state.has_flushed && (flush != MZFlush::Finish) {
-        return StreamResult::error(MZError::Stream);
-    }
-    state.has_flushed |= flush == MZFlush::Finish;
-
-    if (flush == MZFlush::Finish) && first_call {
-        decomp_flags |= inflate_flags::TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF;
-
-        let status = decompress(&mut state.decomp, next_in, next_out, 0, decomp_flags);
-        let in_bytes = status.1;
-        let out_bytes = status.2;
-        let status = status.0;
-
-        state.last_status = status;
-
-        bytes_consumed += in_bytes;
-        bytes_written += out_bytes;
-
-        let ret_status = {
-            if status == TINFLStatus::FailedCannotMakeProgress {
-                Err(MZError::Buf)
-            } else if (status as i32) < 0 {
-                Err(MZError::Data)
-            } else if status != TINFLStatus::Done {
-                state.last_status = TINFLStatus::Failed;
-                Err(MZError::Buf)
-            } else {
-                Ok(MZStatus::StreamEnd)
-            }
-        };
-        return StreamResult {
-            bytes_consumed,
-            bytes_written,
-            status: ret_status,
-        };
-    }
-
-    if flush != MZFlush::Finish {
-        decomp_flags |= inflate_flags::TINFL_FLAG_HAS_MORE_INPUT;
-    }
-
-    if state.dict_avail != 0 {
-        bytes_written += push_dict_out(state, &mut next_out);
-        return StreamResult {
-            bytes_consumed,
-            bytes_written,
-            status: Ok(
-                if (state.last_status == TINFLStatus::Done) && (state.dict_avail == 0) {
-                    MZStatus::StreamEnd
-                } else {
-                    MZStatus::Ok
-                },
-            ),
-        };
-    }
-
-    let status = inflate_loop(
-        state,
-        &mut next_in,
-        &mut next_out,
-        &mut bytes_consumed,
-        &mut bytes_written,
-        decomp_flags,
-        flush,
-    );
-    StreamResult {
-        bytes_consumed,
-        bytes_written,
-        status,
-    }
-}
-
-fn inflate_loop(
-    state: &mut InflateState,
-    next_in: &mut &[u8],
-    next_out: &mut &mut [u8],
-    total_in: &mut usize,
-    total_out: &mut usize,
-    decomp_flags: u32,
-    flush: MZFlush,
-) -> MZResult {
-    let orig_in_len = next_in.len();
-    loop {
-        let status = decompress(
-            &mut state.decomp,
-            next_in,
-            &mut state.dict,
-            state.dict_ofs,
-            decomp_flags,
-        );
-
-        let in_bytes = status.1;
-        let out_bytes = status.2;
-        let status = status.0;
-
-        state.last_status = status;
-
-        *next_in = &next_in[in_bytes..];
-        *total_in += in_bytes;
-
-        state.dict_avail = out_bytes;
-        *total_out += push_dict_out(state, next_out);
-
-        // The stream was corrupted, and decompression failed.
-        if (status as i32) < 0 {
-            return Err(MZError::Data);
-        }
-
-        // The decompressor has flushed all it's data and is waiting for more input, but
-        // there was no more input provided.
-        if (status == TINFLStatus::NeedsMoreInput) && orig_in_len == 0 {
-            return Err(MZError::Buf);
-        }
-
-        if flush == MZFlush::Finish {
-            if status == TINFLStatus::Done {
-                // There is not enough space in the output buffer to flush the remaining
-                // decompressed data in the internal buffer.
-                return if state.dict_avail != 0 {
-                    Err(MZError::Buf)
-                } else {
-                    Ok(MZStatus::StreamEnd)
-                };
-            // No more space in the output buffer, but we're not done.
-            } else if next_out.is_empty() {
-                return Err(MZError::Buf);
-            }
-        } else {
-            // We're not expected to finish, so it's fine if we can't flush everything yet.
-            let empty_buf = next_in.is_empty() || next_out.is_empty();
-            if (status == TINFLStatus::Done) || empty_buf || (state.dict_avail != 0) {
-                return if (status == TINFLStatus::Done) && (state.dict_avail == 0) {
-                    // No more data left, we're done.
-                    Ok(MZStatus::StreamEnd)
-                } else {
-                    // Ok for now, still waiting for more input data or output space.
-                    Ok(MZStatus::Ok)
-                };
-            }
-        }
-    }
-}
-
-fn push_dict_out(state: &mut InflateState, next_out: &mut &mut [u8]) -> usize {
-    let n = cmp::min(state.dict_avail, next_out.len());
-    (next_out[..n]).copy_from_slice(&state.dict[state.dict_ofs..state.dict_ofs + n]);
-    *next_out = &mut mem::take(next_out)[n..];
-    state.dict_avail -= n;
-    state.dict_ofs = (state.dict_ofs + (n)) & (TINFL_LZ_DICT_SIZE - 1);
-    n
-}
-
-#[cfg(all(test, feature = "with-alloc"))]
-mod test {
-    use super::{inflate, InflateState};
-    use crate::{DataFormat, MZFlush, MZStatus};
-    use alloc::vec;
-
-    #[test]
-    fn test_state() {
-        let encoded = [
-            120u8, 156, 243, 72, 205, 201, 201, 215, 81, 168, 202, 201, 76, 82, 4, 0, 27, 101, 4,
-            19,
-        ];
-        let mut out = vec![0; 50];
-        let mut state = InflateState::new_boxed(DataFormat::Zlib);
-        let res = inflate(&mut state, &encoded, &mut out, MZFlush::Finish);
-        let status = res.status.expect("Failed to decompress!");
-        assert_eq!(status, MZStatus::StreamEnd);
-        assert_eq!(out[..res.bytes_written as usize], b"Hello, zlib!"[..]);
-        assert_eq!(res.bytes_consumed, encoded.len());
-
-        state.reset_as(super::ZeroReset);
-        out.iter_mut().map(|x| *x = 0).count();
-        let res = inflate(&mut state, &encoded, &mut out, MZFlush::Finish);
-        let status = res.status.expect("Failed to decompress!");
-        assert_eq!(status, MZStatus::StreamEnd);
-        assert_eq!(out[..res.bytes_written as usize], b"Hello, zlib!"[..]);
-        assert_eq!(res.bytes_consumed, encoded.len());
-
-        state.reset_as(super::MinReset);
-        out.iter_mut().map(|x| *x = 0).count();
-        let res = inflate(&mut state, &encoded, &mut out, MZFlush::Finish);
-        let status = res.status.expect("Failed to decompress!");
-        assert_eq!(status, MZStatus::StreamEnd);
-        assert_eq!(out[..res.bytes_written as usize], b"Hello, zlib!"[..]);
-        assert_eq!(res.bytes_consumed, encoded.len());
-        assert_eq!(state.decompressor().adler32(), Some(459605011));
-
-        // Test state when not computing adler.
-        state = InflateState::new_boxed(DataFormat::ZLibIgnoreChecksum);
-        out.iter_mut().map(|x| *x = 0).count();
-        let res = inflate(&mut state, &encoded, &mut out, MZFlush::Finish);
-        let status = res.status.expect("Failed to decompress!");
-        assert_eq!(status, MZStatus::StreamEnd);
-        assert_eq!(out[..res.bytes_written as usize], b"Hello, zlib!"[..]);
-        assert_eq!(res.bytes_consumed, encoded.len());
-        // Not computed, so should be Some(1)
-        assert_eq!(state.decompressor().adler32(), Some(1));
-        // Should still have the checksum read from the header file.
-        assert_eq!(state.decompressor().adler32_header(), Some(459605011))
-    }
-}
diff --git a/third_party/rust/chromium_crates_io/vendor/miniz_oxide-0.7.4/src/lib.rs b/third_party/rust/chromium_crates_io/vendor/miniz_oxide-0.7.4/src/lib.rs
deleted file mode 100644
index 6cd4ed37cf34f0..00000000000000
--- a/third_party/rust/chromium_crates_io/vendor/miniz_oxide-0.7.4/src/lib.rs
+++ /dev/null
@@ -1,211 +0,0 @@
-//! A pure rust replacement for the [miniz](https://github.com/richgel999/miniz)
-//! DEFLATE/zlib encoder/decoder.
-//! Used a rust back-end for the
-//! [flate2](https://github.com/alexcrichton/flate2-rs) crate.
-//!
-#![cfg_attr(
-    feature = "with-alloc",
-    doc = r##"
-# Usage
-## Simple compression/decompression:
-``` rust
-
-use miniz_oxide::inflate::decompress_to_vec;
-use miniz_oxide::deflate::compress_to_vec;
-
-fn roundtrip(data: &[u8]) {
-    let compressed = compress_to_vec(data, 6);
-    let decompressed = decompress_to_vec(compressed.as_slice()).expect("Failed to decompress!");
-#   let _ = decompressed;
-}
-
-# roundtrip(b"Test_data test data lalalal blabla");
-"##
-)]
-#![forbid(unsafe_code)]
-#![cfg_attr(not(feature = "std"), no_std)]
-
-#[cfg(feature = "with-alloc")]
-extern crate alloc;
-
-#[cfg(feature = "with-alloc")]
-pub mod deflate;
-pub mod inflate;
-mod shared;
-
-pub use crate::shared::update_adler32 as mz_adler32_oxide;
-pub use crate::shared::{MZ_ADLER32_INIT, MZ_DEFAULT_WINDOW_BITS};
-
-/// A list of flush types.
-///
-/// See <http://www.bolet.org/~pornin/deflate-flush.html> for more in-depth info.
-#[repr(i32)]
-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
-pub enum MZFlush {
-    /// Don't force any flushing.
-    /// Used when more input data is expected.
-    None = 0,
-    /// Zlib partial flush.
-    /// Currently treated as [`Sync`].
-    Partial = 1,
-    /// Finish compressing the currently buffered data, and output an empty raw block.
-    /// Has no use in decompression.
-    Sync = 2,
-    /// Same as [`Sync`], but resets the compression dictionary so that further compressed
-    /// data does not depend on data compressed before the flush.
-    ///
-    /// Has no use in decompression, and is an error to supply in that case.
-    Full = 3,
-    /// Attempt to flush the remaining data and end the stream.
-    Finish = 4,
-    /// Not implemented.
-    Block = 5,
-}
-
-impl MZFlush {
-    /// Create an MZFlush value from an integer value.
-    ///
-    /// Returns `MZError::Param` on invalid values.
-    pub fn new(flush: i32) -> Result<Self, MZError> {
-        match flush {
-            0 => Ok(MZFlush::None),
-            1 | 2 => Ok(MZFlush::Sync),
-            3 => Ok(MZFlush::Full),
-            4 => Ok(MZFlush::Finish),
-            _ => Err(MZError::Param),
-        }
-    }
-}
-
-/// A list of miniz successful status codes.
-///
-/// These are emitted as the [`Ok`] side of a [`MZResult`] in the [`StreamResult`] returned from
-/// [`deflate::stream::deflate()`] or [`inflate::stream::inflate()`].
-#[repr(i32)]
-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
-pub enum MZStatus {
-    /// Operation succeeded.
-    ///
-    /// Some data was decompressed or compressed; see the byte counters in the [`StreamResult`] for
-    /// details.
-    Ok = 0,
-
-    /// Operation succeeded and end of deflate stream was found.
-    ///
-    /// X-ref [`TINFLStatus::Done`][inflate::TINFLStatus::Done] or
-    /// [`TDEFLStatus::Done`][deflate::core::TDEFLStatus::Done] for `inflate` or `deflate`
-    /// respectively.
-    StreamEnd = 1,
-
-    /// Unused
-    NeedDict = 2,
-}
-
-/// A list of miniz failed status codes.
-///
-/// These are emitted as the [`Err`] side of a [`MZResult`] in the [`StreamResult`] returned from
-/// [`deflate::stream::deflate()`] or [`inflate::stream::inflate()`].
-#[repr(i32)]
-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
-pub enum MZError {
-    /// Unused
-    ErrNo = -1,
-
-    /// General stream error.
-    ///
-    /// See [`inflate::stream::inflate()`] docs for details of how it can occur there.
-    ///
-    /// See [`deflate::stream::deflate()`] docs for how it can in principle occur there, though it's
-    /// believed impossible in practice.
-    Stream = -2,
-
-    /// Error in inflation; see [`inflate::stream::inflate()`] for details.
-    ///
-    /// Not returned from [`deflate::stream::deflate()`].
-    Data = -3,
-
-    /// Unused
-    Mem = -4,
-
-    /// Buffer-related error.
-    ///
-    /// See the docs of [`deflate::stream::deflate()`] or [`inflate::stream::inflate()`] for details
-    /// of when it would trigger in the one you're using.
-    Buf = -5,
-
-    /// Unused
-    Version = -6,
-
-    /// Bad parameters.
-    ///
-    /// This can be returned from [`deflate::stream::deflate()`] in the case of bad parameters.  See
-    /// [`TDEFLStatus::BadParam`][deflate::core::TDEFLStatus::BadParam].
-    Param = -10_000,
-}
-
-/// How compressed data is wrapped.
-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
-#[non_exhaustive]
-pub enum DataFormat {
-    /// Wrapped using the [zlib](http://www.zlib.org/rfc-zlib.html) format.
-    Zlib,
-    /// Zlib wrapped but ignore and don't compute the adler32 checksum.
-    /// Currently only used for inflate, behaves the same as Zlib for compression.
-    ZLibIgnoreChecksum,
-    /// Raw DEFLATE.
-    Raw,
-}
-
-impl DataFormat {
-    pub fn from_window_bits(window_bits: i32) -> DataFormat {
-        if window_bits > 0 {
-            DataFormat::Zlib
-        } else {
-            DataFormat::Raw
-        }
-    }
-
-    pub fn to_window_bits(self) -> i32 {
-        match self {
-            DataFormat::Zlib | DataFormat::ZLibIgnoreChecksum => shared::MZ_DEFAULT_WINDOW_BITS,
-            DataFormat::Raw => -shared::MZ_DEFAULT_WINDOW_BITS,
-        }
-    }
-}
-
-/// `Result` alias for all miniz status codes both successful and failed.
-pub type MZResult = Result<MZStatus, MZError>;
-
-/// A structure containing the result of a call to the inflate or deflate streaming functions.
-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
-pub struct StreamResult {
-    /// The number of bytes consumed from the input slice.
-    pub bytes_consumed: usize,
-    /// The number of bytes written to the output slice.
-    pub bytes_written: usize,
-    /// The return status of the call.
-    pub status: MZResult,
-}
-
-impl StreamResult {
-    #[inline]
-    pub const fn error(error: MZError) -> StreamResult {
-        StreamResult {
-            bytes_consumed: 0,
-            bytes_written: 0,
-            status: Err(error),
-        }
-    }
-}
-
-impl core::convert::From<StreamResult> for MZResult {
-    fn from(res: StreamResult) -> Self {
-        res.status
-    }
-}
-
-impl core::convert::From<&StreamResult> for MZResult {
-    fn from(res: &StreamResult) -> Self {
-        res.status
-    }
-}
diff --git a/third_party/rust/chromium_crates_io/vendor/miniz_oxide-0.7.4/src/shared.rs b/third_party/rust/chromium_crates_io/vendor/miniz_oxide-0.7.4/src/shared.rs
deleted file mode 100644
index 8b81fb112b8c0b..00000000000000
--- a/third_party/rust/chromium_crates_io/vendor/miniz_oxide-0.7.4/src/shared.rs
+++ /dev/null
@@ -1,25 +0,0 @@
-#[doc(hidden)]
-pub const MZ_ADLER32_INIT: u32 = 1;
-
-#[doc(hidden)]
-pub const MZ_DEFAULT_WINDOW_BITS: i32 = 15;
-
-pub const HUFFMAN_LENGTH_ORDER: [u8; 19] = [
-    16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15,
-];
-
-#[doc(hidden)]
-#[cfg(not(feature = "simd"))]
-pub fn update_adler32(adler: u32, data: &[u8]) -> u32 {
-    let mut hash = adler::Adler32::from_checksum(adler);
-    hash.write_slice(data);
-    hash.checksum()
-}
-
-#[doc(hidden)]
-#[cfg(feature = "simd")]
-pub fn update_adler32(adler: u32, data: &[u8]) -> u32 {
-    let mut hash = simd_adler32::Adler32::from_checksum(adler);
-    hash.write(data);
-    hash.finish()
-}
diff --git a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/.cargo-checksum.json b/third_party/rust/chromium_crates_io/vendor/png-0.17.13/.cargo-checksum.json
deleted file mode 100644
index 697c9ce2fbb400..00000000000000
--- a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/.cargo-checksum.json
+++ /dev/null
@@ -1 +0,0 @@
-{"files":{}}
diff --git a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/.cargo_vcs_info.json b/third_party/rust/chromium_crates_io/vendor/png-0.17.13/.cargo_vcs_info.json
deleted file mode 100644
index 6637a2412c8149..00000000000000
--- a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/.cargo_vcs_info.json
+++ /dev/null
@@ -1,6 +0,0 @@
-{
-  "git": {
-    "sha1": "b5b0d48ee352d638db2810f3083d9323094854f4"
-  },
-  "path_in_vcs": ""
-}
\ No newline at end of file
diff --git a/third_party/rust/chromium_crates_io/vendor/adler-1.0.2/.cargo-checksum.json b/third_party/rust/chromium_crates_io/vendor/png-0.17.14/.cargo-checksum.json
similarity index 100%
rename from third_party/rust/chromium_crates_io/vendor/adler-1.0.2/.cargo-checksum.json
rename to third_party/rust/chromium_crates_io/vendor/png-0.17.14/.cargo-checksum.json
diff --git a/third_party/rust/chromium_crates_io/vendor/png-0.17.14/.cargo_vcs_info.json b/third_party/rust/chromium_crates_io/vendor/png-0.17.14/.cargo_vcs_info.json
new file mode 100644
index 00000000000000..d42731a24c289f
--- /dev/null
+++ b/third_party/rust/chromium_crates_io/vendor/png-0.17.14/.cargo_vcs_info.json
@@ -0,0 +1,6 @@
+{
+  "git": {
+    "sha1": "347dc5dd3ddee8d2d3ef77a2f03a7d59b6c6fe80"
+  },
+  "path_in_vcs": ""
+}
\ No newline at end of file
diff --git a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/CHANGES.md b/third_party/rust/chromium_crates_io/vendor/png-0.17.14/CHANGES.md
similarity index 92%
rename from third_party/rust/chromium_crates_io/vendor/png-0.17.13/CHANGES.md
rename to third_party/rust/chromium_crates_io/vendor/png-0.17.14/CHANGES.md
index 9a4689a6432c7f..d895e7323b512e 100644
--- a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/CHANGES.md
+++ b/third_party/rust/chromium_crates_io/vendor/png-0.17.14/CHANGES.md
@@ -1,4 +1,13 @@
-## Unreleased
+## 0.17.14
+
+* Updated to miniz_oxide 0.8.0.
+* Added public API to consume interlaced rows one by one ([#495])
+* Improved support for resuming decoding after an `UnexpectedEof`, which lets you start parsing a file before it's fully received over the network ([#496])
+* Fixed some broken links in documentation, improved some documentation comments
+
+[#495]: https://github.com/image-rs/image-png/pull/495
+[#496]: https://github.com/image-rs/image-png/pull/496
+
 
 ## 0.17.13
 
@@ -19,7 +28,7 @@
 * Added `new_with_info` constructor for encoder.
 * Removed hard-coded memory limits.
 * No longer allow zero sized images.
-* Added `Reader::finish` to read all the auxillary chunks that comes after the
+* Added `Reader::finish` to read all the auxiliary chunks that comes after the
   image.
 
 ## 0.17.10
diff --git a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/Cargo.lock b/third_party/rust/chromium_crates_io/vendor/png-0.17.14/Cargo.lock
similarity index 74%
rename from third_party/rust/chromium_crates_io/vendor/png-0.17.13/Cargo.lock
rename to third_party/rust/chromium_crates_io/vendor/png-0.17.14/Cargo.lock
index 739ec04aaf88d5..c71b1750919a3e 100644
--- a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/Cargo.lock
+++ b/third_party/rust/chromium_crates_io/vendor/png-0.17.14/Cargo.lock
@@ -4,9 +4,9 @@ version = 3
 
 [[package]]
 name = "addr2line"
-version = "0.21.0"
+version = "0.17.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "8a30b2e23b9e17a9f90641c7ab1549cd9b44f296d3ccbf309d2863cfe398a0cb"
+checksum = "b9ecd88a8c8378ca913a680cd98f0f13ac67383d35993f86c90a70e3f137816b"
 dependencies = [
  "gimli",
 ]
@@ -18,13 +18,10 @@ source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "f26201604c87b1e01bd3d98f8d5d9a8fcbb815e8cedb41ffccbeb4bf593a35fe"
 
 [[package]]
-name = "aho-corasick"
-version = "1.1.2"
+name = "adler2"
+version = "2.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "b2969dcb958b36655471fc61f7e416fa76033bdd4bfed0678d8fee1e2d07a1f0"
-dependencies = [
- "memchr",
-]
+checksum = "512761e0bb2578dd7380c6baaa0f4ce03e84f95e960231d1dec8bf4d7d6e2627"
 
 [[package]]
 name = "anes"
@@ -34,9 +31,9 @@ checksum = "4b46cbb362ab8752921c97e041f5e366ee6297bd428a31275b9fcf1e380f7299"
 
 [[package]]
 name = "arrayref"
-version = "0.3.7"
+version = "0.3.9"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "6b4930d2cb77ce62f89ee5d5289b4ac049559b1c45539271f5ed4fdc7db34545"
+checksum = "76a2e8124351fda1ef8aaaa3bbd7ebbcb486bbcd4225aca0aa0d84bb2db8fecb"
 
 [[package]]
 name = "arrayvec"
@@ -63,15 +60,15 @@ checksum = "d468802bab17cbc0cc575e9b053f41e72aa36bfa6b7f55e3529ffa43161b97fa"
 
 [[package]]
 name = "backtrace"
-version = "0.3.69"
+version = "0.3.64"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "2089b7e3f35b9dd2d0ed921ead4f6d318c27680d4a5bd167b3ee120edb105837"
+checksum = "5e121dee8023ce33ab248d9ce1493df03c3b38a659b240096fcbd7048ff9c31f"
 dependencies = [
  "addr2line",
  "cc",
  "cfg-if",
  "libc",
- "miniz_oxide",
+ "miniz_oxide 0.4.4",
  "object",
  "rustc-demangle",
 ]
@@ -84,9 +81,9 @@ checksum = "bef38d45163c2f1dde094a7dfd33ccf595c92905c8f8f4fdc18d06fb1037718a"
 
 [[package]]
 name = "bitflags"
-version = "2.4.1"
+version = "2.6.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "327762f6e5a765692301e5bb513e0d9fef63be86bbc14528052b1cd3e6f03e07"
+checksum = "b048fb63fd8b5923fc5aa7b340d8e156aec7ec02f0c78fa8a6ddc2613f6f71de"
 
 [[package]]
 name = "block"
@@ -96,15 +93,15 @@ checksum = "0d8c1fef690941d3e7788d328517591fecc684c084084702d6ff1641e993699a"
 
 [[package]]
 name = "bumpalo"
-version = "3.14.0"
+version = "3.9.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "7f30e7476521f6f8af1a1c4c0b8cc94f0bee37d91763d0ca2665f299b6cd8aec"
+checksum = "a4a45a46ab1f2412e53d3a0ade76ffad2025804294569aae387231a0cd6e0899"
 
 [[package]]
 name = "bytemuck"
-version = "1.14.0"
+version = "1.18.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "374d28ec25809ee0e23827c2ab573d729e293f281dfe393500e7ad618baa61c6"
+checksum = "94bbb0ad554ad961ddc5da507a12a29b14e4ae5bda06b19f575a3e6079d2e2ae"
 
 [[package]]
 name = "byteorder"
@@ -134,11 +131,11 @@ checksum = "37b2a672a2cb129a2e41c10b1224bb368f9f37a2b16b612598138befd7b37eb5"
 
 [[package]]
 name = "cc"
-version = "1.0.83"
+version = "1.1.22"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "f1174fb0b6ec23863f8b971027804a42614e347eafb0a95bf0b12cdae21fc4d0"
+checksum = "9540e661f81799159abee814118cc139a2004b3a3aa3ea37724a1b66530b90e0"
 dependencies = [
- "libc",
+ "shlex",
 ]
 
 [[package]]
@@ -158,9 +155,9 @@ dependencies = [
 
 [[package]]
 name = "ciborium"
-version = "0.2.1"
+version = "0.2.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "effd91f6c78e5a4ace8a5d3c0b6bfaec9e2baaef55f3efc00e45fb2e477ee926"
+checksum = "42e69ffd6f0917f5c029256a24d0161db17cea3997d185db0d35926308770f0e"
 dependencies = [
  "ciborium-io",
  "ciborium-ll",
@@ -169,15 +166,15 @@ dependencies = [
 
 [[package]]
 name = "ciborium-io"
-version = "0.2.1"
+version = "0.2.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "cdf919175532b369853f5d5e20b26b43112613fd6fe7aee757e35f7a44642656"
+checksum = "05afea1e0a06c9be33d539b876f1ce3692f4afea2cb41f740e7743225ed1c757"
 
 [[package]]
 name = "ciborium-ll"
-version = "0.2.1"
+version = "0.2.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "defaa24ecc093c77630e6c15e17c51f5e187bf35ee514f4e2d67baaa96dae22b"
+checksum = "57663b653d948a338bfb3eeba9bb2fd5fcfaecb9e199e87e1eda4d9e8b240fd9"
 dependencies = [
  "ciborium-io",
  "half",
@@ -193,7 +190,7 @@ dependencies = [
  "bitflags 1.3.2",
  "clap_derive",
  "clap_lex",
- "indexmap 1.9.3",
+ "indexmap",
  "once_cell",
  "strsim",
  "termcolor",
@@ -210,7 +207,7 @@ dependencies = [
  "proc-macro-error",
  "proc-macro2",
  "quote",
- "syn 1.0.109",
+ "syn 1.0.86",
 ]
 
 [[package]]
@@ -224,64 +221,49 @@ dependencies = [
 
 [[package]]
 name = "cmake"
-version = "0.1.50"
+version = "0.1.51"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "a31c789563b815f77f4250caee12365734369f942439b7defd71e18a48197130"
+checksum = "fb1e43aa7fd152b1f968787f7dbcdeb306d1867ff373c69955211876c053f91a"
 dependencies = [
  "cc",
 ]
 
 [[package]]
 name = "cocoa"
-version = "0.24.1"
+version = "0.24.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "f425db7937052c684daec3bd6375c8abe2d146dca4b8b143d6db777c39138f3a"
+checksum = "6f63902e9223530efb4e26ccd0cf55ec30d592d3b42e21a28defc42a9586e832"
 dependencies = [
  "bitflags 1.3.2",
  "block",
  "cocoa-foundation",
  "core-foundation",
- "core-graphics 0.22.3",
+ "core-graphics",
  "foreign-types 0.3.2",
  "libc",
  "objc",
 ]
 
-[[package]]
-name = "cocoa"
-version = "0.25.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "f6140449f97a6e97f9511815c5632d84c8aacf8ac271ad77c559218161a1373c"
-dependencies = [
- "bitflags 1.3.2",
- "block",
- "cocoa-foundation",
- "core-foundation",
- "core-graphics 0.23.1",
- "foreign-types 0.5.0",
- "libc",
- "objc",
-]
-
 [[package]]
 name = "cocoa-foundation"
-version = "0.1.2"
+version = "0.1.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "8c6234cbb2e4c785b456c0644748b1ac416dd045799740356f8363dfe00c93f7"
+checksum = "7ade49b65d560ca58c403a479bb396592b155c0185eada742ee323d1d68d6318"
 dependencies = [
  "bitflags 1.3.2",
  "block",
  "core-foundation",
  "core-graphics-types",
+ "foreign-types 0.3.2",
  "libc",
  "objc",
 ]
 
 [[package]]
 name = "core-foundation"
-version = "0.9.4"
+version = "0.9.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "91e195e091a93c46f7102ec7818a2aa394e1e1771c3ab4825963fa03e45afb8f"
+checksum = "194a7a9e6de53fa55116934067c844d9d749312f75c6f6d0980e8c252f8c2146"
 dependencies = [
  "core-foundation-sys",
  "libc",
@@ -289,9 +271,9 @@ dependencies = [
 
 [[package]]
 name = "core-foundation-sys"
-version = "0.8.6"
+version = "0.8.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "06ea2b9bc92be3c2baa9334a323ebca2d6f074ff852cd1d7b11064035cd3868f"
+checksum = "5827cebf4670468b8772dd191856768aedcb1b0278a04f989f7766351917b9dc"
 
 [[package]]
 name = "core-graphics"
@@ -306,39 +288,27 @@ dependencies = [
  "libc",
 ]
 
-[[package]]
-name = "core-graphics"
-version = "0.23.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "970a29baf4110c26fedbc7f82107d42c23f7e88e404c4577ed73fe99ff85a212"
-dependencies = [
- "bitflags 1.3.2",
- "core-foundation",
- "core-graphics-types",
- "foreign-types 0.5.0",
- "libc",
-]
-
 [[package]]
 name = "core-graphics-types"
-version = "0.1.3"
+version = "0.1.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "45390e6114f68f718cc7a830514a96f903cccd70d02a8f6d9f643ac4ba45afaf"
+checksum = "3a68b68b3446082644c91ac778bf50cd4104bfb002b5a6a7c44cca5a2c70788b"
 dependencies = [
  "bitflags 1.3.2",
  "core-foundation",
+ "foreign-types 0.3.2",
  "libc",
 ]
 
 [[package]]
 name = "core-text"
-version = "20.1.0"
+version = "19.2.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "c9d2790b5c08465d49f8dc05c8bcae9fea467855947db39b0f8145c091aaced5"
+checksum = "99d74ada66e07c1cefa18f8abfba765b486f250de2e4a999e5727fc0dd4b4a25"
 dependencies = [
  "core-foundation",
- "core-graphics 0.23.1",
- "foreign-types 0.5.0",
+ "core-graphics",
+ "foreign-types 0.3.2",
  "libc",
 ]
 
@@ -387,41 +357,60 @@ dependencies = [
  "itertools",
 ]
 
+[[package]]
+name = "crossbeam-channel"
+version = "0.5.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e54ea8bc3fb1ee042f5aace6e3c6e025d3874866da222930f70ce62aceba0bfa"
+dependencies = [
+ "cfg-if",
+ "crossbeam-utils",
+]
+
 [[package]]
 name = "crossbeam-deque"
-version = "0.8.5"
+version = "0.8.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "613f8cc01fe9cf1a3eb3d7f488fd2fa8388403e97039e2f73692932e291a770d"
+checksum = "6455c0ca19f0d2fbf751b908d5c55c1f5cbc65e03c4225427254b46890bdde1e"
 dependencies = [
+ "cfg-if",
  "crossbeam-epoch",
  "crossbeam-utils",
 ]
 
 [[package]]
 name = "crossbeam-epoch"
-version = "0.9.18"
+version = "0.9.7"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "5b82ac4a3c2ca9c3460964f020e1402edd5753411d7737aa39c3714ad1b5420e"
+checksum = "c00d6d2ea26e8b151d99093005cb442fb9a37aeaca582a03ec70946f49ab5ed9"
 dependencies = [
+ "cfg-if",
  "crossbeam-utils",
+ "lazy_static",
+ "memoffset",
+ "scopeguard",
 ]
 
 [[package]]
 name = "crossbeam-utils"
-version = "0.8.19"
+version = "0.8.7"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "248e3bacc7dc6baa3b21e405ee045c3047101a49145e7e9eca583ab4c2ca5345"
+checksum = "b5e5bed1f1c269533fa816a0a5492b3545209a205ca1a54842be180eb63a16a6"
+dependencies = [
+ "cfg-if",
+ "lazy_static",
+]
 
 [[package]]
 name = "crossfont"
-version = "0.5.2"
+version = "0.5.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "3eb5a3822b594afc99b503cc1859b94686d3c3efdd60507a28587dab80ee1071"
+checksum = "21fd3add36ea31aba1520aa5288714dd63be506106753226d0eb387a93bc9c45"
 dependencies = [
- "cocoa 0.25.0",
+ "cocoa",
  "core-foundation",
  "core-foundation-sys",
- "core-graphics 0.23.1",
+ "core-graphics",
  "core-text",
  "dwrote",
  "foreign-types 0.5.0",
@@ -435,6 +424,12 @@ dependencies = [
  "winapi",
 ]
 
+[[package]]
+name = "crunchy"
+version = "0.2.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7a81dae078cea95a014a339291cec439d2f232ebe854a9d672b796c6afafa9b7"
+
 [[package]]
 name = "cty"
 version = "0.2.2"
@@ -443,9 +438,9 @@ checksum = "b365fabc795046672053e29c954733ec3b05e4be654ab130fe8f1f94d7051f35"
 
 [[package]]
 name = "darling"
-version = "0.13.4"
+version = "0.13.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "a01d95850c592940db9b8194bc39f4bc0e89dee5c4265e4b1807c34a9aba453c"
+checksum = "d0d720b8683f8dd83c65155f0530560cba68cd2bf395f6513a483caee57ff7f4"
 dependencies = [
  "darling_core",
  "darling_macro",
@@ -453,27 +448,27 @@ dependencies = [
 
 [[package]]
 name = "darling_core"
-version = "0.13.4"
+version = "0.13.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "859d65a907b6852c9361e3185c862aae7fafd2887876799fa55f5f99dc40d610"
+checksum = "7a340f241d2ceed1deb47ae36c4144b2707ec7dd0b649f894cb39bb595986324"
 dependencies = [
  "fnv",
  "ident_case",
  "proc-macro2",
  "quote",
  "strsim",
- "syn 1.0.109",
+ "syn 1.0.86",
 ]
 
 [[package]]
 name = "darling_macro"
-version = "0.13.4"
+version = "0.13.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "9c972679f83bdf9c42bd905396b6c3588a843a17f0f16dfcfa3e2c5d57441835"
+checksum = "72c41b3b7352feb3211a0d743dc5700a4e3b60f51bd2b368892d1e0f9a95f44b"
 dependencies = [
  "darling_core",
  "quote",
- "syn 1.0.109",
+ "syn 1.0.86",
 ]
 
 [[package]]
@@ -505,11 +500,11 @@ checksum = "bd0c93bb4b0c6d9b77f4435b0ae98c24d17f1c45b2ff844c6151a07256ca923b"
 
 [[package]]
 name = "dlib"
-version = "0.5.2"
+version = "0.5.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "330c60081dcc4c72131f8eb70510f1ac07223e5d4163db481a04a0befcffa412"
+checksum = "ac1b7517328c04c2aa68422fc60a41b92208182142ed04a25879c26c8f878794"
 dependencies = [
- "libloading 0.8.1",
+ "libloading",
 ]
 
 [[package]]
@@ -520,9 +515,9 @@ checksum = "9ea835d29036a4087793836fa931b08837ad5e957da9e23886b29586fb9b6650"
 
 [[package]]
 name = "dwrote"
-version = "0.11.0"
+version = "0.11.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "439a1c2ba5611ad3ed731280541d36d2e9c4ac5e7fb818a27b604bdc5a6aa65b"
+checksum = "2da3498378ed373237bdef1eddcc64e7be2d3ba4841f4c22a998e81cadeea83c"
 dependencies = [
  "lazy_static",
  "libc",
@@ -534,15 +529,9 @@ dependencies = [
 
 [[package]]
 name = "either"
-version = "1.9.0"
+version = "1.6.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "a26ae43d7bcc3b814de94796a5e736d4029efb0ee900c12e2d54c993ad1a1e07"
-
-[[package]]
-name = "equivalent"
-version = "1.0.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "5443807d6dff69373d433ab9ef5378ad8df50ca6298caf15de6e52e24aaf54d5"
+checksum = "e78d4f1cc4ae33bbfc157ed5d5a5ef3bc29227303d595861deb238fcec4e9457"
 
 [[package]]
 name = "expat-sys"
@@ -556,21 +545,21 @@ dependencies = [
 
 [[package]]
 name = "fdeflate"
-version = "0.3.3"
+version = "0.3.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "209098dd6dfc4445aa6111f0e98653ac323eaa4dfd212c9ca3931bf9955c31bd"
+checksum = "d8090f921a24b04994d9929e204f50b498a33ea6ba559ffaa05e04f7ee7fb5ab"
 dependencies = [
  "simd-adler32",
 ]
 
 [[package]]
 name = "flate2"
-version = "1.0.28"
+version = "1.0.24"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "46303f565772937ffe1d394a4fac6f411c6013172fadde9dcdb1e147a086940e"
+checksum = "f82b0f4c27ad9f8bfd1f3208d882da2b09c301bc1c828fd3a00d0216d2fbbff6"
 dependencies = [
  "crc32fast",
- "miniz_oxide",
+ "miniz_oxide 0.5.3",
 ]
 
 [[package]]
@@ -606,7 +595,7 @@ checksum = "1a5c6c585bc94aaf2c7b51dd4c2ba22680844aba4c687be581871a6f518c5742"
 dependencies = [
  "proc-macro2",
  "quote",
- "syn 2.0.48",
+ "syn 2.0.79",
 ]
 
 [[package]]
@@ -654,9 +643,9 @@ dependencies = [
 
 [[package]]
 name = "getrandom"
-version = "0.2.12"
+version = "0.2.4"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "190092ea657667030ac6a35e305e62fc4dd69fd98ac98631e5d3a2b1575a12b5"
+checksum = "418d37c8b1d42553c93648be529cb70f920d3baf8ef469b74b9638df426e0b4c"
 dependencies = [
  "cfg-if",
  "libc",
@@ -665,9 +654,9 @@ dependencies = [
 
 [[package]]
 name = "gimli"
-version = "0.28.1"
+version = "0.26.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "4271d37baee1b8c7e4b708028c57d816cf9d2434acb33a549475f78c181f6253"
+checksum = "78cc372d058dcf6d5ecd98510e7fbc9e5aec4d21de70f65fea8fecebcd881bd4"
 
 [[package]]
 name = "gl_generator"
@@ -698,9 +687,9 @@ dependencies = [
 
 [[package]]
 name = "glob"
-version = "0.3.1"
+version = "0.3.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "d2fabcfbdc87f4758337ca535fb41a6d701b65693ce38287d856d1674551ec9b"
+checksum = "9b919933a397b79c37e33b77bb2aa3dc8eb6e165ad809e58ff75bc7db2e34574"
 
 [[package]]
 name = "glutin"
@@ -709,13 +698,13 @@ source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "444c9ad294fdcaf20ccf6726b78f380b5450275540c9b68ab62f49726ad1c713"
 dependencies = [
  "cgl",
- "cocoa 0.24.1",
+ "cocoa",
  "core-foundation",
  "glutin_egl_sys",
  "glutin_gles2_sys",
  "glutin_glx_sys",
  "glutin_wgl_sys",
- "libloading 0.7.4",
+ "libloading",
  "log",
  "objc",
  "once_cell",
@@ -769,9 +758,13 @@ dependencies = [
 
 [[package]]
 name = "half"
-version = "1.8.2"
+version = "2.4.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "eabb4a44450da02c90444cf74558da904edde8fb4e9035a9a6a4e15445af0bd7"
+checksum = "6dd08c532ae367adf81c312a4580bc67f1d0fe8bc9c460520283f4c0ff277888"
+dependencies = [
+ "cfg-if",
+ "crunchy",
+]
 
 [[package]]
 name = "hashbrown"
@@ -779,12 +772,6 @@ version = "0.12.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "8a9ee70c43aaf417c914396645a0fa852624801b24ebb7ae78fe8272889ac888"
 
-[[package]]
-name = "hashbrown"
-version = "0.14.3"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "290f1a1d9242c78d09ce40a5e87e7554ee637af1351968159f4952f028f75604"
-
 [[package]]
 name = "heck"
 version = "0.4.1"
@@ -813,17 +800,7 @@ source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "bd070e393353796e801d209ad339e89596eb4c8d430d18ede6a1cced8fafbd99"
 dependencies = [
  "autocfg",
- "hashbrown 0.12.3",
-]
-
-[[package]]
-name = "indexmap"
-version = "2.1.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "d530e1a18b1cb4c484e6e34556a0d948706958449fca0cab753d649f2bce3d1f"
-dependencies = [
- "equivalent",
- "hashbrown 0.14.3",
+ "hashbrown",
 ]
 
 [[package]]
@@ -840,18 +817,18 @@ dependencies = [
 
 [[package]]
 name = "itertools"
-version = "0.10.5"
+version = "0.10.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "b0fd2260e829bddf4cb6ea802289de2f86d6a7a690192fbe91b3f46e0f2c8473"
+checksum = "a9a9d19fa1e79b6215ff29b9d6880b706147f16e9b1dbb1e4e5947b5b02bc5e3"
 dependencies = [
  "either",
 ]
 
 [[package]]
 name = "itoa"
-version = "1.0.10"
+version = "1.0.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "b1a46d1a171d865aa5f83f92695765caa047a9b4cbae2cbf37dbd613a793fd4c"
+checksum = "1aab8fc367588b89dcee83ab0fd66b72b50b72fa1904d7095045ace2b0c81c35"
 
 [[package]]
 name = "jni-sys"
@@ -861,9 +838,9 @@ checksum = "8eaf4bc02d17cbdd7ff4c7438cafcdf7fb9a4613313ad11b4f8fefe7d3fa0130"
 
 [[package]]
 name = "js-sys"
-version = "0.3.67"
+version = "0.3.56"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "9a1d36f1235bc969acba30b7f5990b864423a6068a10f7c90ae8f0112e3a59d1"
+checksum = "a38fc24e30fd564ce974c02bf1d337caddff65be6cc4735a1f7eab22a7440f04"
 dependencies = [
  "wasm-bindgen",
 ]
@@ -882,56 +859,37 @@ checksum = "e2abad23fbc42b3700f2f279844dc832adb2b2eb069b2df918f455c4e18cc646"
 
 [[package]]
 name = "libc"
-version = "0.2.152"
+version = "0.2.159"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "13e3bf6590cbc649f4d1a3eefc9d5d6eb746f5200ffb04e5e142700b8faa56e7"
+checksum = "561d97a539a36e26a9a5fad1ea11a3039a67714694aaa379433e580854bc3dc5"
 
 [[package]]
 name = "libloading"
-version = "0.7.4"
+version = "0.7.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "b67380fd3b2fbe7527a606e18729d21c6f3951633d0500574c4dc22d2d638b9f"
+checksum = "efbc0f03f9a775e9f6aed295c6a1ba2253c5757a9e03d55c6caa46a681abcddd"
 dependencies = [
  "cfg-if",
  "winapi",
 ]
 
-[[package]]
-name = "libloading"
-version = "0.8.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "c571b676ddfc9a8c12f1f3d3085a7b163966a8fd8098a90640953ce5f6170161"
-dependencies = [
- "cfg-if",
- "windows-sys 0.48.0",
-]
-
-[[package]]
-name = "libredox"
-version = "0.0.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "85c833ca1e66078851dba29046874e38f08b2c883700aa29a03ddd3b23814ee8"
-dependencies = [
- "bitflags 2.4.1",
- "libc",
- "redox_syscall",
-]
-
 [[package]]
 name = "lock_api"
-version = "0.4.11"
+version = "0.4.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "3c168f8615b12bc01f9c17e2eb0cc07dcae1940121185446edc3744920e8ef45"
+checksum = "88943dd7ef4a2e5a4bfa2753aaab3013e34ce2533d1996fb18ef591e315e2b3b"
 dependencies = [
- "autocfg",
  "scopeguard",
 ]
 
 [[package]]
 name = "log"
-version = "0.4.20"
+version = "0.4.14"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "b5e6163cb8c49088c2c36f57875e58ccd8c87c7427f7fbd50ea6710b2f3f2e8f"
+checksum = "51b9bbe6c47d51fc3e1a9b945965946b4c44142ab8792c50835a980d362c2710"
+dependencies = [
+ "cfg-if",
+]
 
 [[package]]
 name = "malloc_buf"
@@ -944,9 +902,9 @@ dependencies = [
 
 [[package]]
 name = "memchr"
-version = "2.7.1"
+version = "2.4.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "523dc4f511e55ab87b694dc30d0f820d60906ef06413f93d4d7a1385599cc149"
+checksum = "308cc39be01b73d0d18f82a0e7b2a3df85245f84af96fdddc5d202d27e47b86a"
 
 [[package]]
 name = "memmap2"
@@ -966,26 +924,71 @@ dependencies = [
  "autocfg",
 ]
 
+[[package]]
+name = "minimal-lexical"
+version = "0.2.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "68354c5c6bd36d73ff3feceb05efa59b6acb7626617f4962be322a825e61f79a"
+
+[[package]]
+name = "miniz_oxide"
+version = "0.4.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a92518e98c078586bc6c934028adcca4c92a53d6a958196de835170a01d84e4b"
+dependencies = [
+ "adler",
+ "autocfg",
+]
+
 [[package]]
 name = "miniz_oxide"
-version = "0.7.1"
+version = "0.5.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "e7810e0be55b428ada41041c41f32c9f1a42817901b4ccf45fa3d4b6561e74c7"
+checksum = "6f5c75688da582b8ffc1f1799e9db273f32133c49e048f614d22ec3256773ccc"
+dependencies = [
+ "adler",
+]
+
+[[package]]
+name = "miniz_oxide"
+version = "0.7.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b8a240ddb74feaf34a79a7add65a741f3167852fba007066dcac1ca548d89c08"
 dependencies = [
  "adler",
  "simd-adler32",
 ]
 
+[[package]]
+name = "miniz_oxide"
+version = "0.8.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e2d80299ef12ff69b16a84bb182e3b9df68b5a91574d3d4fa6e41b65deec4df1"
+dependencies = [
+ "adler2",
+ "simd-adler32",
+]
+
 [[package]]
 name = "mio"
-version = "0.8.10"
+version = "0.8.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "8f3d0b296e374a4e6f3c7b0a1f5a51d748a0d34c85e7dc48fc3fa9a87657fe09"
+checksum = "ba272f85fa0b41fc91872be579b3bbe0f56b792aa361a380eb669469f68dafb2"
 dependencies = [
  "libc",
  "log",
- "wasi",
- "windows-sys 0.48.0",
+ "miow",
+ "ntapi",
+ "winapi",
+]
+
+[[package]]
+name = "miow"
+version = "0.3.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b9f1c5b025cda876f66ef43a113f91ebc9f4ccef34843000e0adf6ebbab84e21"
+dependencies = [
+ "winapi",
 ]
 
 [[package]]
@@ -1034,7 +1037,7 @@ dependencies = [
  "proc-macro-crate",
  "proc-macro2",
  "quote",
- "syn 1.0.109",
+ "syn 1.0.86",
 ]
 
 [[package]]
@@ -1046,6 +1049,19 @@ dependencies = [
  "jni-sys",
 ]
 
+[[package]]
+name = "nix"
+version = "0.22.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e4916f159ed8e5de0082076562152a76b7a1f64a01fd9d1e0fea002c37624faf"
+dependencies = [
+ "bitflags 1.3.2",
+ "cc",
+ "cfg-if",
+ "libc",
+ "memoffset",
+]
+
 [[package]]
 name = "nix"
 version = "0.24.3"
@@ -1055,7 +1071,6 @@ dependencies = [
  "bitflags 1.3.2",
  "cfg-if",
  "libc",
- "memoffset",
 ]
 
 [[package]]
@@ -1071,34 +1086,64 @@ dependencies = [
  "memoffset",
 ]
 
+[[package]]
+name = "nom"
+version = "7.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1b1d11e1ef389c76fe5b81bcaf2ea32cf88b62bc494e19f493d0b30e7a930109"
+dependencies = [
+ "memchr",
+ "minimal-lexical",
+ "version_check",
+]
+
+[[package]]
+name = "ntapi"
+version = "0.3.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "c28774a7fd2fbb4f0babd8237ce554b73af68021b5f695a3cebd6c59bac0980f"
+dependencies = [
+ "winapi",
+]
+
 [[package]]
 name = "num-traits"
-version = "0.2.17"
+version = "0.2.14"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "39e3200413f237f41ab11ad6d161bc7239c84dcb631773ccd7de3dfe4b5c267c"
+checksum = "9a64b1ec5cda2586e284722486d802acf1f7dbdc623e2bfc57e65ca1cd099290"
 dependencies = [
  "autocfg",
 ]
 
+[[package]]
+name = "num_cpus"
+version = "1.13.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "19e64526ebdee182341572e50e9ad03965aa510cd94427a4549448f285e957a1"
+dependencies = [
+ "hermit-abi",
+ "libc",
+]
+
 [[package]]
 name = "num_enum"
-version = "0.5.11"
+version = "0.5.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "1f646caf906c20226733ed5b1374287eb97e3c2a5c227ce668c1f2ce20ae57c9"
+checksum = "720d3ea1055e4e4574c0c0b0f8c3fd4f24c4cdaf465948206dea090b57b526ad"
 dependencies = [
  "num_enum_derive",
 ]
 
 [[package]]
 name = "num_enum_derive"
-version = "0.5.11"
+version = "0.5.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "dcbff9bc912032c62bf65ef1d5aea88983b420f4f839db1e9b0c281a25c9c799"
+checksum = "0d992b768490d7fe0d8586d9b5745f6c49f557da6d81dc982b1d167ad4edbb21"
 dependencies = [
  "proc-macro-crate",
  "proc-macro2",
  "quote",
- "syn 1.0.109",
+ "syn 1.0.86",
 ]
 
 [[package]]
@@ -1112,9 +1157,9 @@ dependencies = [
 
 [[package]]
 name = "object"
-version = "0.32.2"
+version = "0.27.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "a6a622008b6e321afc04970976f62ee297fdbaa6f95318ca343e3eebb9648441"
+checksum = "67ac1d3f9a1d3616fd9a60c8d74296f22406a238b6a72f5cc1e6f314df4ffbf9"
 dependencies = [
  "memchr",
 ]
@@ -1148,9 +1193,9 @@ dependencies = [
 
 [[package]]
 name = "parking_lot"
-version = "0.12.1"
+version = "0.12.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "3742b2c103b9f06bc9fff0a37ff4912935851bee6d36f3c02bcc755bcfec228f"
+checksum = "f1bf18183cf54e8d6059647fc3063646a1801cf30896933ec2311622cc4b9a27"
 dependencies = [
  "lock_api",
  "parking_lot_core",
@@ -1158,34 +1203,34 @@ dependencies = [
 
 [[package]]
 name = "parking_lot_core"
-version = "0.9.9"
+version = "0.9.10"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "4c42a9226546d68acdd9c0a280d17ce19bfe27a46bf68784e4066115788d008e"
+checksum = "1e401f977ab385c9e4e3ab30627d6f26d00e2c73eef317493c4ec6d468726cf8"
 dependencies = [
  "cfg-if",
  "libc",
- "redox_syscall",
+ "redox_syscall 0.5.6",
  "smallvec",
  "windows-targets",
 ]
 
 [[package]]
 name = "percent-encoding"
-version = "2.3.1"
+version = "2.1.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "e3148f5046208a5d56bcfc03053e3ca6334e51da8dfb19b6cdc8b306fae3283e"
+checksum = "d4fd5641d01c8f18a23da7b6fe29298ff4b55afcccdf78973b24cf3175fee32e"
 
 [[package]]
 name = "pkg-config"
-version = "0.3.28"
+version = "0.3.24"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "69d3587f8a9e599cc7ec2c00e331f71c4e69a5f9a4b8a6efd5b07466b9736f9a"
+checksum = "58893f751c9b0412871a09abd62ecd2a00298c6c83befa223ef98c52aef40cbe"
 
 [[package]]
 name = "plotters"
-version = "0.3.5"
+version = "0.3.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "d2c224ba00d7cadd4d5c660deaf2098e5e80e07846537c51f9cfa4be50c1fd45"
+checksum = "32a3fd9ec30b9749ce28cd91f255d569591cdf937fe280c312143e3c4bad6f2a"
 dependencies = [
  "num-traits",
  "plotters-backend",
@@ -1196,35 +1241,35 @@ dependencies = [
 
 [[package]]
 name = "plotters-backend"
-version = "0.3.5"
+version = "0.3.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "9e76628b4d3a7581389a35d5b6e2139607ad7c75b17aed325f210aa91f4a9609"
+checksum = "d88417318da0eaf0fdcdb51a0ee6c3bed624333bff8f946733049380be67ac1c"
 
 [[package]]
 name = "plotters-svg"
-version = "0.3.5"
+version = "0.3.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "38f6d39893cca0701371e3c27294f09797214b86f1fb951b89ade8ec04e2abab"
+checksum = "521fa9638fa597e1dc53e9412a4f9cefb01187ee1f7413076f9e6749e2885ba9"
 dependencies = [
  "plotters-backend",
 ]
 
 [[package]]
 name = "png"
-version = "0.17.10"
+version = "0.17.13"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "dd75bf2d8dd3702b9707cdbc56a5b9ef42cec752eb8b3bafc01234558442aa64"
+checksum = "06e4b0d3d1312775e782c86c91a111aa1f910cbb65e1337f9975b5f9a554b5e1"
 dependencies = [
  "bitflags 1.3.2",
  "crc32fast",
  "fdeflate",
  "flate2",
- "miniz_oxide",
+ "miniz_oxide 0.7.4",
 ]
 
 [[package]]
 name = "png"
-version = "0.17.13"
+version = "0.17.14"
 dependencies = [
  "bitflags 1.3.2",
  "byteorder",
@@ -1236,25 +1281,25 @@ dependencies = [
  "getopts",
  "glium",
  "glob",
- "miniz_oxide",
+ "miniz_oxide 0.8.0",
  "rand",
  "term",
 ]
 
 [[package]]
 name = "ppv-lite86"
-version = "0.2.17"
+version = "0.2.16"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "5b40af805b3121feab8a3c29f04d8ad262fa8e0561883e7653e024ae4479e6de"
+checksum = "eb9f9e6e233e5c4a35559a617bf40a4ec447db2e84c20b55a6f83167b7e57872"
 
 [[package]]
 name = "proc-macro-crate"
-version = "1.3.1"
+version = "1.1.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "7f4c021e1093a56626774e81216a4ce732a735e5bad4868a03f3ed65ca0c3919"
+checksum = "e17d47ce914bf4de440332250b0edd23ce48c005f59fab39d3335866b114f11a"
 dependencies = [
- "once_cell",
- "toml_edit",
+ "thiserror",
+ "toml",
 ]
 
 [[package]]
@@ -1266,7 +1311,7 @@ dependencies = [
  "proc-macro-error-attr",
  "proc-macro2",
  "quote",
- "syn 1.0.109",
+ "syn 1.0.86",
  "version_check",
 ]
 
@@ -1283,18 +1328,18 @@ dependencies = [
 
 [[package]]
 name = "proc-macro2"
-version = "1.0.76"
+version = "1.0.86"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "95fc56cda0b5c3325f5fbbd7ff9fda9e02bb00bb3dac51252d2f1bfa1cb8cc8c"
+checksum = "5e719e8df665df0d1c8fbfd238015744736151d4445ec0836b8e628aae103b77"
 dependencies = [
  "unicode-ident",
 ]
 
 [[package]]
 name = "quote"
-version = "1.0.35"
+version = "1.0.37"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "291ec9ab5efd934aaf503a6466c5d5251535d108ee747472c3977cc5acc868ef"
+checksum = "b5b9d34b8991d19d98081b46eacdd8eb58c6f2b201139f7c5f643cc155a633af"
 dependencies = [
  "proc-macro2",
 ]
@@ -1322,9 +1367,9 @@ dependencies = [
 
 [[package]]
 name = "rand_core"
-version = "0.6.4"
+version = "0.6.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "ec0be4795e2f6a28069bec0b5ff3e2ac9bafc99e6a9a7dc3547996c5c816922c"
+checksum = "d34f1408f55294453790c48b2f1ebbb1c5b4b7563eb1f418bcfcfdbb06ebb4e7"
 dependencies = [
  "getrandom",
 ]
@@ -1346,90 +1391,89 @@ checksum = "f2ff9a1f06a88b01621b7ae906ef0211290d1c8a168a15542486a8f61c0833b9"
 
 [[package]]
 name = "rayon"
-version = "1.8.0"
+version = "1.5.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "9c27db03db7734835b3f53954b534c91069375ce6ccaa2e065441e07d9b6cdb1"
+checksum = "c06aca804d41dbc8ba42dfd964f0d01334eceb64314b9ecf7c5fad5188a06d90"
 dependencies = [
+ "autocfg",
+ "crossbeam-deque",
  "either",
  "rayon-core",
 ]
 
 [[package]]
 name = "rayon-core"
-version = "1.12.0"
+version = "1.9.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "5ce3fb6ad83f861aac485e76e1985cd109d9a3713802152be56c3b1f0e0658ed"
+checksum = "d78120e2c850279833f1dd3582f730c4ab53ed95aeaaaa862a2a5c71b1656d8e"
 dependencies = [
+ "crossbeam-channel",
  "crossbeam-deque",
  "crossbeam-utils",
+ "lazy_static",
+ "num_cpus",
 ]
 
 [[package]]
 name = "redox_syscall"
-version = "0.4.1"
+version = "0.2.10"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "4722d768eff46b75989dd134e5c353f0d6296e5aaa3132e776cbdb56be7731aa"
+checksum = "8383f39639269cde97d255a32bdb68c047337295414940c68bdd30c2e13203ff"
 dependencies = [
  "bitflags 1.3.2",
 ]
 
 [[package]]
-name = "redox_users"
-version = "0.4.4"
+name = "redox_syscall"
+version = "0.5.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "a18479200779601e498ada4e8c1e1f50e3ee19deb0259c25825a98b5603b2cb4"
+checksum = "355ae415ccd3a04315d3f8246e86d67689ea74d88d915576e1589a351062a13b"
 dependencies = [
- "getrandom",
- "libredox",
- "thiserror",
+ "bitflags 2.6.0",
 ]
 
 [[package]]
-name = "regex"
-version = "1.10.2"
+name = "redox_users"
+version = "0.4.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "380b951a9c5e80ddfd6136919eef32310721aa4aacd4889a8d39124b026ab343"
+checksum = "528532f3d801c87aec9def2add9ca802fe569e44a544afe633765267840abe64"
 dependencies = [
- "aho-corasick",
- "memchr",
- "regex-automata",
- "regex-syntax",
+ "getrandom",
+ "redox_syscall 0.2.10",
 ]
 
 [[package]]
-name = "regex-automata"
-version = "0.4.3"
+name = "regex"
+version = "1.5.4"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "5f804c7828047e88b2d32e2d7fe5a105da8ee3264f01902f796c8e067dc2483f"
+checksum = "d07a8629359eb56f1e2fb1652bb04212c072a87ba68546a04065d525673ac461"
 dependencies = [
- "aho-corasick",
- "memchr",
  "regex-syntax",
 ]
 
 [[package]]
 name = "regex-syntax"
-version = "0.8.2"
+version = "0.6.25"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "c08c74e62047bb2de4ff487b251e4a92e24f48745648451635cec7d591162d9f"
+checksum = "f497285884f3fcff424ffc933e56d7cbca511def0c9831a7f9b5f6153e3cc89b"
 
 [[package]]
 name = "rustc-demangle"
-version = "0.1.23"
+version = "0.1.21"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "d626bb9dae77e28219937af045c257c28bfd3f69333c512553507f5f9798cb76"
+checksum = "7ef03e0a2b150c7a90d01faf6254c9c48a41e95fb2a8c2ac1c6f0d2b9aefc342"
 
 [[package]]
 name = "rustversion"
-version = "1.0.14"
+version = "1.0.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "7ffc183a10b4478d04cbbbfc96d0873219d962dd5accaff2ffbd4ceb7df837f4"
+checksum = "f2cc38e8fa666e2de3c4aba7edeb5ffc5246c1c2ed0e3d17e560aeeba736b23f"
 
 [[package]]
 name = "ryu"
-version = "1.0.16"
+version = "1.0.9"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "f98d2aa92eebf49b69786be48e4477826b256916e84a57ff2a4f21923b48eb4c"
+checksum = "73b4b750c782965c211b42f022f59af1fbceabdd026623714f104152f1ec149f"
 
 [[package]]
 name = "safe_arch"
@@ -1451,15 +1495,15 @@ dependencies = [
 
 [[package]]
 name = "scoped-tls"
-version = "1.0.1"
+version = "1.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "e1cf6437eb19a8f4a6cc0f7dca544973b0b78843adbfeb3683d1a94a0024a294"
+checksum = "ea6a9290e3c9cf0f18145ef7ffa62d68ee0bf5fcd651017e586dc7fd5da448c2"
 
 [[package]]
 name = "scopeguard"
-version = "1.2.0"
+version = "1.1.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "94143f37725109f92c262ed2cf5e59bce7498c01bcc1502d7b9afe439a4e9f49"
+checksum = "d29ab0c6d3fc0ee92fe66e2d99f700eab17a8d57d1c1d3b748380fb20baa78cd"
 
 [[package]]
 name = "sctk-adwaita"
@@ -1475,29 +1519,29 @@ dependencies = [
 
 [[package]]
 name = "serde"
-version = "1.0.195"
+version = "1.0.136"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "63261df402c67811e9ac6def069e4786148c4563f4b50fd4bf30aa370d626b02"
+checksum = "ce31e24b01e1e524df96f1c2fdd054405f8d7376249a5110886fb4b658484789"
 dependencies = [
  "serde_derive",
 ]
 
 [[package]]
 name = "serde_derive"
-version = "1.0.195"
+version = "1.0.136"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "46fe8f8603d81ba86327b23a2e9cdf49e1255fb94a4c5f297f6ee0547178ea2c"
+checksum = "08597e7152fcd306f41838ed3e37be9eaeed2b61c42e2117266a554fab4662f9"
 dependencies = [
  "proc-macro2",
  "quote",
- "syn 2.0.48",
+ "syn 1.0.86",
 ]
 
 [[package]]
 name = "serde_json"
-version = "1.0.111"
+version = "1.0.79"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "176e46fa42316f18edd598015a5166857fc835ec732f5215eac6b7bdbf0a84f4"
+checksum = "8e8d9fa5c3b304765ce1fd9c4c8a3de2c8db365a5b91be52f186efc675681d95"
 dependencies = [
  "itoa",
  "ryu",
@@ -1535,6 +1579,12 @@ dependencies = [
  "libc",
 ]
 
+[[package]]
+name = "shlex"
+version = "1.3.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0fda2ff0d084019ba4d7c6f371c95d8fd75ce3524c3cb8fb653a3023f6323e64"
+
 [[package]]
 name = "simd-adler32"
 version = "0.3.7"
@@ -1552,9 +1602,9 @@ dependencies = [
 
 [[package]]
 name = "smallvec"
-version = "1.11.2"
+version = "1.8.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "4dccd0940a2dcdf68d092b8cbab7dc0ad8fa938bf95787e1b916b0e3d0e8e970"
+checksum = "f2dd574626839106c320a323308629dcb1acfc96e32a8cba364ddc61ac23ee83"
 
 [[package]]
 name = "smithay-client-toolkit"
@@ -1583,20 +1633,20 @@ checksum = "73473c0e59e6d5812c5dfe2a064a6444949f089e20eec9a2e5506596494e4623"
 
 [[package]]
 name = "syn"
-version = "1.0.109"
+version = "1.0.86"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "72b64191b275b66ffe2469e8af2c1cfe3bafa67b529ead792a6d0160888b4237"
+checksum = "8a65b3f4ffa0092e9887669db0eae07941f023991ab58ea44da8fe8e2d511c6b"
 dependencies = [
  "proc-macro2",
  "quote",
- "unicode-ident",
+ "unicode-xid",
 ]
 
 [[package]]
 name = "syn"
-version = "2.0.48"
+version = "2.0.79"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "0f3531638e407dfc0814761abb7c00a5b54992b849452a0646b7f65c9f770f3f"
+checksum = "89132cd0bf050864e1d38dc3bbc07a0eb8e7530af26344d3d2bbbef83499f590"
 dependencies = [
  "proc-macro2",
  "quote",
@@ -1631,28 +1681,28 @@ dependencies = [
 
 [[package]]
 name = "textwrap"
-version = "0.16.0"
+version = "0.16.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "222a222a5bfe1bba4a77b45ec488a741b3cb8872e5e499451fd7d0129c9c7c3d"
+checksum = "23d434d3f8967a09480fb04132ebe0a3e088c173e6d0ee7897abbdf4eab0f8b9"
 
 [[package]]
 name = "thiserror"
-version = "1.0.56"
+version = "1.0.30"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "d54378c645627613241d077a3a79db965db602882668f9136ac42af9ecb730ad"
+checksum = "854babe52e4df1653706b98fcfc05843010039b406875930a70e4d9644e5c417"
 dependencies = [
  "thiserror-impl",
 ]
 
 [[package]]
 name = "thiserror-impl"
-version = "1.0.56"
+version = "1.0.30"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "fa0faa943b50f3db30a20aa7e265dbc66076993efed8463e8de414e5d06d3471"
+checksum = "aa32fd3f627f367fe16f893e2597ae3c05020f8bba2666a4e6ea73d377e5714b"
 dependencies = [
  "proc-macro2",
  "quote",
- "syn 2.0.48",
+ "syn 1.0.86",
 ]
 
 [[package]]
@@ -1665,7 +1715,7 @@ dependencies = [
  "arrayvec",
  "bytemuck",
  "cfg-if",
- "png 0.17.10",
+ "png 0.17.13",
  "safe_arch",
  "tiny-skia-path",
 ]
@@ -1691,33 +1741,31 @@ dependencies = [
 ]
 
 [[package]]
-name = "toml_datetime"
-version = "0.6.5"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "3550f4e9685620ac18a50ed434eb3aec30db8ba93b0287467bca5826ea25baf1"
-
-[[package]]
-name = "toml_edit"
-version = "0.19.15"
+name = "toml"
+version = "0.5.8"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "1b5bb770da30e5cbfde35a2d7b9b8a2c4b8ef89548a7a6aeab5c9a576e3e7421"
+checksum = "a31142970826733df8241ef35dc040ef98c679ab14d7c3e54d827099b3acecaa"
 dependencies = [
- "indexmap 2.1.0",
- "toml_datetime",
- "winnow",
+ "serde",
 ]
 
 [[package]]
 name = "unicode-ident"
-version = "1.0.12"
+version = "1.0.13"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "3354b9ac3fae1ff6755cb6db53683adb661634f67557942dea4facebec0fee4b"
+checksum = "e91b56cd4cadaeb79bbf1a5645f6b4f8dc5bde8834ad5894a8db35fda9efa1fe"
 
 [[package]]
 name = "unicode-width"
-version = "0.1.11"
+version = "0.1.9"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3ed742d4ea2bd1176e236172c8429aaf54486e7ac098db29ffe6529e0ce50973"
+
+[[package]]
+name = "unicode-xid"
+version = "0.2.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "e51733f11c9c4f72aa0c160008246859e340b00807569a0da0e7a1079b27ba85"
+checksum = "8ccb82d61f80a663efe1f787a51b16b5a51e3314d6ac365b08639f52387b33f3"
 
 [[package]]
 name = "vec_map"
@@ -1733,25 +1781,26 @@ checksum = "49874b5167b65d7193b8aba1567f5c7d93d001cafc34600cee003eda787e483f"
 
 [[package]]
 name = "walkdir"
-version = "2.4.0"
+version = "2.3.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "d71d857dc86794ca4c280d616f7da00d2dbfd8cd788846559a6813e6aa4b54ee"
+checksum = "808cf2735cd4b6866113f648b791c6adc5714537bc222d9347bb203386ffda56"
 dependencies = [
  "same-file",
+ "winapi",
  "winapi-util",
 ]
 
 [[package]]
 name = "wasi"
-version = "0.11.0+wasi-snapshot-preview1"
+version = "0.10.2+wasi-snapshot-preview1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "9c8d87e72b64a3b4db28d11ce29237c246188f4f51057d65a7eab63b7987e423"
+checksum = "fd6fbd9a79829dd1ad0cc20627bf1ed606756a7f77edff7b66b7064f9cb327c6"
 
 [[package]]
 name = "wasm-bindgen"
-version = "0.2.90"
+version = "0.2.79"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "b1223296a201415c7fad14792dbefaace9bd52b62d33453ade1c5b5f07555406"
+checksum = "25f1af7423d8588a3d840681122e72e6a24ddbcb3f0ec385cac0d12d24256c06"
 dependencies = [
  "cfg-if",
  "wasm-bindgen-macro",
@@ -1759,24 +1808,24 @@ dependencies = [
 
 [[package]]
 name = "wasm-bindgen-backend"
-version = "0.2.90"
+version = "0.2.79"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "fcdc935b63408d58a32f8cc9738a0bffd8f05cc7c002086c6ef20b7312ad9dcd"
+checksum = "8b21c0df030f5a177f3cba22e9bc4322695ec43e7257d865302900290bcdedca"
 dependencies = [
  "bumpalo",
+ "lazy_static",
  "log",
- "once_cell",
  "proc-macro2",
  "quote",
- "syn 2.0.48",
+ "syn 1.0.86",
  "wasm-bindgen-shared",
 ]
 
 [[package]]
 name = "wasm-bindgen-macro"
-version = "0.2.90"
+version = "0.2.79"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "3e4c238561b2d428924c49815533a8b9121c664599558a5d9ec51f8a1740a999"
+checksum = "2f4203d69e40a52ee523b2529a773d5ffc1dc0071801c87b3d270b471b80ed01"
 dependencies = [
  "quote",
  "wasm-bindgen-macro-support",
@@ -1784,33 +1833,33 @@ dependencies = [
 
 [[package]]
 name = "wasm-bindgen-macro-support"
-version = "0.2.90"
+version = "0.2.79"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "bae1abb6806dc1ad9e560ed242107c0f6c84335f1749dd4e8ddb012ebd5e25a7"
+checksum = "bfa8a30d46208db204854cadbb5d4baf5fcf8071ba5bf48190c3e59937962ebc"
 dependencies = [
  "proc-macro2",
  "quote",
- "syn 2.0.48",
+ "syn 1.0.86",
  "wasm-bindgen-backend",
  "wasm-bindgen-shared",
 ]
 
 [[package]]
 name = "wasm-bindgen-shared"
-version = "0.2.90"
+version = "0.2.79"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "4d91413b1c31d7539ba5ef2451af3f0b833a005eb27a631cec32bc0635a8602b"
+checksum = "3d958d035c4438e28c70e4321a2911302f10135ce78a9c7834c0cab4123d06a2"
 
 [[package]]
 name = "wayland-client"
-version = "0.29.5"
+version = "0.29.4"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "3f3b068c05a039c9f755f881dc50f01732214f5685e379829759088967c46715"
+checksum = "91223460e73257f697d9e23d401279123d36039a3f7a449e983f123292d4458f"
 dependencies = [
  "bitflags 1.3.2",
  "downcast-rs",
  "libc",
- "nix 0.24.3",
+ "nix 0.22.3",
  "scoped-tls",
  "wayland-commons",
  "wayland-scanner",
@@ -1819,11 +1868,11 @@ dependencies = [
 
 [[package]]
 name = "wayland-commons"
-version = "0.29.5"
+version = "0.29.4"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "8691f134d584a33a6606d9d717b95c4fa20065605f798a3f350d78dced02a902"
+checksum = "94f6e5e340d7c13490eca867898c4cec5af56c27a5ffe5c80c6fc4708e22d33e"
 dependencies = [
- "nix 0.24.3",
+ "nix 0.22.3",
  "once_cell",
  "smallvec",
  "wayland-sys",
@@ -1831,20 +1880,20 @@ dependencies = [
 
 [[package]]
 name = "wayland-cursor"
-version = "0.29.5"
+version = "0.29.4"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "6865c6b66f13d6257bef1cd40cbfe8ef2f150fb8ebbdb1e8e873455931377661"
+checksum = "c52758f13d5e7861fc83d942d3d99bf270c83269575e52ac29e5b73cb956a6bd"
 dependencies = [
- "nix 0.24.3",
+ "nix 0.22.3",
  "wayland-client",
  "xcursor",
 ]
 
 [[package]]
 name = "wayland-egl"
-version = "0.29.5"
+version = "0.29.4"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "402de949f81a012926d821a2d659f930694257e76dd92b6e0042ceb27be4107d"
+checksum = "83281d69ee162b59031c666385e93bde4039ec553b90c4191cdb128ceea29a3a"
 dependencies = [
  "wayland-client",
  "wayland-sys",
@@ -1852,9 +1901,9 @@ dependencies = [
 
 [[package]]
 name = "wayland-protocols"
-version = "0.29.5"
+version = "0.29.4"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "b950621f9354b322ee817a23474e479b34be96c2e909c14f7bc0100e9a970bc6"
+checksum = "60147ae23303402e41fe034f74fb2c35ad0780ee88a1c40ac09a3be1e7465741"
 dependencies = [
  "bitflags 1.3.2",
  "wayland-client",
@@ -1864,9 +1913,9 @@ dependencies = [
 
 [[package]]
 name = "wayland-scanner"
-version = "0.29.5"
+version = "0.29.4"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "8f4303d8fa22ab852f789e75a967f0a2cdc430a607751c0499bada3e451cbd53"
+checksum = "39a1ed3143f7a143187156a2ab52742e89dac33245ba505c17224df48939f9e0"
 dependencies = [
  "proc-macro2",
  "quote",
@@ -1875,9 +1924,9 @@ dependencies = [
 
 [[package]]
 name = "wayland-sys"
-version = "0.29.5"
+version = "0.29.4"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "be12ce1a3c39ec7dba25594b97b42cb3195d54953ddb9d3d95a7c3902bc6e9d4"
+checksum = "d9341df79a8975679188e37dab3889bfa57c44ac2cb6da166f519a81cbe452d4"
 dependencies = [
  "dlib",
  "lazy_static",
@@ -1886,9 +1935,9 @@ dependencies = [
 
 [[package]]
 name = "web-sys"
-version = "0.3.67"
+version = "0.3.56"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "58cd2333b6e0be7a39605f0e255892fd7418a682d8da8fe042fe25128794d2ed"
+checksum = "c060b319f29dd25724f09a2ba1418f142f539b2be99fbf4d2d5a8f7330afb8eb"
 dependencies = [
  "js-sys",
  "wasm-bindgen",
@@ -1912,9 +1961,9 @@ checksum = "ac3b87c63620426dd9b991e5ce0329eff545bccbbb34f3be09ff6fb6ab51b7b6"
 
 [[package]]
 name = "winapi-util"
-version = "0.1.6"
+version = "0.1.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "f29e6f9198ba0d26b4c9f07dbe6f9ed633e1f3d5b8b414090084349e46a52596"
+checksum = "70ec6ce85bb158151cae5e5c87f95a8e97d2c0c4b001223f33a334e3ce5de178"
 dependencies = [
  "winapi",
 ]
@@ -1938,35 +1987,27 @@ dependencies = [
  "windows_x86_64_msvc 0.36.1",
 ]
 
-[[package]]
-name = "windows-sys"
-version = "0.48.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "677d2418bec65e3338edb076e806bc1ec15693c5d0104683f2efe857f61056a9"
-dependencies = [
- "windows-targets",
-]
-
 [[package]]
 name = "windows-targets"
-version = "0.48.5"
+version = "0.52.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "9a2fa6e2155d7247be68c096456083145c183cbbbc2764150dda45a87197940c"
+checksum = "9b724f72796e036ab90c1021d4780d4d3d648aca59e491e6b98e725b84e99973"
 dependencies = [
  "windows_aarch64_gnullvm",
- "windows_aarch64_msvc 0.48.5",
- "windows_i686_gnu 0.48.5",
- "windows_i686_msvc 0.48.5",
- "windows_x86_64_gnu 0.48.5",
+ "windows_aarch64_msvc 0.52.6",
+ "windows_i686_gnu 0.52.6",
+ "windows_i686_gnullvm",
+ "windows_i686_msvc 0.52.6",
+ "windows_x86_64_gnu 0.52.6",
  "windows_x86_64_gnullvm",
- "windows_x86_64_msvc 0.48.5",
+ "windows_x86_64_msvc 0.52.6",
 ]
 
 [[package]]
 name = "windows_aarch64_gnullvm"
-version = "0.48.5"
+version = "0.52.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "2b38e32f0abccf9987a4e3079dfb67dcd799fb61361e53e2882c3cbaf0d905d8"
+checksum = "32a4622180e7a0ec044bb555404c800bc9fd9ec262ec147edd5989ccd0c02cd3"
 
 [[package]]
 name = "windows_aarch64_msvc"
@@ -1976,9 +2017,9 @@ checksum = "9bb8c3fd39ade2d67e9874ac4f3db21f0d710bee00fe7cab16949ec184eeaa47"
 
 [[package]]
 name = "windows_aarch64_msvc"
-version = "0.48.5"
+version = "0.52.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "dc35310971f3b2dbbf3f0690a219f40e2d9afcf64f9ab7cc1be722937c26b4bc"
+checksum = "09ec2a7bb152e2252b53fa7803150007879548bc709c039df7627cabbd05d469"
 
 [[package]]
 name = "windows_i686_gnu"
@@ -1988,9 +2029,15 @@ checksum = "180e6ccf01daf4c426b846dfc66db1fc518f074baa793aa7d9b9aaeffad6a3b6"
 
 [[package]]
 name = "windows_i686_gnu"
-version = "0.48.5"
+version = "0.52.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "a75915e7def60c94dcef72200b9a8e58e5091744960da64ec734a6c6e9b3743e"
+checksum = "8e9b5ad5ab802e97eb8e295ac6720e509ee4c243f69d781394014ebfe8bbfa0b"
+
+[[package]]
+name = "windows_i686_gnullvm"
+version = "0.52.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0eee52d38c090b3caa76c563b86c3a4bd71ef1a819287c19d586d7334ae8ed66"
 
 [[package]]
 name = "windows_i686_msvc"
@@ -2000,9 +2047,9 @@ checksum = "e2e7917148b2812d1eeafaeb22a97e4813dfa60a3f8f78ebe204bcc88f12f024"
 
 [[package]]
 name = "windows_i686_msvc"
-version = "0.48.5"
+version = "0.52.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "8f55c233f70c4b27f66c523580f78f1004e8b5a8b659e05a4eb49d4166cca406"
+checksum = "240948bc05c5e7c6dabba28bf89d89ffce3e303022809e73deaefe4f6ec56c66"
 
 [[package]]
 name = "windows_x86_64_gnu"
@@ -2012,15 +2059,15 @@ checksum = "4dcd171b8776c41b97521e5da127a2d86ad280114807d0b2ab1e462bc764d9e1"
 
 [[package]]
 name = "windows_x86_64_gnu"
-version = "0.48.5"
+version = "0.52.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "53d40abd2583d23e4718fddf1ebec84dbff8381c07cae67ff7768bbf19c6718e"
+checksum = "147a5c80aabfbf0c7d901cb5895d1de30ef2907eb21fbbab29ca94c5b08b1a78"
 
 [[package]]
 name = "windows_x86_64_gnullvm"
-version = "0.48.5"
+version = "0.52.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "0b7b52767868a23d5bab768e390dc5f5c55825b6d30b86c844ff2dc7414044cc"
+checksum = "24d5b23dc417412679681396f2b49f3de8c1473deb516bd34410872eff51ed0d"
 
 [[package]]
 name = "windows_x86_64_msvc"
@@ -2030,9 +2077,9 @@ checksum = "c811ca4a8c853ef420abd8592ba53ddbbac90410fab6903b3e79972a631f7680"
 
 [[package]]
 name = "windows_x86_64_msvc"
-version = "0.48.5"
+version = "0.52.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "ed94fce61571a4006852b7389a063ab983c02eb1bb37b47f8272ce92d06d9538"
+checksum = "589f6da84c646204747d1270a2a5661ea66ed1cced2631d546fdfb155959f9ec"
 
 [[package]]
 name = "winit"
@@ -2041,9 +2088,9 @@ source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "bb796d6fbd86b2fd896c9471e6f04d39d750076ebe5680a3958f00f5ab97657c"
 dependencies = [
  "bitflags 1.3.2",
- "cocoa 0.24.1",
+ "cocoa",
  "core-foundation",
- "core-graphics 0.22.3",
+ "core-graphics",
  "dispatch",
  "instant",
  "libc",
@@ -2063,19 +2110,10 @@ dependencies = [
  "wayland-client",
  "wayland-protocols",
  "web-sys",
- "windows-sys 0.36.1",
+ "windows-sys",
  "x11-dl",
 ]
 
-[[package]]
-name = "winnow"
-version = "0.5.34"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "b7cf47b659b318dccbd69cc4797a39ae128f533dce7902a1096044d1967b9c16"
-dependencies = [
- "memchr",
-]
-
 [[package]]
 name = "wio"
 version = "0.2.2"
@@ -2087,23 +2125,26 @@ dependencies = [
 
 [[package]]
 name = "x11-dl"
-version = "2.21.0"
+version = "2.19.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "38735924fedd5314a6e548792904ed8c6de6636285cb9fec04d5b1db85c1516f"
+checksum = "ea26926b4ce81a6f5d9d0f3a0bc401e5a37c6ae14a1bfaa8ff6099ca80038c59"
 dependencies = [
+ "lazy_static",
  "libc",
- "once_cell",
  "pkg-config",
 ]
 
 [[package]]
 name = "xcursor"
-version = "0.3.5"
+version = "0.3.4"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "6a0ccd7b4a5345edfcd0c3535718a4e9ff7798ffc536bb5b5a0e26ff84732911"
+checksum = "463705a63313cd4301184381c5e8042f0a7e9b4bb63653f216311d4ae74690b7"
+dependencies = [
+ "nom",
+]
 
 [[package]]
 name = "xml-rs"
-version = "0.8.19"
+version = "0.8.4"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "0fcb9cbac069e033553e8bb871be2fbdffcab578eb25bd0f7c508cedc6dcd75a"
+checksum = "d2d7d3948613f75c98fd9328cfdcc45acc4d360655289d0a7d4ec931392200a3"
diff --git a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/Cargo.toml b/third_party/rust/chromium_crates_io/vendor/png-0.17.14/Cargo.toml
similarity index 98%
rename from third_party/rust/chromium_crates_io/vendor/png-0.17.13/Cargo.toml
rename to third_party/rust/chromium_crates_io/vendor/png-0.17.14/Cargo.toml
index 9ae81904f8fcd8..d10d5c7f67230f 100644
--- a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/Cargo.toml
+++ b/third_party/rust/chromium_crates_io/vendor/png-0.17.14/Cargo.toml
@@ -13,7 +13,7 @@
 edition = "2018"
 rust-version = "1.57"
 name = "png"
-version = "0.17.13"
+version = "0.17.14"
 authors = ["The image-rs Developers"]
 include = [
     "/LICENSE-MIT",
@@ -60,7 +60,7 @@ version = "0.3.3"
 version = "1.0.11"
 
 [dependencies.miniz_oxide]
-version = "0.7.1"
+version = "0.8"
 features = ["simd"]
 
 [dev-dependencies.byteorder]
diff --git a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/Cargo.toml.orig b/third_party/rust/chromium_crates_io/vendor/png-0.17.14/Cargo.toml.orig
similarity index 90%
rename from third_party/rust/chromium_crates_io/vendor/png-0.17.13/Cargo.toml.orig
rename to third_party/rust/chromium_crates_io/vendor/png-0.17.14/Cargo.toml.orig
index 5849279d4f8c09..08d475bcf789d7 100644
--- a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/Cargo.toml.orig
+++ b/third_party/rust/chromium_crates_io/vendor/png-0.17.14/Cargo.toml.orig
@@ -1,6 +1,6 @@
 [package]
 name = "png"
-version = "0.17.13"
+version = "0.17.14"
 license = "MIT OR Apache-2.0"
 
 description = "PNG decoding and encoding library in pure Rust"
@@ -25,7 +25,7 @@ bitflags = "1.0"
 crc32fast = "1.2.0"
 fdeflate = "0.3.3"
 flate2 = "1.0.11"
-miniz_oxide = { version = "0.7.1", features = ["simd"] }
+miniz_oxide = { version = "0.8", features = ["simd"] }
 
 [dev-dependencies]
 byteorder = "1.5.0"
@@ -56,4 +56,4 @@ required-features = ["benchmarks"]
 path = "benches/expand_paletted.rs"
 name = "expand_paletted"
 harness = false
-required-features = ["benchmarks"]
\ No newline at end of file
+required-features = ["benchmarks"]
diff --git a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/LICENSE-APACHE b/third_party/rust/chromium_crates_io/vendor/png-0.17.14/LICENSE-APACHE
similarity index 100%
rename from third_party/rust/chromium_crates_io/vendor/png-0.17.13/LICENSE-APACHE
rename to third_party/rust/chromium_crates_io/vendor/png-0.17.14/LICENSE-APACHE
diff --git a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/LICENSE-MIT b/third_party/rust/chromium_crates_io/vendor/png-0.17.14/LICENSE-MIT
similarity index 100%
rename from third_party/rust/chromium_crates_io/vendor/png-0.17.13/LICENSE-MIT
rename to third_party/rust/chromium_crates_io/vendor/png-0.17.14/LICENSE-MIT
diff --git a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/README.md b/third_party/rust/chromium_crates_io/vendor/png-0.17.14/README.md
similarity index 89%
rename from third_party/rust/chromium_crates_io/vendor/png-0.17.13/README.md
rename to third_party/rust/chromium_crates_io/vendor/png-0.17.14/README.md
index e6719bc5f59ba4..2b7bac5521b5a3 100644
--- a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/README.md
+++ b/third_party/rust/chromium_crates_io/vendor/png-0.17.14/README.md
@@ -2,9 +2,7 @@
 [![Build Status](https://github.com/image-rs/image-png/workflows/Rust%20CI/badge.svg)](https://github.com/image-rs/image-png/actions)
 [![Documentation](https://docs.rs/png/badge.svg)](https://docs.rs/png)
 [![Crates.io](https://img.shields.io/crates/v/png.svg)](https://crates.io/crates/png)
-![Lines of Code](https://tokei.rs/b1/github/image-rs/image-png)
 [![License](https://img.shields.io/crates/l/png.svg)](https://github.com/image-rs/image-png)
-[![fuzzit](https://app.fuzzit.dev/badge?org_id=image-rs)](https://app.fuzzit.dev/orgs/image-rs/dashboard)
 
 PNG decoder/encoder in pure Rust.
 
diff --git a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/benches/README.md b/third_party/rust/chromium_crates_io/vendor/png-0.17.14/benches/README.md
similarity index 100%
rename from third_party/rust/chromium_crates_io/vendor/png-0.17.13/benches/README.md
rename to third_party/rust/chromium_crates_io/vendor/png-0.17.14/benches/README.md
diff --git a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/benches/decoder.rs b/third_party/rust/chromium_crates_io/vendor/png-0.17.14/benches/decoder.rs
similarity index 100%
rename from third_party/rust/chromium_crates_io/vendor/png-0.17.13/benches/decoder.rs
rename to third_party/rust/chromium_crates_io/vendor/png-0.17.14/benches/decoder.rs
diff --git a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/benches/expand_paletted.rs b/third_party/rust/chromium_crates_io/vendor/png-0.17.14/benches/expand_paletted.rs
similarity index 100%
rename from third_party/rust/chromium_crates_io/vendor/png-0.17.13/benches/expand_paletted.rs
rename to third_party/rust/chromium_crates_io/vendor/png-0.17.14/benches/expand_paletted.rs
diff --git a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/benches/unfilter.rs b/third_party/rust/chromium_crates_io/vendor/png-0.17.14/benches/unfilter.rs
similarity index 100%
rename from third_party/rust/chromium_crates_io/vendor/png-0.17.13/benches/unfilter.rs
rename to third_party/rust/chromium_crates_io/vendor/png-0.17.14/benches/unfilter.rs
diff --git a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/examples/change-png-info.rs b/third_party/rust/chromium_crates_io/vendor/png-0.17.14/examples/change-png-info.rs
similarity index 100%
rename from third_party/rust/chromium_crates_io/vendor/png-0.17.13/examples/change-png-info.rs
rename to third_party/rust/chromium_crates_io/vendor/png-0.17.14/examples/change-png-info.rs
diff --git a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/examples/corpus-bench.rs b/third_party/rust/chromium_crates_io/vendor/png-0.17.14/examples/corpus-bench.rs
similarity index 100%
rename from third_party/rust/chromium_crates_io/vendor/png-0.17.13/examples/corpus-bench.rs
rename to third_party/rust/chromium_crates_io/vendor/png-0.17.14/examples/corpus-bench.rs
diff --git a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/examples/png-generate.rs b/third_party/rust/chromium_crates_io/vendor/png-0.17.14/examples/png-generate.rs
similarity index 100%
rename from third_party/rust/chromium_crates_io/vendor/png-0.17.13/examples/png-generate.rs
rename to third_party/rust/chromium_crates_io/vendor/png-0.17.14/examples/png-generate.rs
diff --git a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/examples/pngcheck.rs b/third_party/rust/chromium_crates_io/vendor/png-0.17.14/examples/pngcheck.rs
similarity index 98%
rename from third_party/rust/chromium_crates_io/vendor/png-0.17.13/examples/pngcheck.rs
rename to third_party/rust/chromium_crates_io/vendor/png-0.17.14/examples/pngcheck.rs
index 69e95e3c1dc60a..97f8b0d5b08f2f 100644
--- a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/examples/pngcheck.rs
+++ b/third_party/rust/chromium_crates_io/vendor/png-0.17.14/examples/pngcheck.rs
@@ -1,9 +1,5 @@
 #![allow(non_upper_case_globals)]
 
-extern crate getopts;
-extern crate glob;
-extern crate png;
-
 use std::env;
 use std::fs::File;
 use std::io;
@@ -77,7 +73,7 @@ fn final_channels(c: png::ColorType, trns: bool) -> u8 {
     }
 }
 fn check_image<P: AsRef<Path>>(c: Config, fname: P) -> io::Result<()> {
-    // TODO improve performance by resusing allocations from decoder
+    // TODO improve performance by reusing allocations from decoder
     use png::Decoded::*;
     let mut t = term::stdout()
         .ok_or_else(|| io::Error::new(io::ErrorKind::Other, "could not open terminal"))?;
@@ -252,7 +248,7 @@ fn check_image<P: AsRef<Path>>(c: Config, fname: P) -> io::Result<()> {
                             }
                             print!(
                                 " at offset {:#07x}, length {}",
-                                pos - 4, // substract chunk name length
+                                pos - 4, // subtract chunk name length
                                 len
                             )
                         }
diff --git a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/examples/show.rs b/third_party/rust/chromium_crates_io/vendor/png-0.17.14/examples/show.rs
similarity index 100%
rename from third_party/rust/chromium_crates_io/vendor/png-0.17.13/examples/show.rs
rename to third_party/rust/chromium_crates_io/vendor/png-0.17.14/examples/show.rs
diff --git a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/adam7.rs b/third_party/rust/chromium_crates_io/vendor/png-0.17.14/src/adam7.rs
similarity index 100%
rename from third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/adam7.rs
rename to third_party/rust/chromium_crates_io/vendor/png-0.17.14/src/adam7.rs
diff --git a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/benchable_apis.rs b/third_party/rust/chromium_crates_io/vendor/png-0.17.14/src/benchable_apis.rs
similarity index 100%
rename from third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/benchable_apis.rs
rename to third_party/rust/chromium_crates_io/vendor/png-0.17.14/src/benchable_apis.rs
diff --git a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/chunk.rs b/third_party/rust/chromium_crates_io/vendor/png-0.17.14/src/chunk.rs
similarity index 100%
rename from third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/chunk.rs
rename to third_party/rust/chromium_crates_io/vendor/png-0.17.14/src/chunk.rs
diff --git a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/common.rs b/third_party/rust/chromium_crates_io/vendor/png-0.17.14/src/common.rs
similarity index 99%
rename from third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/common.rs
rename to third_party/rust/chromium_crates_io/vendor/png-0.17.14/src/common.rs
index 400aca11523c5e..4475153e30db6b 100644
--- a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/common.rs
+++ b/third_party/rust/chromium_crates_io/vendor/png-0.17.14/src/common.rs
@@ -343,7 +343,7 @@ impl ScaledFloat {
 
     /// Gets whether the value is within the clamped range of this type.
     pub fn in_range(value: f32) -> bool {
-        value >= 0.0 && (value * Self::SCALING).floor() <= std::u32::MAX as f32
+        value >= 0.0 && (value * Self::SCALING).floor() <= u32::MAX as f32
     }
 
     /// Gets whether the value can be exactly converted in round-trip.
@@ -704,7 +704,7 @@ impl BytesPerPixel {
     }
 }
 
-bitflags! {
+bitflags::bitflags! {
     /// Output transformations
     ///
     /// Many flags from libpng are not yet supported. A PR discussing/adding them would be nice.
diff --git a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/decoder/interlace_info.rs b/third_party/rust/chromium_crates_io/vendor/png-0.17.14/src/decoder/interlace_info.rs
similarity index 100%
rename from third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/decoder/interlace_info.rs
rename to third_party/rust/chromium_crates_io/vendor/png-0.17.14/src/decoder/interlace_info.rs
diff --git a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/decoder/mod.rs b/third_party/rust/chromium_crates_io/vendor/png-0.17.14/src/decoder/mod.rs
similarity index 94%
rename from third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/decoder/mod.rs
rename to third_party/rust/chromium_crates_io/vendor/png-0.17.14/src/decoder/mod.rs
index 6450ac830e886c..8a76200c93bf40 100644
--- a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/decoder/mod.rs
+++ b/third_party/rust/chromium_crates_io/vendor/png-0.17.14/src/decoder/mod.rs
@@ -4,10 +4,10 @@ pub(crate) mod transform;
 mod zlib;
 
 pub use self::stream::{DecodeOptions, Decoded, DecodingError, StreamingDecoder};
-use self::stream::{FormatErrorInner, CHUNCK_BUFFER_SIZE};
+use self::stream::{FormatErrorInner, CHUNK_BUFFER_SIZE};
 use self::transform::{create_transform_fn, TransformFn};
 
-use std::io::{BufRead, BufReader, Read};
+use std::io::{BufRead, BufReader, ErrorKind, Read};
 use std::mem;
 
 use crate::adam7::{self, Adam7Info};
@@ -132,7 +132,7 @@ impl<R: Read> Decoder<R> {
 
         Decoder {
             read_decoder: ReadDecoder {
-                reader: BufReader::with_capacity(CHUNCK_BUFFER_SIZE, r),
+                reader: BufReader::with_capacity(CHUNK_BUFFER_SIZE, r),
                 decoder,
                 at_eof: false,
             },
@@ -147,7 +147,7 @@ impl<R: Read> Decoder<R> {
 
         Decoder {
             read_decoder: ReadDecoder {
-                reader: BufReader::with_capacity(CHUNCK_BUFFER_SIZE, r),
+                reader: BufReader::with_capacity(CHUNK_BUFFER_SIZE, r),
                 decoder,
                 at_eof: false,
             },
@@ -191,7 +191,7 @@ impl<R: Read> Decoder<R> {
         while self.read_decoder.info().is_none() {
             buf.clear();
             if self.read_decoder.decode_next(&mut buf)?.is_none() {
-                return Err(DecodingError::IoError(std::io::ErrorKind::UnexpectedEof.into()));
+                return Err(DecodingError::IoError(ErrorKind::UnexpectedEof.into()));
             }
         }
         Ok(self.read_decoder.info().unwrap())
@@ -261,6 +261,22 @@ impl<R: Read> Decoder<R> {
             .set_ignore_text_chunk(ignore_text_chunk);
     }
 
+    /// Set the decoder to ignore iccp chunks while parsing.
+    ///
+    /// eg.
+    /// ```
+    /// use std::fs::File;
+    /// use png::Decoder;
+    /// let mut decoder = Decoder::new(File::open("tests/iccp/broken_iccp.png").unwrap());
+    /// decoder.set_ignore_iccp_chunk(true);
+    /// assert!(decoder.read_info().is_ok());
+    /// ```
+    pub fn set_ignore_iccp_chunk(&mut self, ignore_iccp_chunk: bool) {
+        self.read_decoder
+            .decoder
+            .set_ignore_iccp_chunk(ignore_iccp_chunk);
+    }
+
     /// Set the decoder to ignore and not verify the Adler-32 checksum
     /// and CRC code.
     pub fn ignore_checksums(&mut self, ignore_checksums: bool) {
@@ -285,7 +301,7 @@ impl<R: Read> ReadDecoder<R> {
             let (consumed, result) = {
                 let buf = self.reader.fill_buf()?;
                 if buf.is_empty() {
-                    return Err(DecodingError::IoError(std::io::ErrorKind::UnexpectedEof.into()));
+                    return Err(DecodingError::IoError(ErrorKind::UnexpectedEof.into()));
                 }
                 self.decoder.update(buf, image_data)?
             };
@@ -303,7 +319,7 @@ impl<R: Read> ReadDecoder<R> {
         while !self.at_eof {
             let buf = self.reader.fill_buf()?;
             if buf.is_empty() {
-                return Err(DecodingError::IoError(std::io::ErrorKind::UnexpectedEof.into()));
+                return Err(DecodingError::IoError(ErrorKind::UnexpectedEof.into()));
             }
             let (consumed, event) = self.decoder.update(buf, &mut vec![])?;
             self.reader.consume(consumed);
@@ -318,7 +334,7 @@ impl<R: Read> ReadDecoder<R> {
             }
         }
 
-        Err(DecodingError::IoError(std::io::ErrorKind::UnexpectedEof.into()))
+        Err(DecodingError::IoError(ErrorKind::UnexpectedEof.into()))
     }
 
     fn info(&self) -> Option<&Info<'static>> {
@@ -399,7 +415,6 @@ impl<R: Read> Reader<R> {
                 Some(Decoded::ChunkBegin(_, chunk::IDAT))
                 | Some(Decoded::ChunkBegin(_, chunk::fdAT)) => break,
                 Some(Decoded::FrameControl(_)) => {
-                    self.subframe = SubframeInfo::new(self.info());
                     // The next frame is the one to which this chunk applies.
                     self.next_frame = SubframeIdx::Some(self.fctl_read);
                     // TODO: what about overflow here? That would imply there are more fctl chunks
@@ -458,17 +473,13 @@ impl<R: Read> Reader<R> {
     /// Output lines will be written in row-major, packed matrix with width and height of the read
     /// frame (or subframe), all samples are in big endian byte order where this matters.
     pub fn next_frame(&mut self, buf: &mut [u8]) -> Result<OutputInfo, DecodingError> {
-        let subframe_idx = match self.decoder.info().unwrap().frame_control() {
-            None => SubframeIdx::Initial,
-            Some(_) => SubframeIdx::Some(self.fctl_read - 1),
-        };
-
         if self.next_frame == SubframeIdx::End {
             return Err(DecodingError::Parameter(
                 ParameterErrorKind::PolledAfterEndOfImage.into(),
             ));
-        } else if self.next_frame != subframe_idx {
-            // Advance until we've read the info / fcTL for this frame.
+        } else if self.subframe.consumed_and_flushed {
+            // Advance until the next `fdAT`
+            // (along the way we should encounter the fcTL for this frame).
             self.read_until_image_data()?;
         }
 
@@ -523,6 +534,7 @@ impl<R: Read> Reader<R> {
         // Advance over the rest of data for this (sub-)frame.
         if !self.subframe.consumed_and_flushed {
             self.decoder.finish_decoding()?;
+            self.subframe.consumed_and_flushed = true;
         }
 
         // Advance our state to expect the next frame.
@@ -686,7 +698,9 @@ impl<R: Read> Reader<R> {
         // Read image data until we have at least one full row (but possibly more than one).
         while self.data_stream.len() - self.current_start < rowlen {
             if self.subframe.consumed_and_flushed {
-                return Err(DecodingError::IoError(std::io::ErrorKind::UnexpectedEof.into()));
+                return Err(DecodingError::Format(
+                    FormatErrorInner::NoMoreImageData.into(),
+                ));
             }
 
             // Clear the current buffer before appending more data.
@@ -699,13 +713,8 @@ impl<R: Read> Reader<R> {
             }
 
             match self.decoder.decode_next(&mut self.data_stream)? {
-                Some(Decoded::ImageData) => {}
-                Some(Decoded::ImageDataFlushed) => {
-                    self.subframe.consumed_and_flushed = true;
-                }
-                None => {
-                    return Err(DecodingError::IoError(std::io::ErrorKind::UnexpectedEof.into()));
-                }
+                Some(Decoded::ImageData) => (),
+                Some(Decoded::ImageDataFlushed) => self.subframe.consumed_and_flushed = true,
                 _ => (),
             }
         }
diff --git a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/decoder/stream.rs b/third_party/rust/chromium_crates_io/vendor/png-0.17.14/src/decoder/stream.rs
similarity index 92%
rename from third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/decoder/stream.rs
rename to third_party/rust/chromium_crates_io/vendor/png-0.17.14/src/decoder/stream.rs
index 207c0c8e548e23..ac6e6c00b4df50 100644
--- a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/decoder/stream.rs
+++ b/third_party/rust/chromium_crates_io/vendor/png-0.17.14/src/decoder/stream.rs
@@ -1,7 +1,4 @@
-extern crate crc32fast;
-
-use std::convert::{From, TryInto};
-use std::default::Default;
+use std::convert::TryInto;
 use std::error;
 use std::fmt;
 use std::io;
@@ -20,7 +17,7 @@ use crate::traits::ReadBytesExt;
 use crate::Limits;
 
 /// TODO check if these size are reasonable
-pub const CHUNCK_BUFFER_SIZE: usize = 32 * 1024;
+pub const CHUNK_BUFFER_SIZE: usize = 32 * 1024;
 
 /// Determines if checksum checks should be disabled globally.
 ///
@@ -231,15 +228,32 @@ pub(crate) enum FormatErrorInner {
     /// The subframe is not in bounds of the image.
     /// TODO: fields with relevant data.
     BadSubFrameBounds {},
-    // Errors specific to the IDAT/fDAT chunks.
+    // Errors specific to the IDAT/fdAT chunks.
     /// The compression of the data stream was faulty.
     CorruptFlateStream {
         err: fdeflate::DecompressionError,
     },
+    /// The image data chunk was too short for the expected pixel count.
+    NoMoreImageData,
     /// Bad text encoding
     BadTextEncoding(TextDecodingError),
     /// fdAT shorter than 4 bytes
     FdatShorterThanFourBytes,
+    /// "11.2.4 IDAT Image data" section of the PNG spec says: There may be multiple IDAT chunks;
+    /// if so, they shall appear consecutively with no other intervening chunks.
+    /// `UnexpectedRestartOfDataChunkSequence{kind: IDAT}` indicates that there were "intervening
+    /// chunks".
+    ///
+    /// The APNG spec doesn't directly describe an error similar to `CantInterleaveIdatChunks`,
+    /// but we require that a new sequence of consecutive `fdAT` chunks cannot appear unless we've
+    /// seen an `fcTL` chunk.
+    UnexpectedRestartOfDataChunkSequence {
+        kind: ChunkType,
+    },
+    /// Failure to parse a chunk, because the chunk didn't contain enough bytes.
+    ChunkTooShort {
+        kind: ChunkType,
+    },
 }
 
 impl error::Error for DecodingError {
@@ -279,7 +293,7 @@ impl fmt::Display for FormatError {
             ),
             MissingIhdr => write!(fmt, "IHDR chunk missing"),
             MissingFctl => write!(fmt, "fcTL chunk missing before fdAT chunk."),
-            MissingImageData => write!(fmt, "IDAT or fDAT chunk is missing."),
+            MissingImageData => write!(fmt, "IDAT or fdAT chunk is missing."),
             ChunkBeforeIhdr { kind } => write!(fmt, "{:?} chunk appeared before IHDR chunk", kind),
             AfterIdat { kind } => write!(fmt, "Chunk {:?} is invalid after IDAT chunk.", kind),
             AfterPlte { kind } => write!(fmt, "Chunk {:?} is invalid after PLTE chunk.", kind),
@@ -314,7 +328,7 @@ impl fmt::Display for FormatError {
                 "Transparency chunk found for color type {:?}.",
                 color_type
             ),
-            InvalidBitDepth(nr) => write!(fmt, "Invalid dispose operation {}.", nr),
+            InvalidBitDepth(nr) => write!(fmt, "Invalid bit depth {}.", nr),
             InvalidColorType(nr) => write!(fmt, "Invalid color type {}.", nr),
             InvalidDisposeOp(nr) => write!(fmt, "Invalid dispose op {}.", nr),
             InvalidBlendOp(nr) => write!(fmt, "Invalid blend op {}.", nr),
@@ -325,6 +339,10 @@ impl fmt::Display for FormatError {
             UnknownInterlaceMethod(nr) => write!(fmt, "Unknown interlace method {}.", nr),
             BadSubFrameBounds {} => write!(fmt, "Sub frame is out-of-bounds."),
             InvalidSignature => write!(fmt, "Invalid PNG signature."),
+            NoMoreImageData => write!(
+                fmt,
+                "IDAT or fDAT chunk does not have enough data for image."
+            ),
             CorruptFlateStream { err } => {
                 write!(fmt, "Corrupt deflate stream. ")?;
                 write!(fmt, "{:?}", err)
@@ -359,6 +377,12 @@ impl fmt::Display for FormatError {
                 }
             }
             FdatShorterThanFourBytes => write!(fmt, "fdAT chunk shorter than 4 bytes"),
+            UnexpectedRestartOfDataChunkSequence { kind } => {
+                write!(fmt, "Unexpected restart of {:?} chunk sequence", kind)
+            }
+            ChunkTooShort { kind } => {
+                write!(fmt, "Chunk is too short: {:?}", kind)
+            }
         }
     }
 }
@@ -404,6 +428,7 @@ pub struct DecodeOptions {
     ignore_adler32: bool,
     ignore_crc: bool,
     ignore_text_chunk: bool,
+    ignore_iccp_chunk: bool,
     skip_ancillary_crc_failures: bool,
 }
 
@@ -413,6 +438,7 @@ impl Default for DecodeOptions {
             ignore_adler32: true,
             ignore_crc: false,
             ignore_text_chunk: false,
+            ignore_iccp_chunk: false,
             skip_ancillary_crc_failures: true,
         }
     }
@@ -447,6 +473,13 @@ impl DecodeOptions {
         self.ignore_text_chunk = ignore_text_chunk;
     }
 
+    /// Ignore ICCP chunks while decoding.
+    ///
+    /// Defaults to `false`.
+    pub fn set_ignore_iccp_chunk(&mut self, ignore_iccp_chunk: bool) {
+        self.ignore_iccp_chunk = ignore_iccp_chunk;
+    }
+
     /// Ignore ancillary chunks if CRC fails
     ///
     /// Defaults to `true`
@@ -472,6 +505,15 @@ pub struct StreamingDecoder {
     /// Whether we have already seen a start of an IDAT chunk.  (Used to validate chunk ordering -
     /// some chunk types can only appear before or after an IDAT chunk.)
     have_idat: bool,
+    /// Whether we are ready for a start of an `IDAT` chunk sequence.  Initially `true` and set to
+    /// `false` when the first sequence of consecutive `IDAT` chunks ends.
+    ready_for_idat_chunks: bool,
+    /// Whether we are ready for a start of an `fdAT` chunk sequence.  Initially `false`.  Set to
+    /// `true` after encountering an `fcTL` chunk. Set to `false` when a sequence of consecutive
+    /// `fdAT` chunks ends.
+    ready_for_fdat_chunks: bool,
+    /// Whether we have already seen an iCCP chunk. Used to prevent parsing of duplicate iCCP chunks.
+    have_iccp: bool,
     decode_options: DecodeOptions,
     pub(crate) limits: Limits,
 }
@@ -510,6 +552,9 @@ impl StreamingDecoder {
             info: None,
             current_seq_no: None,
             have_idat: false,
+            have_iccp: false,
+            ready_for_idat_chunks: true,
+            ready_for_fdat_chunks: false,
             decode_options,
             limits: Limits { bytes: usize::MAX },
         }
@@ -536,6 +581,10 @@ impl StreamingDecoder {
         self.decode_options.set_ignore_text_chunk(ignore_text_chunk);
     }
 
+    pub fn set_ignore_iccp_chunk(&mut self, ignore_iccp_chunk: bool) {
+        self.decode_options.set_ignore_iccp_chunk(ignore_iccp_chunk);
+    }
+
     /// Return whether the decoder is set to ignore the Adler-32 checksum.
     pub fn ignore_adler32(&self) -> bool {
         self.inflater.ignore_adler32()
@@ -757,6 +806,8 @@ impl StreamingDecoder {
                     self.current_chunk.type_ = type_str;
                     self.inflater.finish_compressed_chunks(image_data)?;
                     self.inflater.reset();
+                    self.ready_for_idat_chunks = false;
+                    self.ready_for_fdat_chunks = false;
                     self.state = Some(State::U32 {
                         kind,
                         bytes,
@@ -764,15 +815,16 @@ impl StreamingDecoder {
                     });
                     return Ok(Decoded::ImageDataFlushed);
                 }
-                self.current_chunk.type_ = type_str;
-                if !self.decode_options.ignore_crc {
-                    self.current_chunk.crc.reset();
-                    self.current_chunk.crc.update(&type_str.0);
-                }
-                self.current_chunk.remaining = length;
-                self.current_chunk.raw_bytes.clear();
                 self.state = match type_str {
                     chunk::fdAT => {
+                        if !self.ready_for_fdat_chunks {
+                            return Err(DecodingError::Format(
+                                FormatErrorInner::UnexpectedRestartOfDataChunkSequence {
+                                    kind: chunk::fdAT,
+                                }
+                                .into(),
+                            ));
+                        }
                         if length < 4 {
                             return Err(DecodingError::Format(
                                 FormatErrorInner::FdatShorterThanFourBytes.into(),
@@ -781,11 +833,26 @@ impl StreamingDecoder {
                         Some(State::new_u32(U32ValueKind::ApngSequenceNumber))
                     }
                     IDAT => {
+                        if !self.ready_for_idat_chunks {
+                            return Err(DecodingError::Format(
+                                FormatErrorInner::UnexpectedRestartOfDataChunkSequence {
+                                    kind: IDAT,
+                                }
+                                .into(),
+                            ));
+                        }
                         self.have_idat = true;
                         Some(State::ImageData(type_str))
                     }
                     _ => Some(State::ReadChunkData(type_str)),
                 };
+                self.current_chunk.type_ = type_str;
+                if !self.decode_options.ignore_crc {
+                    self.current_chunk.crc.reset();
+                    self.current_chunk.crc.update(&type_str.0);
+                }
+                self.current_chunk.remaining = length;
+                self.current_chunk.raw_bytes.clear();
                 Ok(Decoded::ChunkBegin(length, type_str))
             }
             U32ValueKind::Crc(type_str) => {
@@ -884,16 +951,29 @@ impl StreamingDecoder {
             chunk::fcTL => self.parse_fctl(),
             chunk::cHRM => self.parse_chrm(),
             chunk::sRGB => self.parse_srgb(),
-            chunk::iCCP => self.parse_iccp(),
+            chunk::iCCP if !self.decode_options.ignore_iccp_chunk => self.parse_iccp(),
             chunk::tEXt if !self.decode_options.ignore_text_chunk => self.parse_text(),
             chunk::zTXt if !self.decode_options.ignore_text_chunk => self.parse_ztxt(),
             chunk::iTXt if !self.decode_options.ignore_text_chunk => self.parse_itxt(),
             _ => Ok(Decoded::PartialChunk(type_str)),
         };
 
-        if parse_result.is_err() {
+        let parse_result = parse_result.map_err(|e| {
             self.state = None;
-        }
+            match e {
+                // `parse_chunk` is invoked after gathering **all** bytes of a chunk, so
+                // `UnexpectedEof` from something like `read_be` is permanent and indicates an
+                // invalid PNG that should be represented as a `FormatError`, rather than as a
+                // (potentially recoverable) `IoError` / `UnexpectedEof`.
+                DecodingError::IoError(e) if e.kind() == std::io::ErrorKind::UnexpectedEof => {
+                    let fmt_err: FormatError =
+                        FormatErrorInner::ChunkTooShort { kind: type_str }.into();
+                    fmt_err.into()
+                }
+                e => e,
+            }
+        });
+
         parse_result
     }
 
@@ -926,6 +1006,7 @@ impl StreamingDecoder {
             0
         });
         self.inflater.reset();
+        self.ready_for_fdat_chunks = true;
         let fc = FrameControl {
             sequence_number: next_seq_no,
             width: buf.read_be()?,
@@ -1186,12 +1267,11 @@ impl StreamingDecoder {
     }
 
     fn parse_iccp(&mut self) -> Result<Decoded, DecodingError> {
-        let info = self.info.as_mut().unwrap();
         if self.have_idat {
             Err(DecodingError::Format(
                 FormatErrorInner::AfterIdat { kind: chunk::iCCP }.into(),
             ))
-        } else if info.icc_profile.is_some() {
+        } else if self.have_iccp {
             // We have already encountered an iCCP chunk before.
             //
             // Section "4.2.2.4. iCCP Embedded ICC profile" of the spec says:
@@ -1205,44 +1285,51 @@ impl StreamingDecoder {
             //     (treating them as a benign error).
             Ok(Decoded::Nothing)
         } else {
-            let mut buf = &self.current_chunk.raw_bytes[..];
+            self.have_iccp = true;
+            let _ = self.parse_iccp_raw();
+            Ok(Decoded::Nothing)
+        }
+    }
 
-            // read profile name
-            let _: u8 = buf.read_be()?;
-            for _ in 1..80 {
-                let raw: u8 = buf.read_be()?;
-                if raw == 0 {
-                    break;
-                }
-            }
+    fn parse_iccp_raw(&mut self) -> Result<(), DecodingError> {
+        let info = self.info.as_mut().unwrap();
+        let mut buf = &self.current_chunk.raw_bytes[..];
 
-            match buf.read_be()? {
-                // compression method
-                0u8 => (),
-                n => {
-                    return Err(DecodingError::Format(
-                        FormatErrorInner::UnknownCompressionMethod(n).into(),
-                    ))
-                }
+        // read profile name
+        let _: u8 = buf.read_be()?;
+        for _ in 1..80 {
+            let raw: u8 = buf.read_be()?;
+            if raw == 0 {
+                break;
             }
+        }
 
-            match fdeflate::decompress_to_vec_bounded(buf, self.limits.bytes) {
-                Ok(profile) => {
-                    self.limits.reserve_bytes(profile.len())?;
-                    info.icc_profile = Some(Cow::Owned(profile));
-                }
-                Err(fdeflate::BoundedDecompressionError::DecompressionError { inner: err }) => {
-                    return Err(DecodingError::Format(
-                        FormatErrorInner::CorruptFlateStream { err }.into(),
-                    ))
-                }
-                Err(fdeflate::BoundedDecompressionError::OutputTooLarge { .. }) => {
-                    return Err(DecodingError::LimitsExceeded);
-                }
+        match buf.read_be()? {
+            // compression method
+            0u8 => (),
+            n => {
+                return Err(DecodingError::Format(
+                    FormatErrorInner::UnknownCompressionMethod(n).into(),
+                ))
             }
+        }
 
-            Ok(Decoded::Nothing)
+        match fdeflate::decompress_to_vec_bounded(buf, self.limits.bytes) {
+            Ok(profile) => {
+                self.limits.reserve_bytes(profile.len())?;
+                info.icc_profile = Some(Cow::Owned(profile));
+            }
+            Err(fdeflate::BoundedDecompressionError::DecompressionError { inner: err }) => {
+                return Err(DecodingError::Format(
+                    FormatErrorInner::CorruptFlateStream { err }.into(),
+                ))
+            }
+            Err(fdeflate::BoundedDecompressionError::OutputTooLarge { .. }) => {
+                return Err(DecodingError::LimitsExceeded);
+            }
         }
+
+        Ok(())
     }
 
     fn parse_ihdr(&mut self) -> Result<Decoded, DecodingError> {
@@ -1474,7 +1561,7 @@ impl Default for ChunkState {
             type_: ChunkType([0; 4]),
             crc: Crc32::new(),
             remaining: 0,
-            raw_bytes: Vec::with_capacity(CHUNCK_BUFFER_SIZE),
+            raw_bytes: Vec::with_capacity(CHUNK_BUFFER_SIZE),
         }
     }
 }
@@ -1738,6 +1825,15 @@ mod tests {
         assert_eq!(4070462061, crc32fast::hash(&icc_profile));
     }
 
+    #[test]
+    fn test_png_with_broken_iccp() {
+        let decoder = crate::Decoder::new(File::open("tests/iccp/broken_iccp.png").unwrap());
+        assert!(decoder.read_info().is_ok());
+        let mut decoder = crate::Decoder::new(File::open("tests/iccp/broken_iccp.png").unwrap());
+        decoder.set_ignore_iccp_chunk(true);
+        assert!(decoder.read_info().is_ok());
+    }
+
     /// Writes an acTL chunk.
     /// See https://wiki.mozilla.org/APNG_Specification#.60acTL.60:_The_Animation_Control_Chunk
     fn write_actl(w: &mut impl Write, animation: &crate::AnimationControl) {
@@ -1907,7 +2003,7 @@ mod tests {
                 panic!("No fcTL (2nd frame)");
             };
             // The sequence number is taken from the `fcTL` chunk that comes before the two `fdAT`
-            // chunks.  Note that sequence numbers inside `fdAT` chunks are not publically exposed
+            // chunks.  Note that sequence numbers inside `fdAT` chunks are not publicly exposed
             // (but they are still checked when decoding to verify that they are sequential).
             assert_eq!(frame_control.sequence_number, 1);
         }
diff --git a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/decoder/transform.rs b/third_party/rust/chromium_crates_io/vendor/png-0.17.14/src/decoder/transform.rs
similarity index 100%
rename from third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/decoder/transform.rs
rename to third_party/rust/chromium_crates_io/vendor/png-0.17.14/src/decoder/transform.rs
diff --git a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/decoder/transform/palette.rs b/third_party/rust/chromium_crates_io/vendor/png-0.17.14/src/decoder/transform/palette.rs
similarity index 99%
rename from third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/decoder/transform/palette.rs
rename to third_party/rust/chromium_crates_io/vendor/png-0.17.14/src/decoder/transform/palette.rs
index 91e5326ecaa1ae..329c7bd4e69ca7 100644
--- a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/decoder/transform/palette.rs
+++ b/third_party/rust/chromium_crates_io/vendor/png-0.17.14/src/decoder/transform/palette.rs
@@ -1,4 +1,4 @@
-//! Helpers for taking a slice of indeces (indices into `PLTE` and/or `trNS`
+//! Helpers for taking a slice of indices (indices into `PLTE` and/or `trNS`
 //! entries) and transforming this into RGB or RGBA output.
 //!
 //! # Memoization
diff --git a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/decoder/zlib.rs b/third_party/rust/chromium_crates_io/vendor/png-0.17.14/src/decoder/zlib.rs
similarity index 97%
rename from third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/decoder/zlib.rs
rename to third_party/rust/chromium_crates_io/vendor/png-0.17.14/src/decoder/zlib.rs
index 1693154e789232..30cd54f77d08dd 100644
--- a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/decoder/zlib.rs
+++ b/third_party/rust/chromium_crates_io/vendor/png-0.17.14/src/decoder/zlib.rs
@@ -1,4 +1,4 @@
-use super::{stream::FormatErrorInner, DecodingError, CHUNCK_BUFFER_SIZE};
+use super::{stream::FormatErrorInner, DecodingError, CHUNK_BUFFER_SIZE};
 
 use fdeflate::Decompressor;
 
@@ -166,7 +166,7 @@ impl ZlibStream {
         let current_len = self.out_buffer.len();
         let desired_len = self
             .out_pos
-            .saturating_add(CHUNCK_BUFFER_SIZE)
+            .saturating_add(CHUNK_BUFFER_SIZE)
             .min(self.max_total_output);
         if current_len >= desired_len {
             return;
@@ -182,13 +182,13 @@ impl ZlibStream {
         // allocation is valid and that any cursor within it will be valid.
         len
             // This keeps the buffer size a power-of-two, required by miniz_oxide.
-            .saturating_add(CHUNCK_BUFFER_SIZE.max(len))
+            .saturating_add(CHUNK_BUFFER_SIZE.max(len))
             // Ensure all buffer indices are valid cursor positions.
             // Note: both cut off and zero extension give correct results.
-            .min(u64::max_value() as usize)
+            .min(u64::MAX as usize)
             // Ensure the allocation request is valid.
             // TODO: maximum allocation limits?
-            .min(isize::max_value() as usize)
+            .min(isize::MAX as usize)
             // Don't unnecessarily allocate more than `max_total_output`.
             .min(self.max_total_output)
     }
diff --git a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/encoder.rs b/third_party/rust/chromium_crates_io/vendor/png-0.17.14/src/encoder.rs
similarity index 95%
rename from third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/encoder.rs
rename to third_party/rust/chromium_crates_io/vendor/png-0.17.14/src/encoder.rs
index c6db916524f6b2..73e0f1ead36c49 100644
--- a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/encoder.rs
+++ b/third_party/rust/chromium_crates_io/vendor/png-0.17.14/src/encoder.rs
@@ -307,9 +307,6 @@ impl<'a, W: Write> Encoder<'a, W> {
     /// The default filter is [`FilterType::Sub`] which provides a basic prediction algorithm for
     /// sample values based on the previous. For a potentially better compression ratio, at the
     /// cost of more complex processing, try out [`FilterType::Paeth`].
-    ///
-    /// [`FilterType::Sub`]: enum.FilterType.html#variant.Sub
-    /// [`FilterType::Paeth`]: enum.FilterType.html#variant.Paeth
     pub fn set_filter(&mut self, filter: FilterType) {
         self.options.filter = filter;
     }
@@ -320,8 +317,7 @@ impl<'a, W: Write> Encoder<'a, W> {
     /// based on heuristics which minimize the file size for compression rather
     /// than use a single filter for the entire image. The default method is
     /// [`AdaptiveFilterType::NonAdaptive`].
-    ///
-    /// [`AdaptiveFilterType::NonAdaptive`]: enum.AdaptiveFilterType.html
+
     pub fn set_adaptive_filter(&mut self, adaptive_filter: AdaptiveFilterType) {
         self.options.adaptive_filter = adaptive_filter;
     }
@@ -333,7 +329,7 @@ impl<'a, W: Write> Encoder<'a, W> {
     ///
     /// If the denominator is 0, it is to be treated as if it were 100
     /// (that is, the numerator then specifies 1/100ths of a second).
-    /// If the the value of the numerator is 0 the decoder should render the next frame
+    /// If the value of the numerator is 0 the decoder should render the next frame
     /// as quickly as possible, though viewers may impose a reasonable lower bound.
     ///
     /// The default value is 0 for both the numerator and denominator.
@@ -341,9 +337,8 @@ impl<'a, W: Write> Encoder<'a, W> {
     /// This method will return an error if the image is not animated.
     /// (see [`set_animated`])
     ///
-    /// [`write_header`]: struct.Encoder.html#method.write_header
-    /// [`set_animated`]: struct.Encoder.html#method.set_animated
-    /// [`Writer::set_frame_delay`]: struct.Writer#method.set_frame_delay
+    /// [`write_header`]: Self::write_header
+    /// [`set_animated`]: Self::set_animated
     pub fn set_frame_delay(&mut self, numerator: u16, denominator: u16) -> Result<()> {
         if let Some(ref mut fctl) = self.info.frame_control {
             fctl.delay_den = denominator;
@@ -374,11 +369,8 @@ impl<'a, W: Write> Encoder<'a, W> {
     /// This method will return an error if the image is not animated.
     /// (see [`set_animated`])
     ///
-    /// [`BlendOP`]: enum.BlendOp.html
-    /// [`BlendOP::Source`]: enum.BlendOp.html#variant.Source
-    /// [`write_header`]: struct.Encoder.html#method.write_header
-    /// [`set_animated`]: struct.Encoder.html#method.set_animated
-    /// [`Writer::set_blend_op`]: struct.Writer#method.set_blend_op
+    /// [`write_header`]: Self::write_header
+    /// [`set_animated`]: Self::set_animated
     pub fn set_blend_op(&mut self, op: BlendOp) -> Result<()> {
         if let Some(ref mut fctl) = self.info.frame_control {
             fctl.blend_op = op;
@@ -406,13 +398,8 @@ impl<'a, W: Write> Encoder<'a, W> {
     /// This method will return an error if the image is not animated.
     /// (see [`set_animated`])
     ///
-    /// [`DisposeOp`]: ../common/enum.BlendOp.html
-    /// [`DisposeOp::Previous`]: ../common/enum.BlendOp.html#variant.Previous
-    /// [`DisposeOp::Background`]: ../common/enum.BlendOp.html#variant.Background
-    /// [`DisposeOp::None`]: ../common/enum.BlendOp.html#variant.None
-    /// [`write_header`]: struct.Encoder.html#method.write_header
-    /// [`set_animated`]: struct.Encoder.html#method.set_animated
-    /// [`Writer::set_dispose_op`]: struct.Writer#method.set_dispose_op
+    /// [`set_animated`]: Self::set_animated
+    /// [`write_header`]: Self::write_header
     pub fn set_dispose_op(&mut self, op: DisposeOp) -> Result<()> {
         if let Some(ref mut fctl) = self.info.frame_control {
             fctl.dispose_op = op;
@@ -652,9 +639,9 @@ impl<W: Write> Writer<W> {
         }
     }
 
-    const MAX_IDAT_CHUNK_LEN: u32 = std::u32::MAX >> 1;
+    const MAX_IDAT_CHUNK_LEN: u32 = u32::MAX >> 1;
     #[allow(non_upper_case_globals)]
-    const MAX_fdAT_CHUNK_LEN: u32 = (std::u32::MAX >> 1) - 4;
+    const MAX_fdAT_CHUNK_LEN: u32 = (u32::MAX >> 1) - 4;
 
     /// Writes the next image data.
     pub fn write_image_data(&mut self, data: &[u8]) -> Result<()> {
@@ -822,9 +809,6 @@ impl<W: Write> Writer<W> {
     /// The default filter is [`FilterType::Sub`] which provides a basic prediction algorithm for
     /// sample values based on the previous. For a potentially better compression ratio, at the
     /// cost of more complex processing, try out [`FilterType::Paeth`].
-    ///
-    /// [`FilterType::Sub`]: enum.FilterType.html#variant.Sub
-    /// [`FilterType::Paeth`]: enum.FilterType.html#variant.Paeth
     pub fn set_filter(&mut self, filter: FilterType) {
         self.options.filter = filter;
     }
@@ -835,8 +819,6 @@ impl<W: Write> Writer<W> {
     /// based on heuristics which minimize the file size for compression rather
     /// than use a single filter for the entire image. The default method is
     /// [`AdaptiveFilterType::NonAdaptive`].
-    ///
-    /// [`AdaptiveFilterType::NonAdaptive`]: enum.AdaptiveFilterType.html
     pub fn set_adaptive_filter(&mut self, adaptive_filter: AdaptiveFilterType) {
         self.options.adaptive_filter = adaptive_filter;
     }
@@ -846,7 +828,7 @@ impl<W: Write> Writer<W> {
     ///
     /// If the denominator is 0, it is to be treated as if it were 100
     /// (that is, the numerator then specifies 1/100ths of a second).
-    /// If the the value of the numerator is 0 the decoder should render the next frame
+    /// If the value of the numerator is 0 the decoder should render the next frame
     /// as quickly as possible, though viewers may impose a reasonable lower bound.
     ///
     /// This method will return an error if the image is not animated.
@@ -924,7 +906,7 @@ impl<W: Write> Writer<W> {
     ///
     /// This method will return an error if the image is not animated.
     ///
-    /// [`reset_frame_position`]: struct.Writer.html#method.reset_frame_position
+    /// [`reset_frame_position`]: Writer::reset_frame_position
     pub fn reset_frame_dimension(&mut self) -> Result<()> {
         if let Some(ref mut fctl) = self.info.frame_control {
             fctl.width = self.info.width - fctl.x_offset;
@@ -941,7 +923,7 @@ impl<W: Write> Writer<W> {
     ///
     /// This method will return an error if the image is not animated.
     ///
-    /// [`set_frame_position(0, 0)`]: struct.Writer.html#method.set_frame_position
+    /// [`set_frame_position(0, 0)`]: Writer::set_frame_position
     pub fn reset_frame_position(&mut self) -> Result<()> {
         if let Some(ref mut fctl) = self.info.frame_control {
             fctl.x_offset = 0;
@@ -965,8 +947,6 @@ impl<W: Write> Writer<W> {
     /// of each play.*
     ///
     /// This method will return an error if the image is not animated.
-    ///
-    /// [`BlendOP`]: enum.BlendOp.html
     pub fn set_blend_op(&mut self, op: BlendOp) -> Result<()> {
         if let Some(ref mut fctl) = self.info.frame_control {
             fctl.blend_op = op;
@@ -987,10 +967,6 @@ impl<W: Write> Writer<W> {
     /// it will be treated as [`DisposeOp::Background`].*
     ///
     /// This method will return an error if the image is not animated.
-    ///
-    /// [`DisposeOp`]: ../common/enum.BlendOp.html
-    /// [`DisposeOp::Previous`]: ../common/enum.BlendOp.html#variant.Previous
-    /// [`DisposeOp::Background`]: ../common/enum.BlendOp.html#variant.Background
     pub fn set_dispose_op(&mut self, op: DisposeOp) -> Result<()> {
         if let Some(ref mut fctl) = self.info.frame_control {
             fctl.dispose_op = op;
@@ -1016,7 +992,7 @@ impl<W: Write> Writer<W> {
     ///
     /// See [`stream_writer`].
     ///
-    /// [`stream_writer`]: #fn.stream_writer
+    /// [`stream_writer`]: Self::stream_writer
     pub fn stream_writer_with_size(&mut self, size: usize) -> Result<StreamWriter<W>> {
         StreamWriter::new(ChunkOutput::Borrowed(self), size)
     }
@@ -1024,8 +1000,10 @@ impl<W: Write> Writer<W> {
     /// Turn this into a stream writer for image data.
     ///
     /// This allows you to create images that do not fit in memory. The default
-    /// chunk size is 4K, use `stream_writer_with_size` to set another chunk
+    /// chunk size is 4K, use [`stream_writer_with_size`] to set another chunk
     /// size.
+    ///
+    /// [`stream_writer_with_size`]: Self::stream_writer_with_size
     pub fn into_stream_writer(self) -> Result<StreamWriter<'static, W>> {
         self.into_stream_writer_with_size(DEFAULT_BUFFER_LENGTH)
     }
@@ -1034,7 +1012,7 @@ impl<W: Write> Writer<W> {
     ///
     /// See [`into_stream_writer`].
     ///
-    /// [`into_stream_writer`]: #fn.into_stream_writer
+    /// [`into_stream_writer`]: Self::into_stream_writer
     pub fn into_stream_writer_with_size(self, size: usize) -> Result<StreamWriter<'static, W>> {
         StreamWriter::new(ChunkOutput::Owned(self), size)
     }
@@ -1119,7 +1097,7 @@ impl<'a, W: Write> ChunkWriter<'a, W> {
         //
         // TODO (maybe): find a way to hold two chunks at a time if `usize`
         //               is 64 bits.
-        const CAP: usize = std::u32::MAX as usize >> 1;
+        const CAP: usize = u32::MAX as usize >> 1;
         let curr_chunk = if writer.images_written == 0 {
             chunk::IDAT
         } else {
@@ -1182,7 +1160,7 @@ impl<'a, W: Write> ChunkWriter<'a, W> {
         Ok(())
     }
 
-    /// Set the `FrameControl` for the following frame
+    /// Set the [`FrameControl`] for the following frame
     ///
     /// It will ignore the `sequence_number` of the parameter
     /// as it is updated internally.
@@ -1299,9 +1277,10 @@ impl<'a, W: Write> Wrapper<'a, W> {
 /// Streaming PNG writer
 ///
 /// This may silently fail in the destructor, so it is a good idea to call
-/// [`finish`](#method.finish) or [`flush`] before dropping.
+/// [`finish`] or [`flush`] before dropping.
 ///
-/// [`flush`]: https://doc.rust-lang.org/stable/std/io/trait.Write.html#tymethod.flush
+/// [`finish`]: Self::finish
+/// [`flush`]: Write::flush
 pub struct StreamWriter<'a, W: Write> {
     /// The option here is needed in order to access the inner `ChunkWriter` in-between
     /// each frame, which is needed for writing the fcTL chunks between each frame
@@ -1367,11 +1346,11 @@ impl<'a, W: Write> StreamWriter<'a, W> {
     /// Set the used filter type for the next frame.
     ///
     /// The default filter is [`FilterType::Sub`] which provides a basic prediction algorithm for
-    /// sample values based on the previous. For a potentially better compression ratio, at the
-    /// cost of more complex processing, try out [`FilterType::Paeth`].
+    /// sample values based on the previous.
     ///
-    /// [`FilterType::Sub`]: enum.FilterType.html#variant.Sub
-    /// [`FilterType::Paeth`]: enum.FilterType.html#variant.Paeth
+    /// For optimal compression ratio you should enable adaptive filtering
+    /// instead of setting a single filter for the entire image, see
+    /// [set_adaptive_filter](Self::set_adaptive_filter).
     pub fn set_filter(&mut self, filter: FilterType) {
         self.filter = filter;
     }
@@ -1380,10 +1359,9 @@ impl<'a, W: Write> StreamWriter<'a, W> {
     ///
     /// Adaptive filtering attempts to select the best filter for each line
     /// based on heuristics which minimize the file size for compression rather
-    /// than use a single filter for the entire image. The default method is
-    /// [`AdaptiveFilterType::NonAdaptive`].
+    /// than use a single filter for the entire image.
     ///
-    /// [`AdaptiveFilterType::NonAdaptive`]: enum.AdaptiveFilterType.html
+    /// The default method is [`AdaptiveFilterType::NonAdaptive`].
     pub fn set_adaptive_filter(&mut self, adaptive_filter: AdaptiveFilterType) {
         self.adaptive_filter = adaptive_filter;
     }
@@ -1393,7 +1371,7 @@ impl<'a, W: Write> StreamWriter<'a, W> {
     ///
     /// If the denominator is 0, it is to be treated as if it were 100
     /// (that is, the numerator then specifies 1/100ths of a second).
-    /// If the the value of the numerator is 0 the decoder should render the next frame
+    /// If the value of the numerator is 0 the decoder should render the next frame
     /// as quickly as possible, though viewers may impose a reasonable lower bound.
     ///
     /// This method will return an error if the image is not animated.
@@ -1467,7 +1445,7 @@ impl<'a, W: Write> StreamWriter<'a, W> {
     ///
     /// This method will return an error if the image is not animated.
     ///
-    /// [`reset_frame_position`]: struct.Writer.html#method.reset_frame_position
+    /// [`reset_frame_position`]: Writer::reset_frame_position
     pub fn reset_frame_dimension(&mut self) -> Result<()> {
         if let Some(ref mut fctl) = self.fctl {
             fctl.width = self.width - fctl.x_offset;
@@ -1484,7 +1462,7 @@ impl<'a, W: Write> StreamWriter<'a, W> {
     ///
     /// This method will return an error if the image is not animated.
     ///
-    /// [`set_frame_position(0, 0)`]: struct.Writer.html#method.set_frame_position
+    /// [`set_frame_position(0, 0)`]: Writer::set_frame_position
     pub fn reset_frame_position(&mut self) -> Result<()> {
         if let Some(ref mut fctl) = self.fctl {
             fctl.x_offset = 0;
@@ -1508,8 +1486,6 @@ impl<'a, W: Write> StreamWriter<'a, W> {
     /// of each play.*
     ///
     /// This method will return an error if the image is not animated.
-    ///
-    /// [`BlendOP`]: enum.BlendOp.html
     pub fn set_blend_op(&mut self, op: BlendOp) -> Result<()> {
         if let Some(ref mut fctl) = self.fctl {
             fctl.blend_op = op;
@@ -1530,10 +1506,6 @@ impl<'a, W: Write> StreamWriter<'a, W> {
     /// it will be treated as [`DisposeOp::Background`].*
     ///
     /// This method will return an error if the image is not animated.
-    ///
-    /// [`DisposeOp`]: ../common/enum.BlendOp.html
-    /// [`DisposeOp::Previous`]: ../common/enum.BlendOp.html#variant.Previous
-    /// [`DisposeOp::Background`]: ../common/enum.BlendOp.html#variant.Background
     pub fn set_dispose_op(&mut self, op: DisposeOp) -> Result<()> {
         if let Some(ref mut fctl) = self.fctl {
             fctl.dispose_op = op;
@@ -1716,9 +1688,9 @@ mod tests {
     use crate::Decoder;
 
     use rand::{thread_rng, Rng};
+    use std::cmp;
     use std::fs::File;
-    use std::io::{Cursor, Write};
-    use std::{cmp, io};
+    use std::io::Cursor;
 
     #[test]
     fn roundtrip() {
diff --git a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/filter.rs b/third_party/rust/chromium_crates_io/vendor/png-0.17.14/src/filter.rs
similarity index 83%
rename from third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/filter.rs
rename to third_party/rust/chromium_crates_io/vendor/png-0.17.14/src/filter.rs
index 5afed49e0e001e..9290a0402a4e25 100644
--- a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/filter.rs
+++ b/third_party/rust/chromium_crates_io/vendor/png-0.17.14/src/filter.rs
@@ -9,13 +9,13 @@ use crate::common::BytesPerPixel;
 /// feature of Rust gets stabilized.
 #[cfg(feature = "unstable")]
 mod simd {
-    use std::simd::cmp::{SimdOrd, SimdPartialEq};
+    use std::simd::cmp::{SimdOrd, SimdPartialEq, SimdPartialOrd};
     use std::simd::num::{SimdInt, SimdUint};
-    use std::simd::{u8x4, u8x8, LaneCount, Simd, SupportedLaneCount};
+    use std::simd::{u8x4, u8x8, LaneCount, Simd, SimdElement, SupportedLaneCount};
 
     /// This is an equivalent of the `PaethPredictor` function from
     /// [the spec](http://www.libpng.org/pub/png/spec/1.2/PNG-Filters.html#Filter-type-4-Paeth)
-    /// except that it simultaenously calculates the predictor for all SIMD lanes.
+    /// except that it simultaneously calculates the predictor for all SIMD lanes.
     /// Mapping between parameter names and pixel positions can be found in
     /// [a diagram here](https://www.w3.org/TR/png/#filter-byte-positions).
     ///
@@ -53,26 +53,80 @@ mod simd {
             .select(a, smallest.simd_eq(pb).select(b, c))
     }
 
+    /// Equivalent to `simd::paeth_predictor` but does not temporarily convert
+    /// the SIMD elements to `i16`.
+    fn paeth_predictor_u8<const N: usize>(
+        a: Simd<u8, N>,
+        b: Simd<u8, N>,
+        c: Simd<u8, N>,
+    ) -> Simd<u8, N>
+    where
+        LaneCount<N>: SupportedLaneCount,
+    {
+        // Calculates the absolute difference between `a` and `b`.
+        fn abs_diff_simd<const N: usize>(a: Simd<u8, N>, b: Simd<u8, N>) -> Simd<u8, N>
+        where
+            LaneCount<N>: SupportedLaneCount,
+        {
+            a.simd_max(b) - b.simd_min(a)
+        }
+
+        // Uses logic from `filter::filter_paeth` to calculate absolute values
+        // entirely in `Simd<u8, N>`. This method avoids unpacking and packing
+        // penalties resulting from conversion to and from `Simd<i16, N>`.
+        // ```
+        //     let pa = b.max(c) - c.min(b);
+        //     let pb = a.max(c) - c.min(a);
+        //     let pc = if (a < c) == (c < b) {
+        //         pa.max(pb) - pa.min(pb)
+        //     } else {
+        //         255
+        //     };
+        // ```
+        let pa = abs_diff_simd(b, c);
+        let pb = abs_diff_simd(a, c);
+        let pc = a
+            .simd_lt(c)
+            .simd_eq(c.simd_lt(b))
+            .select(abs_diff_simd(pa, pb), Simd::splat(255));
+
+        let smallest = pc.simd_min(pa.simd_min(pb));
+
+        // Paeth algorithm breaks ties favoring a over b over c, so we execute the following
+        // lane-wise selection:
+        //
+        //     if smalest == pa
+        //         then select a
+        //         else select (if smallest == pb then select b else select c)
+        smallest
+            .simd_eq(pa)
+            .select(a, smallest.simd_eq(pb).select(b, c))
+    }
+
     /// Memory of previous pixels (as needed to unfilter `FilterType::Paeth`).
     /// See also https://www.w3.org/TR/png/#filter-byte-positions
     #[derive(Default)]
-    struct PaethState<const N: usize>
+    struct PaethState<T, const N: usize>
     where
+        T: SimdElement,
         LaneCount<N>: SupportedLaneCount,
     {
         /// Previous pixel in the previous row.
-        c: Simd<i16, N>,
+        c: Simd<T, N>,
 
         /// Previous pixel in the current row.
-        a: Simd<i16, N>,
+        a: Simd<T, N>,
     }
 
     /// Mutates `x` as needed to unfilter `FilterType::Paeth`.
     ///
     /// `b` is the current pixel in the previous row.  `x` is the current pixel in the current row.
     /// See also https://www.w3.org/TR/png/#filter-byte-positions
-    fn paeth_step<const N: usize>(state: &mut PaethState<N>, b: Simd<u8, N>, x: &mut Simd<u8, N>)
-    where
+    fn paeth_step<const N: usize>(
+        state: &mut PaethState<i16, N>,
+        b: Simd<u8, N>,
+        x: &mut Simd<u8, N>,
+    ) where
         LaneCount<N>: SupportedLaneCount,
     {
         // Storing the inputs.
@@ -87,6 +141,24 @@ mod simd {
         state.a = x.cast::<i16>();
     }
 
+    /// Computes the Paeth predictor without converting `u8` to `i16`.
+    ///
+    /// See `simd::paeth_step`.
+    fn paeth_step_u8<const N: usize>(
+        state: &mut PaethState<u8, N>,
+        b: Simd<u8, N>,
+        x: &mut Simd<u8, N>,
+    ) where
+        LaneCount<N>: SupportedLaneCount,
+    {
+        // Calculating the new value of the current pixel.
+        *x += paeth_predictor_u8(state.a, b, state.c);
+
+        // Preparing for the next step.
+        state.c = b;
+        state.a = *x;
+    }
+
     fn load3(src: &[u8]) -> u8x4 {
         u8x4::from_array([src[0], src[1], src[2], 0])
     }
@@ -100,7 +172,7 @@ mod simd {
         debug_assert_eq!(prev_row.len(), curr_row.len());
         debug_assert_eq!(prev_row.len() % 3, 0);
 
-        let mut state = PaethState::<4>::default();
+        let mut state = PaethState::<i16, 4>::default();
         while prev_row.len() >= 4 {
             // `u8x4` requires working with `[u8;4]`, but we can just load and ignore the first
             // byte from the next triple.  This optimization technique mimics the algorithm found
@@ -126,6 +198,30 @@ mod simd {
         store3(x, curr_row);
     }
 
+    /// Undoes `FilterType::Paeth` for `BytesPerPixel::Four` and `BytesPerPixel::Eight`.
+    ///
+    /// This function calculates the Paeth predictor entirely in `Simd<u8, N>`
+    /// without converting to an intermediate `Simd<i16, N>`. Doing so avoids
+    /// paying a small performance penalty converting between types.
+    pub fn unfilter_paeth_u8<const N: usize>(prev_row: &[u8], curr_row: &mut [u8])
+    where
+        LaneCount<N>: SupportedLaneCount,
+    {
+        debug_assert_eq!(prev_row.len(), curr_row.len());
+        debug_assert_eq!(prev_row.len() % N, 0);
+        assert!(matches!(N, 4 | 8));
+
+        let mut state = PaethState::<u8, N>::default();
+        for (prev_row, curr_row) in prev_row.chunks_exact(N).zip(curr_row.chunks_exact_mut(N)) {
+            let b = Simd::from_slice(prev_row);
+            let mut x = Simd::from_slice(curr_row);
+
+            paeth_step_u8(&mut state, b, &mut x);
+
+            curr_row[..N].copy_from_slice(&x.to_array()[..N]);
+        }
+    }
+
     fn load6(src: &[u8]) -> u8x8 {
         u8x8::from_array([src[0], src[1], src[2], src[3], src[4], src[5], 0, 0])
     }
@@ -139,7 +235,7 @@ mod simd {
         debug_assert_eq!(prev_row.len(), curr_row.len());
         debug_assert_eq!(prev_row.len() % 6, 0);
 
-        let mut state = PaethState::<8>::default();
+        let mut state = PaethState::<i16, 8>::default();
         while prev_row.len() >= 8 {
             // `u8x8` requires working with `[u8;8]`, but we can just load and ignore the first two
             // bytes from the next pixel.  This optimization technique mimics the algorithm found
@@ -171,6 +267,8 @@ mod simd {
 /// Compression in general benefits from repetitive data. The filter is a content-aware method of
 /// compressing the range of occurring byte values to help the compression algorithm. Note that
 /// this does not operate on pixels but on raw bytes of a scanline.
+///
+/// Details on how each filter works can be found in the [PNG Book](http://www.libpng.org/pub/png/book/chapter09.html).
 #[derive(Debug, Clone, Copy, PartialEq, Eq)]
 #[repr(u8)]
 pub enum FilterType {
@@ -201,12 +299,14 @@ impl FilterType {
     }
 }
 
-/// The filtering method for preprocessing scanline data before compression.
+/// Adaptive filtering tries every possible filter for each row and uses a heuristic to select the best one.
+/// This improves compression ratio, but makes encoding slightly slower.
 ///
-/// Adaptive filtering performs additional computation in an attempt to maximize
-/// the compression of the data. [`NonAdaptive`] filtering is the default.
+/// It is recommended to use `Adaptive` whenever you care about compression ratio.
+/// Filtering is quite cheap compared to other parts of encoding, but can contribute
+/// to the compression ratio significantly.
 ///
-/// [`NonAdaptive`]: enum.AdaptiveFilterType.html#variant.NonAdaptive
+/// `NonAdaptive` filtering is the default.
 #[derive(Debug, Clone, Copy, PartialEq, Eq)]
 #[repr(u8)]
 pub enum AdaptiveFilterType {
@@ -678,23 +778,34 @@ pub(crate) fn unfilter(
                     }
                 }
                 BytesPerPixel::Four => {
-                    let mut a_bpp = [0; 4];
-                    let mut c_bpp = [0; 4];
-                    for (chunk, b_bpp) in current.chunks_exact_mut(4).zip(previous.chunks_exact(4))
+                    #[cfg(feature = "unstable")]
+                    simd::unfilter_paeth_u8::<4>(previous, current);
+
+                    #[cfg(not(feature = "unstable"))]
                     {
-                        let new_chunk = [
-                            chunk[0]
-                                .wrapping_add(filter_paeth_decode(a_bpp[0], b_bpp[0], c_bpp[0])),
-                            chunk[1]
-                                .wrapping_add(filter_paeth_decode(a_bpp[1], b_bpp[1], c_bpp[1])),
-                            chunk[2]
-                                .wrapping_add(filter_paeth_decode(a_bpp[2], b_bpp[2], c_bpp[2])),
-                            chunk[3]
-                                .wrapping_add(filter_paeth_decode(a_bpp[3], b_bpp[3], c_bpp[3])),
-                        ];
-                        *TryInto::<&mut [u8; 4]>::try_into(chunk).unwrap() = new_chunk;
-                        a_bpp = new_chunk;
-                        c_bpp = b_bpp.try_into().unwrap();
+                        let mut a_bpp = [0; 4];
+                        let mut c_bpp = [0; 4];
+                        for (chunk, b_bpp) in
+                            current.chunks_exact_mut(4).zip(previous.chunks_exact(4))
+                        {
+                            let new_chunk = [
+                                chunk[0].wrapping_add(filter_paeth_decode(
+                                    a_bpp[0], b_bpp[0], c_bpp[0],
+                                )),
+                                chunk[1].wrapping_add(filter_paeth_decode(
+                                    a_bpp[1], b_bpp[1], c_bpp[1],
+                                )),
+                                chunk[2].wrapping_add(filter_paeth_decode(
+                                    a_bpp[2], b_bpp[2], c_bpp[2],
+                                )),
+                                chunk[3].wrapping_add(filter_paeth_decode(
+                                    a_bpp[3], b_bpp[3], c_bpp[3],
+                                )),
+                            ];
+                            *TryInto::<&mut [u8; 4]>::try_into(chunk).unwrap() = new_chunk;
+                            a_bpp = new_chunk;
+                            c_bpp = b_bpp.try_into().unwrap();
+                        }
                     }
                 }
                 BytesPerPixel::Six => {
@@ -735,31 +846,46 @@ pub(crate) fn unfilter(
                     }
                 }
                 BytesPerPixel::Eight => {
-                    let mut a_bpp = [0; 8];
-                    let mut c_bpp = [0; 8];
-                    for (chunk, b_bpp) in current.chunks_exact_mut(8).zip(previous.chunks_exact(8))
+                    #[cfg(feature = "unstable")]
+                    simd::unfilter_paeth_u8::<8>(previous, current);
+
+                    #[cfg(not(feature = "unstable"))]
                     {
-                        let new_chunk = [
-                            chunk[0]
-                                .wrapping_add(filter_paeth_decode(a_bpp[0], b_bpp[0], c_bpp[0])),
-                            chunk[1]
-                                .wrapping_add(filter_paeth_decode(a_bpp[1], b_bpp[1], c_bpp[1])),
-                            chunk[2]
-                                .wrapping_add(filter_paeth_decode(a_bpp[2], b_bpp[2], c_bpp[2])),
-                            chunk[3]
-                                .wrapping_add(filter_paeth_decode(a_bpp[3], b_bpp[3], c_bpp[3])),
-                            chunk[4]
-                                .wrapping_add(filter_paeth_decode(a_bpp[4], b_bpp[4], c_bpp[4])),
-                            chunk[5]
-                                .wrapping_add(filter_paeth_decode(a_bpp[5], b_bpp[5], c_bpp[5])),
-                            chunk[6]
-                                .wrapping_add(filter_paeth_decode(a_bpp[6], b_bpp[6], c_bpp[6])),
-                            chunk[7]
-                                .wrapping_add(filter_paeth_decode(a_bpp[7], b_bpp[7], c_bpp[7])),
-                        ];
-                        *TryInto::<&mut [u8; 8]>::try_into(chunk).unwrap() = new_chunk;
-                        a_bpp = new_chunk;
-                        c_bpp = b_bpp.try_into().unwrap();
+                        let mut a_bpp = [0; 8];
+                        let mut c_bpp = [0; 8];
+                        for (chunk, b_bpp) in
+                            current.chunks_exact_mut(8).zip(previous.chunks_exact(8))
+                        {
+                            let new_chunk = [
+                                chunk[0].wrapping_add(filter_paeth_decode(
+                                    a_bpp[0], b_bpp[0], c_bpp[0],
+                                )),
+                                chunk[1].wrapping_add(filter_paeth_decode(
+                                    a_bpp[1], b_bpp[1], c_bpp[1],
+                                )),
+                                chunk[2].wrapping_add(filter_paeth_decode(
+                                    a_bpp[2], b_bpp[2], c_bpp[2],
+                                )),
+                                chunk[3].wrapping_add(filter_paeth_decode(
+                                    a_bpp[3], b_bpp[3], c_bpp[3],
+                                )),
+                                chunk[4].wrapping_add(filter_paeth_decode(
+                                    a_bpp[4], b_bpp[4], c_bpp[4],
+                                )),
+                                chunk[5].wrapping_add(filter_paeth_decode(
+                                    a_bpp[5], b_bpp[5], c_bpp[5],
+                                )),
+                                chunk[6].wrapping_add(filter_paeth_decode(
+                                    a_bpp[6], b_bpp[6], c_bpp[6],
+                                )),
+                                chunk[7].wrapping_add(filter_paeth_decode(
+                                    a_bpp[7], b_bpp[7], c_bpp[7],
+                                )),
+                            ];
+                            *TryInto::<&mut [u8; 8]>::try_into(chunk).unwrap() = new_chunk;
+                            a_bpp = new_chunk;
+                            c_bpp = b_bpp.try_into().unwrap();
+                        }
                     }
                 }
             }
@@ -777,7 +903,7 @@ fn filter_internal(
 ) -> FilterType {
     use self::FilterType::*;
 
-    // This value was chosen experimentally based on what acheived the best performance. The
+    // This value was chosen experimentally based on what achieved the best performance. The
     // Rust compiler does auto-vectorization, and 32-bytes per loop iteration seems to enable
     // the fastest code when doing so.
     const CHUNK_SIZE: usize = 32;
diff --git a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/lib.rs b/third_party/rust/chromium_crates_io/vendor/png-0.17.14/src/lib.rs
similarity index 92%
rename from third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/lib.rs
rename to third_party/rust/chromium_crates_io/vendor/png-0.17.14/src/lib.rs
index 72450abff41793..9e8a2113628ca2 100644
--- a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/lib.rs
+++ b/third_party/rust/chromium_crates_io/vendor/png-0.17.14/src/lib.rs
@@ -4,9 +4,9 @@
 //!
 //! ## The decoder
 //!
-//! The most important types for decoding purposes are [`Decoder`](struct.Decoder.html) and
-//! [`Reader`](struct.Reader.html). They both wrap a `std::io::Read`.
-//! `Decoder` serves as a builder for `Reader`. Calling `Decoder::read_info` reads from the `Read` until the
+//! The most important types for decoding purposes are [`Decoder`] and
+//! [`Reader`]. They both wrap a [`std::io::Read`].
+//! `Decoder` serves as a builder for `Reader`. Calling [`Decoder::read_info`] reads from the `Read` until the
 //! image data is reached.
 //!
 //! ### Using the decoder
@@ -61,9 +61,6 @@
 #![cfg_attr(feature = "unstable", feature(portable_simd))]
 #![forbid(unsafe_code)]
 
-#[macro_use]
-extern crate bitflags;
-
 mod adam7;
 pub mod chunk;
 mod common;
diff --git a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/srgb.rs b/third_party/rust/chromium_crates_io/vendor/png-0.17.14/src/srgb.rs
similarity index 100%
rename from third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/srgb.rs
rename to third_party/rust/chromium_crates_io/vendor/png-0.17.14/src/srgb.rs
diff --git a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/test_utils.rs b/third_party/rust/chromium_crates_io/vendor/png-0.17.14/src/test_utils.rs
similarity index 100%
rename from third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/test_utils.rs
rename to third_party/rust/chromium_crates_io/vendor/png-0.17.14/src/test_utils.rs
diff --git a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/text_metadata.rs b/third_party/rust/chromium_crates_io/vendor/png-0.17.14/src/text_metadata.rs
similarity index 100%
rename from third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/text_metadata.rs
rename to third_party/rust/chromium_crates_io/vendor/png-0.17.14/src/text_metadata.rs
diff --git a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/traits.rs b/third_party/rust/chromium_crates_io/vendor/png-0.17.14/src/traits.rs
similarity index 100%
rename from third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/traits.rs
rename to third_party/rust/chromium_crates_io/vendor/png-0.17.14/src/traits.rs
diff --git a/third_party/rust/miniz_oxide/v0_7/BUILD.gn b/third_party/rust/miniz_oxide/v0_7/BUILD.gn
deleted file mode 100644
index d1ac1a0248cbe7..00000000000000
--- a/third_party/rust/miniz_oxide/v0_7/BUILD.gn
+++ /dev/null
@@ -1,56 +0,0 @@
-# Copyright 2023 The Chromium Authors
-# Use of this source code is governed by a BSD-style license that can be
-# found in the LICENSE file.
-
-# @generated from third_party/rust/chromium_crates_io/BUILD.gn.hbs by
-# tools/crates/gnrt.
-# Do not edit!
-
-import("//build/rust/cargo_crate.gni")
-
-cargo_crate("lib") {
-  crate_name = "miniz_oxide"
-  epoch = "0.7"
-  crate_type = "rlib"
-  crate_root = "//third_party/rust/chromium_crates_io/vendor/miniz_oxide-0.7.4/src/lib.rs"
-  sources = [
-    "//third_party/rust/chromium_crates_io/vendor/miniz_oxide-0.7.4/src/deflate/buffer.rs",
-    "//third_party/rust/chromium_crates_io/vendor/miniz_oxide-0.7.4/src/deflate/core.rs",
-    "//third_party/rust/chromium_crates_io/vendor/miniz_oxide-0.7.4/src/deflate/mod.rs",
-    "//third_party/rust/chromium_crates_io/vendor/miniz_oxide-0.7.4/src/deflate/stream.rs",
-    "//third_party/rust/chromium_crates_io/vendor/miniz_oxide-0.7.4/src/inflate/core.rs",
-    "//third_party/rust/chromium_crates_io/vendor/miniz_oxide-0.7.4/src/inflate/mod.rs",
-    "//third_party/rust/chromium_crates_io/vendor/miniz_oxide-0.7.4/src/inflate/output_buffer.rs",
-    "//third_party/rust/chromium_crates_io/vendor/miniz_oxide-0.7.4/src/inflate/stream.rs",
-    "//third_party/rust/chromium_crates_io/vendor/miniz_oxide-0.7.4/src/lib.rs",
-    "//third_party/rust/chromium_crates_io/vendor/miniz_oxide-0.7.4/src/shared.rs",
-  ]
-  inputs = []
-
-  build_native_rust_unit_tests = false
-  edition = "2018"
-  cargo_pkg_version = "0.7.4"
-  cargo_pkg_authors = "Frommi <daniil.liferenko@gmail.com>, oyvindln <oyvindln@users.noreply.github.com>"
-  cargo_pkg_name = "miniz_oxide"
-  cargo_pkg_description = "DEFLATE compression and decompression library rewritten in Rust based on miniz"
-  library_configs -= [ "//build/config/compiler:chromium_code" ]
-  library_configs += [ "//build/config/compiler:no_chromium_code" ]
-  executable_configs -= [ "//build/config/compiler:chromium_code" ]
-  executable_configs += [ "//build/config/compiler:no_chromium_code" ]
-  proc_macro_configs -= [ "//build/config/compiler:chromium_code" ]
-  proc_macro_configs += [ "//build/config/compiler:no_chromium_code" ]
-  deps = [
-    "//third_party/rust/adler/v1:lib",
-    "//third_party/rust/simd_adler32/v0_3:lib",
-  ]
-  features = [
-    "simd",
-    "simd-adler32",
-    "with-alloc",
-  ]
-
-  # Only for usage from third-party crates. Add the crate to
-  # //third_party/rust/chromium_crates_io/Cargo.toml to use
-  # it from first-party code.
-  visibility = [ "//third_party/rust/*" ]
-}
diff --git a/third_party/rust/miniz_oxide/v0_7/README.chromium b/third_party/rust/miniz_oxide/v0_7/README.chromium
deleted file mode 100644
index 0eb8e9bb85e348..00000000000000
--- a/third_party/rust/miniz_oxide/v0_7/README.chromium
+++ /dev/null
@@ -1,9 +0,0 @@
-Name: miniz_oxide
-URL: https://crates.io/crates/miniz_oxide
-Description: DEFLATE compression and decompression library rewritten in Rust based on miniz
-Version: 0.7.4
-Security Critical: yes
-Shipped: yes
-License: Apache 2.0
-License File: //third_party/rust/chromium_crates_io/vendor/miniz_oxide-0.7.4/LICENSE,//third_party/rust/chromium_crates_io/vendor/miniz_oxide-0.7.4/LICENSE-APACHE.md
-Revision: 084c21bcaa0a788f330b15af5abc1bd33bce13a6
diff --git a/third_party/rust/miniz_oxide/v0_8/BUILD.gn b/third_party/rust/miniz_oxide/v0_8/BUILD.gn
index 08acefa8cb059e..7d4b4aa1a3a651 100644
--- a/third_party/rust/miniz_oxide/v0_8/BUILD.gn
+++ b/third_party/rust/miniz_oxide/v0_8/BUILD.gn
@@ -39,8 +39,15 @@ cargo_crate("lib") {
   executable_configs += [ "//build/config/compiler:no_chromium_code" ]
   proc_macro_configs -= [ "//build/config/compiler:chromium_code" ]
   proc_macro_configs += [ "//build/config/compiler:no_chromium_code" ]
-  deps = [ "//third_party/rust/adler2/v2:lib" ]
-  features = [ "with-alloc" ]
+  deps = [
+    "//third_party/rust/adler2/v2:lib",
+    "//third_party/rust/simd_adler32/v0_3:lib",
+  ]
+  features = [
+    "simd",
+    "simd-adler32",
+    "with-alloc",
+  ]
 
   # Only for usage from third-party crates. Add the crate to
   # //third_party/rust/chromium_crates_io/Cargo.toml to use
diff --git a/third_party/rust/png/v0_17/BUILD.gn b/third_party/rust/png/v0_17/BUILD.gn
index 0c090a40d0428d..d9231d6427968c 100644
--- a/third_party/rust/png/v0_17/BUILD.gn
+++ b/third_party/rust/png/v0_17/BUILD.gn
@@ -13,31 +13,31 @@ cargo_crate("lib") {
   epoch = "0.17"
   crate_type = "rlib"
   crate_root =
-      "//third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/lib.rs"
+      "//third_party/rust/chromium_crates_io/vendor/png-0.17.14/src/lib.rs"
   sources = [
-    "//third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/adam7.rs",
-    "//third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/benchable_apis.rs",
-    "//third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/chunk.rs",
-    "//third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/common.rs",
-    "//third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/decoder/interlace_info.rs",
-    "//third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/decoder/mod.rs",
-    "//third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/decoder/stream.rs",
-    "//third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/decoder/transform.rs",
-    "//third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/decoder/transform/palette.rs",
-    "//third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/decoder/zlib.rs",
-    "//third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/encoder.rs",
-    "//third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/filter.rs",
-    "//third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/lib.rs",
-    "//third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/srgb.rs",
-    "//third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/test_utils.rs",
-    "//third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/text_metadata.rs",
-    "//third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/traits.rs",
+    "//third_party/rust/chromium_crates_io/vendor/png-0.17.14/src/adam7.rs",
+    "//third_party/rust/chromium_crates_io/vendor/png-0.17.14/src/benchable_apis.rs",
+    "//third_party/rust/chromium_crates_io/vendor/png-0.17.14/src/chunk.rs",
+    "//third_party/rust/chromium_crates_io/vendor/png-0.17.14/src/common.rs",
+    "//third_party/rust/chromium_crates_io/vendor/png-0.17.14/src/decoder/interlace_info.rs",
+    "//third_party/rust/chromium_crates_io/vendor/png-0.17.14/src/decoder/mod.rs",
+    "//third_party/rust/chromium_crates_io/vendor/png-0.17.14/src/decoder/stream.rs",
+    "//third_party/rust/chromium_crates_io/vendor/png-0.17.14/src/decoder/transform.rs",
+    "//third_party/rust/chromium_crates_io/vendor/png-0.17.14/src/decoder/transform/palette.rs",
+    "//third_party/rust/chromium_crates_io/vendor/png-0.17.14/src/decoder/zlib.rs",
+    "//third_party/rust/chromium_crates_io/vendor/png-0.17.14/src/encoder.rs",
+    "//third_party/rust/chromium_crates_io/vendor/png-0.17.14/src/filter.rs",
+    "//third_party/rust/chromium_crates_io/vendor/png-0.17.14/src/lib.rs",
+    "//third_party/rust/chromium_crates_io/vendor/png-0.17.14/src/srgb.rs",
+    "//third_party/rust/chromium_crates_io/vendor/png-0.17.14/src/test_utils.rs",
+    "//third_party/rust/chromium_crates_io/vendor/png-0.17.14/src/text_metadata.rs",
+    "//third_party/rust/chromium_crates_io/vendor/png-0.17.14/src/traits.rs",
   ]
   inputs = []
 
   build_native_rust_unit_tests = false
   edition = "2018"
-  cargo_pkg_version = "0.17.13"
+  cargo_pkg_version = "0.17.14"
   cargo_pkg_authors = "The image-rs Developers"
   cargo_pkg_name = "png"
   cargo_pkg_description = "PNG decoding and encoding library in pure Rust"
@@ -52,7 +52,7 @@ cargo_crate("lib") {
     "//third_party/rust/crc32fast/v1:lib",
     "//third_party/rust/fdeflate/v0_3:lib",
     "//third_party/rust/flate2/v1:lib",
-    "//third_party/rust/miniz_oxide/v0_7:lib",
+    "//third_party/rust/miniz_oxide/v0_8:lib",
   ]
   features = [ "unstable" ]
 }
diff --git a/third_party/rust/png/v0_17/README.chromium b/third_party/rust/png/v0_17/README.chromium
index 9e022d35503edf..1ab74446f4b2fd 100644
--- a/third_party/rust/png/v0_17/README.chromium
+++ b/third_party/rust/png/v0_17/README.chromium
@@ -1,9 +1,9 @@
 Name: png
 URL: https://crates.io/crates/png
 Description: PNG decoding and encoding library in pure Rust
-Version: 0.17.13
+Version: 0.17.14
 Security Critical: yes
 Shipped: yes
 License: Apache 2.0
-License File: //third_party/rust/chromium_crates_io/vendor/png-0.17.13/LICENSE-APACHE
-Revision: b5b0d48ee352d638db2810f3083d9323094854f4
+License File: //third_party/rust/chromium_crates_io/vendor/png-0.17.14/LICENSE-APACHE
+Revision: 347dc5dd3ddee8d2d3ef77a2f03a7d59b6c6fe80
